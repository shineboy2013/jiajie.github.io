<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jiajie&#39;s blog</title>
  
  <subtitle>每天积累多一些</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shineboy2013.github.com/"/>
  <updated>2018-02-01T07:40:34.860Z</updated>
  <id>https://shineboy2013.github.com/</id>
  
  <author>
    <name>KK Shum</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 004 Median of Two Sorted Arrays</title>
    <link href="https://shineboy2013.github.com/2018/01/31/lee-004/"/>
    <id>https://shineboy2013.github.com/2018/01/31/lee-004/</id>
    <published>2018-02-01T03:24:53.428Z</published>
    <updated>2018-02-01T07:40:34.860Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/median-of-two-sorted-arrays" target="_blank" rel="noopener">LeetCode 004 Median of Two Sorted Arrays</a></strong></p><p>There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size m and n respectively.</p><p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p><p><strong>Example 1:</strong>  </p><pre>nums1 = [1, 3]nums2 = [2]The median is 2.0</pre><p><strong>Example 2:</strong>  </p><pre>nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5</pre><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求两个有序数组中的中位数。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>题目要求log(m+n)复杂度，也就提示要对数组总长做二分法。因为要同时处理两个数组所以考虑用递归版二分法。因奇偶中位数有1-2个，<br>所以加强命题为求两有序数组的第k个数(k&gt;=1)。<br>对k的值进行二分k/2，先尝试num1数组的第k/2个数和num2数组的第k/2个数。若它们相等，表示它们即为第k个数。若它们不等，不妨假设<br>aKey&lt;bKey，这样表示第k个数一定不会是aKey，因为即使比bKey小的数均小于aKey的话（有k/2-1个），总共有k/2-1+k/2-1=k-2个数小于<br>aKey，也就是aKey为第k-1个数，不可能为第k个数，它只可能出现是bKey或者在num1中比aKey大的数。既然aKey不是解，比aKey小的数<br>更不可能是解。所以，可以抛掉num1[0, k/2]这部分，转而求num1[k/2+1,nums.length-1]以及nums2的第k-k/2个数，抛掉部分会影响结果<br>吗？答案是否定的。比如<br>1 2 3 4<br>0 6 7 8<br>k=4，比较2和6,2&lt;6抛掉1 2，转求[3,4],[0,6,7,8]的第2个数，答案仍为3，不影响结果，因为前k/2个数即使有些在nums2也不会影响<br>最后结果，求的是第k个。<br>1 2 9 9<br>0 6 7 8<br>第k=4数可能出现在num1[k/2+1,nums.length-1]=3或num2=6（下面例子），所以保留部分是正确的。<br>主要思路是<strong>每次递归抛掉k/2个数，数组规模减少k/2，k变成k-k/2</strong>, API为left, left2表示新数组的左边界以及k。<br>递归终止条件为</p><ol><li>left越界，归结为求另一数组[left..]的第k个数  </li><li>k为1时候，是基本情况，表示求两数组的第1个数，只要返回左端的最小值即可。  </li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>中位数有1-2两个。</li><li>off by 1的问题。若API中的k定义为第k个数k&gt;=1，若总长len=5，中位数为第len/2+1=3个数。所以在递归函数中，数组下标用到k时<br>都要-1。抛掉[left, left+k/2-1],递归[left+k/2..]。</li><li>若nums中left+k/2-1越界，不碰nums，右移left2，因为nums不能右移那么多。</li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] num1, <span class="keyword">int</span>[] num2)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = num1.length+num2.length;</span><br><span class="line"><span class="keyword">if</span>(len%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> findKth(num1,num2,<span class="number">0</span>,<span class="number">0</span>,len/<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> (findKth(num1,num2,<span class="number">0</span>,<span class="number">0</span>,len/<span class="number">2</span>)+findKth(num1,num2,<span class="number">0</span>,<span class="number">0</span>,len/<span class="number">2</span>+<span class="number">1</span>))/<span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="keyword">int</span>[] num1, <span class="keyword">int</span>[] num2, <span class="keyword">int</span> left, <span class="keyword">int</span> left2, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left&gt;=num1.length)</span><br><span class="line"><span class="keyword">return</span> num2[left2+k-<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span>(left2&gt;=num2.length)</span><br><span class="line"><span class="keyword">return</span> num1[left+k-<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> Math.min(num1[left], num2[left2]);;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> aKey = left+k/<span class="number">2</span>-<span class="number">1</span>&lt;num1.length?num1[left+k/<span class="number">2</span>-<span class="number">1</span>]:Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">int</span> bKey = left2+k/<span class="number">2</span>-<span class="number">1</span>&lt;num2.length?num2[left2+k/<span class="number">2</span>-<span class="number">1</span>]:Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">if</span>(aKey&lt;bKey)</span><br><span class="line"><span class="keyword">return</span> findKth(num1,num2,left+k/<span class="number">2</span>,left2,k-k/<span class="number">2</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> findKth(num1,num2,left,left2+k/<span class="number">2</span>, k-k/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>假设两数组总长度为N，k为中位数即N/2，每次抛掉k/2也就是子问题规模为N-k/2=N-N/4=3N/4. f(N)=f(3N/4)+1.<br>利用master理论b=4/3, a=1, f(n)=1代入时间复杂度为<code>O(log(m+n))</code>，空间复杂度<code>O(1)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/median-of-two-sorted-arrays&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 004 Median of Two Sor
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="https://shineboy2013.github.com/tags/Binary-Search/"/>
    
      <category term="Divide and Conquer" scheme="https://shineboy2013.github.com/tags/Divide-and-Conquer/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 006 ZigZag Conversion</title>
    <link href="https://shineboy2013.github.com/2018/01/30/lee-006/"/>
    <id>https://shineboy2013.github.com/2018/01/30/lee-006/</id>
    <published>2018-01-31T06:11:31.902Z</published>
    <updated>2018-01-31T06:41:25.803Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/zigzag-conversion" target="_blank" rel="noopener">LeetCode 006 ZigZag Conversion</a></strong></p><p>The string <code>&quot;PAYPALISHIRING&quot;</code> is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p><pre>P   A   H   NA P L S I I GY   I   R</pre><p>And then read line by line: <code>&quot;PAHNAPLSIIGYIR&quot;</code></p><p>Write the code that will take a string and make this conversion given a number of rows:</p><pre>string convert(string text, int nRows);</pre><p><code>convert(&quot;PAYPALISHIRING&quot;, 3)</code> should return <code>&quot;PAHNAPLSIIGYIR&quot;</code>.</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定字符串按如上的“Z”字锯齿形进行按行重排。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这是一个周期性的字符串。周期是竖+折（不含首节点）。<br><img src="/images/L006.png" alt=""><br>首节点和竖的最后一点在每周期只会出现一次，其他点会出现两次。<br>T=2<em>numRows-2(因为不含竖节点最后一点+折线上的最后一点属于另一个周期)。nT是有几个周期，即使不完成的周期也算一个。<br>按行遍历（实质是周期上的每个点），再按周期遍历，非顶点有两个需加入：j</em>T+i,(j+1)*T-i。由于周期可能不完成，只要写一个API检查边界且加入字符即可。</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><p>一个字符的字符串。此时T=0.直接返回原字符串。</p><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convert2</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="keyword">int</span> T = numRows*<span class="number">2</span>-<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line"><span class="keyword">int</span> nT = (<span class="keyword">int</span>)Math.ceil((s.length()+<span class="number">0.0</span>)/T);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numRows;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nT;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span> || i==numRows-<span class="number">1</span>)</span><br><span class="line">sb.append(addChar(s, j*T+i));</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">sb.append(addChar(s, j*T+i));</span><br><span class="line">sb.append(addChar(s, (j+<span class="number">1</span>)*T-i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addChar</span><span class="params">(String s, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">String a = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">if</span>(index&lt;s.length())</span><br><span class="line"><span class="keyword">return</span> s.substring(index, index+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/zigzag-conversion&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 006 ZigZag Conversion&lt;/a&gt;&lt;/stro
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 253 Meeting Rooms II</title>
    <link href="https://shineboy2013.github.com/2018/01/29/lee-253/"/>
    <id>https://shineboy2013.github.com/2018/01/29/lee-253/</id>
    <published>2018-01-30T06:07:55.170Z</published>
    <updated>2018-01-30T06:57:24.417Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/meeting-rooms-ii/" target="_blank" rel="noopener">LeetCode 253 Meeting Rooms II</a></strong></p><p>Given an array of meeting time intervals consisting of start and end times <code>[[s1,e1],[s2,e2],...]</code> (si &lt; ei), find the minimum number of conference rooms required.</p><p>For example,<br>Given <code>[[0, 30],[5, 10],[15, 20]]</code>,<br>return <code>2</code>.</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>输入[[0, 30],[5, 10],[15, 20]]表示每个会议的开始结束时间，求最少需要多少会议室能够安排所有的会议。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>基于merging interval题目，首先按start排序。并且merge条件是start大于上一个会议的end。</p><ol><li>写几个例子感受一下。<br><img src="/images/L253.png" alt=""><br>有两个重叠的会议，现在插入新的会议。是否再需要一个会议室取决于该新会议的开始时间大于这两个目前会议的终止时间的最小值。<br>所以思路是用End time min-heap维护目前会议End time。若新会议start time大于堆顶元素，入栈且activeMeeting++，否则循环地出栈且activeMeeting–。<br>这过程activeMeeting的最大值即所求。</li><li>证明解与具体间隔无关，只与end time的值有关。<br><img src="/images/L253-2.png" alt=""></li><li>基于1和2，对end time进行排序，题解只与start-end的相对顺序有关。既然这样，我们可以把所有start，end一起排序，也就是按时间轴排列，排成一个2n大小的数组，<br>遇到start，activeMeeting++，遇到end，activeMeeting–。 这过程activeMeeting的最大值即所求。<br>当然，上述方法直观，但实现起来需要建立一个class Node{value, startOrEnd}。本质上等价于对排序后的start数组和排序后的end数组进行<strong>合并排序</strong>。<br>合并排序的结果等价于时间轴上两个数组的统一排序。当然，不需要剩余部分的合并排序，因为这部分不会增加activeMeeting的值。</li></ol><p>解题步骤：</p><ol><li>排序start</li><li>排序end</li><li>合并排序，start小就activeMeeting++，否则activeMeeting–。求activeMeeting的最大值。</li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><p><a href="http://blog.csdn.net/jmspan/article/details/51093343" target="_blank" rel="noopener">http://blog.csdn.net/jmspan/article/details/51093343</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/meeting-rooms-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 253 Meeting Rooms II&lt;/a&gt;&lt;/stron
      
    
    </summary>
    
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 572 Subtree of Another Tree</title>
    <link href="https://shineboy2013.github.com/2018/01/29/lee-572/"/>
    <id>https://shineboy2013.github.com/2018/01/29/lee-572/</id>
    <published>2018-01-29T09:33:24.224Z</published>
    <updated>2018-01-29T09:52:31.388Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/subtree-of-another-tree" target="_blank" rel="noopener">LeetCode 572 Subtree of Another Tree</a></strong></p><p>Given two non-empty binary trees <strong>s</strong> and <strong>t</strong>, check whether tree <strong>t</strong> has exactly the same structure and node values with a subtree of <strong>s</strong>. A subtree of <strong>s</strong> is a tree consists of a node in <strong>s</strong> and all of this node’s descendants. The tree <strong>s</strong> could also be considered as a subtree of itself.</p><p><strong>Example 1:</strong><br>Given tree s:</p><pre>     3    / \   4   5  / \ 1   2</pre><p>Given tree t:</p><pre>   4   / \ 1   2</pre><p>Return <strong>true</strong>, because t has the same structure and node values with a subtree of s.</p><p><strong>Example 2:</strong><br>Given tree s:</p><pre>     3    / \   4   5  / \ 1   2    /   0</pre><p>Given tree t:</p><pre>   4  / \ 1   2</pre><p>Return <strong>false</strong>.</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定两个非空二叉树s和t，判断t是否是s的子树。s的子树是指由s中某节点及该节点的所有子节点构成的二叉树。<br>特别的，s是其本身的子树。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这是A公司的题目。DFS解题：</p><ol><li>s树的每一个节点与t树的根节点比较，若值相等进行下一步。</li><li>s树的某节点为根的子树和t树进行结构+值比较。</li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>s=null和t=null，是子树</li><li>s和t任一为空，另一个不为空，不是子树。</li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(isSame(s, t))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span>(t==<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> s!=<span class="keyword">null</span> &amp;&amp; (isSubtree(s.left, t) || isSubtree(s.right, t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSame</span><span class="params">(TreeNode root, TreeNode root2)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="keyword">null</span> &amp;&amp; root2 == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="keyword">null</span> || root2 == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> root.val==root2.val &amp;&amp; isSame(root.left,root2.left) &amp;&amp; isSame(root.right, root2.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nm)</code>，空间复杂度<code>O(1)</code>，n和m分别为s数和t数大小。</p><h3 id="Follow-up"><a href="#Follow-up" class="headerlink" title="Follow-up:"></a><strong>Follow-up:</strong></h3><p>如果s数是BST，怎么改进算法？<br>二分法先找到s的节点值等于t根节点值的节点再比较。时间复杂度为<code>O(logn+m)</code>。若BST不是严格递增，多比较几个相等节点即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/subtree-of-another-tree&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 572 Subtree of Another Tr
      
    
    </summary>
    
    
      <category term="Interviewer" scheme="https://shineboy2013.github.com/tags/Interviewer/"/>
    
      <category term="Tree" scheme="https://shineboy2013.github.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 57 Insert Interval</title>
    <link href="https://shineboy2013.github.com/2018/01/29/lee-057/"/>
    <id>https://shineboy2013.github.com/2018/01/29/lee-057/</id>
    <published>2018-01-29T08:54:24.407Z</published>
    <updated>2018-01-29T09:52:11.980Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/insert-interval" target="_blank" rel="noopener">LeetCode 57 Insert Interval</a></strong></p><p>Given a set of <em>non-overlapping</em> intervals, insert a new interval into the intervals (merge if necessary).</p><p>You may assume that the intervals were initially sorted according to their start times.</p><p><strong>Example 1:</strong><br>Given intervals <code>[1,3],[6,9]</code>, insert and merge <code>[2,5]</code> in as <code>[1,5],[6,9]</code>.</p><p><strong>Example 2:</strong><br>Given <code>[1,2],[3,5],[6,7],[8,10],[12,16]</code>, insert and merge <code>[4,9]</code> in as <code>[1,2],[3,10],[12,16]</code>.</p><p>This is because the new interval <code>[4,9]</code> overlaps with <code>[3,5],[6,7],[8,10]</code>.</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>对于给出的互不重叠且按照左端点排序的区间序列，将一个新的区间插入到这个序列当中（合并重叠的区间），使其仍然保持原本的性质。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>与L56题基本一致，但单元测试更加严格，加入含最大整数值的区间。</p><ol><li>先找到start大于等于待插入区间的区间，然后待插入区间插入其前。</li><li>归结成L56题</li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><p>判断是否合并的API中，加入in2.start == Integer.MAX_VALUE返回false。</p><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title">merge</span><span class="params">(List&lt;Interval&gt; intervals)</span> </span>&#123;</span><br><span class="line">Collections.sort(intervals, <span class="keyword">new</span> Comparator&lt;Interval&gt;()&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Interval v1, Interval v2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1.start - v2.start;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">intervals.add(<span class="keyword">new</span> Interval(Integer.MAX_VALUE, Integer.MAX_VALUE));</span><br><span class="line">List&lt;Interval&gt; re = <span class="keyword">new</span> ArrayList&lt;Interval&gt;();</span><br><span class="line">Interval newInterval = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;intervals.size();i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(newInterval==<span class="keyword">null</span>)</span><br><span class="line">newInterval = intervals.get(i-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(canMerge(newInterval,intervals.get(i)))&#123;</span><br><span class="line">newInterval = mergeIntervals(newInterval,intervals.get(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">re.add(newInterval);</span><br><span class="line">newInterval = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//假设in与in2按start排序，所以只有两情况：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * In  -------</span></span><br><span class="line"><span class="comment"> * In2   ---</span></span><br><span class="line"><span class="comment"> * In2   -------- </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canMerge</span><span class="params">(Interval in, Interval in2)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(in2.start == Integer.MAX_VALUE)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> in.end&gt;=in2.start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Interval <span class="title">mergeIntervals</span><span class="params">(Interval in, Interval in2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Interval(in.start, Math.max(in.end, in2.end));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(1)</code>，因为不用排序。</p><h3 id="Follow-up"><a href="#Follow-up" class="headerlink" title="Follow-up:"></a><strong>Follow-up:</strong></h3><ol><li>先解出L56</li><li>再解此题</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/insert-interval&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 57 Insert Interval&lt;/a&gt;&lt;/strong&gt;&lt;/
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Sort" scheme="https://shineboy2013.github.com/tags/Sort/"/>
    
      <category term="Interviewer" scheme="https://shineboy2013.github.com/tags/Interviewer/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 56 Merge Intervals</title>
    <link href="https://shineboy2013.github.com/2018/01/28/lee-056/"/>
    <id>https://shineboy2013.github.com/2018/01/28/lee-056/</id>
    <published>2018-01-29T07:52:23.474Z</published>
    <updated>2018-01-29T09:03:48.685Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/merge-interval" target="_blank" rel="noopener">LeetCode 56 Merge Intervals</a></strong></p><p>Given a collection of intervals, merge all overlapping intervals.</p><p>For example,<br>Given <code>[1,3],[2,6],[8,10],[15,18]</code>,<br>return <code>[1,6],[8,10],[15,18]</code>.</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定几个区间，要求合并重叠区间，返回结果.</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>A公司的考题。这条题难点在于判断是否合并，怎么合并，新区间合并多个区间。</p><ol><li>按start排序。</li><li>定义API：如何合并两个区间（两情况），两个区间是否可以合并</li><li>加入空区间到末尾</li><li>遍历每个区间，产生新区间并将其带入到下一轮循环。</li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>区间的右端与另一个区间的左端一样，也算重叠，如[1,2],[3,4]。</li><li>原输入末端加入空节点（左右端均为最大值，不能为最小值或0，表示不可能合并），避免1.处理单一区间输入。2. 最后一个区间的情况。</li><li>合并后生成新区间，要与下一个继续尝试合并。</li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title">merge</span><span class="params">(List&lt;Interval&gt; intervals)</span> </span>&#123;</span><br><span class="line">Collections.sort(intervals, <span class="keyword">new</span> Comparator&lt;Interval&gt;()&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Interval v1, Interval v2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1.start - v2.start;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">intervals.add(<span class="keyword">new</span> Interval(Integer.MAX_VALUE, Integer.MAX_VALUE));</span><br><span class="line">List&lt;Interval&gt; re = <span class="keyword">new</span> ArrayList&lt;Interval&gt;();</span><br><span class="line">Interval newInterval = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;intervals.size();i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(newInterval==<span class="keyword">null</span>)</span><br><span class="line">newInterval = intervals.get(i-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(canMerge(newInterval,intervals.get(i)))&#123;</span><br><span class="line">newInterval = mergeIntervals(newInterval,intervals.get(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">re.add(newInterval);</span><br><span class="line">newInterval = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//假设in与in2按start排序，所以只有两情况：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * In  -------</span></span><br><span class="line"><span class="comment"> * In2   ---</span></span><br><span class="line"><span class="comment"> * In2   -------- </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canMerge</span><span class="params">(Interval in, Interval in2)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(in2.start == Integer.MAX_VALUE)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> in.end&gt;=in2.start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Interval <span class="title">mergeIntervals</span><span class="params">(Interval in, Interval in2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Interval(in.start, Math.max(in.end, in2.end));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(1)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/merge-interval&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 56 Merge Intervals&lt;/a&gt;&lt;/strong&gt;&lt;/p
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Sort" scheme="https://shineboy2013.github.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 503 Next Greater Element II</title>
    <link href="https://shineboy2013.github.com/2018/01/28/lee-503/"/>
    <id>https://shineboy2013.github.com/2018/01/28/lee-503/</id>
    <published>2018-01-29T05:24:19.538Z</published>
    <updated>2018-02-01T06:42:01.990Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/next-greater-element-ii" target="_blank" rel="noopener">LeetCode 503 Next Greater Element II</a></strong></p><p>Given a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn’t exist, output -1 for this number.</p><p><strong>Example 1:</strong>  </p><pre><b>Input:</b> [1,2,1]<b>Output:</b> [2,-1,2]<b>Explanation:</b> The first 1's next greater number is 2;   The number 2 can't find next greater number;   The second 1's next greater number needs to search circularly, which is also 2.</pre><p><strong>Note:</strong> The length of given array won’t exceed 10000.</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个循环数组（末尾元素的下一个元素为起始元素），输出每一个元素的下一个更大的数字（Next Greater Number）。Next Greater Number是指位于某元素右侧，大于该元素，且距离最近的元素。如果不存在这样的元素，则输出-1。</p><p>注意：给定数组长度不超过10000。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>最直接的思路是遍历每个元素，对每个元素，遍历它的后面所有元素。最差情况是递减数列，时间复杂度为<code>O(<em>n</em><sup>2</sup>)</code>。<br>这题关于局部递增数组，所以考虑用递减栈。首先不考虑循环数组的情况，例如8,5,4,6,栈存入8,5,4，当6准备进栈时，5,4比6小，它们都出栈且它们的结果集为6。<br>循环数组其实只要将原数组复制一倍，按原算法处理，结果集取前n个元素即可。</p><ol><li>栈不为空，准入栈元素逼出比其小的元素且赋予其结果。</li><li>该元素入栈。、</li><li>栈剩下元素的结果集赋值为-1</li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>栈存储元素下标，结果集存储元素值。</li><li>栈剩下元素的结果集赋值为-1</li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">Stack s = <span class="keyword">new</span> Stack();</span><br><span class="line"><span class="keyword">int</span>[] nums2 = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span>[] re2 = <span class="keyword">new</span> <span class="keyword">int</span>[nums2.length];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums2.length;i++)&#123;</span><br><span class="line">nums2[i] = nums[i%nums.length];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums2.length;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(!s.isEmpty() &amp;&amp; nums2[i]&gt;nums2[(<span class="keyword">int</span>)s.peek()])&#123;</span><br><span class="line"><span class="keyword">int</span> topIdx = (<span class="keyword">int</span>)s.pop();</span><br><span class="line">re2[topIdx] = nums2[i];</span><br><span class="line">&#125;</span><br><span class="line">s.add(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!s.isEmpty())&#123;</span><br><span class="line"><span class="keyword">int</span> topIdx = (<span class="keyword">int</span>)s.pop();</span><br><span class="line">re2[topIdx] = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span>[] re = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">re[i] = re2[i];</span><br><span class="line"><span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>。</p><p>有人考虑用TreeMap，<br> 2<br>1 3<br>但TreeMap不能保留顺序，如这个TreeMap可以对应两种数组,[2,1,3], [2,3,1]并非一一对应。</p><h3 id="Follow-up"><a href="#Follow-up" class="headerlink" title="Follow-up:"></a><strong>Follow-up:</strong></h3><ol><li>Given an integer array, print the Next Greater Number for every element.先从不循环数组考起。<br>3,8,5,4,6,7 =&gt; 8,-1,6,6,7,-1</li><li>先让其写出暴力法brute force，再优化，第0个提示是考虑用一些数据结构，第一个提示为Stack。第二个提示注意比较元素之间大小。</li><li>最后如果是循环数组circular array，如果解决。<br>3,8,5,4,6,7 =&gt; 8,-1,6,6,7,8</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/next-greater-element-ii&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 503 Next Greater Element 
      
    
    </summary>
    
    
      <category term="Interviewer" scheme="https://shineboy2013.github.com/tags/Interviewer/"/>
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
      <category term="Stack" scheme="https://shineboy2013.github.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 658 Find K Closest Elements</title>
    <link href="https://shineboy2013.github.com/2018/01/28/lee-658/"/>
    <id>https://shineboy2013.github.com/2018/01/28/lee-658/</id>
    <published>2018-01-29T03:26:02.137Z</published>
    <updated>2018-01-29T09:58:33.869Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/find-k-closest-elements" target="_blank" rel="noopener">LeetCode 658 Find K Closest Elements</a></strong></p><p>Given a sorted array, two integers <code>k</code> and <code>x</code>, find the <code>k</code> closest elements to <code>x</code> in the array. The result should also be sorted in ascending order. If there is a tie, the smaller elements are always preferred.</p><p><strong>Example 1:</strong>  </p><pre><b>Input:</b> [1,2,3,4,5], k=4, x=3<b>Output:</b> [1,2,3,4]</pre><p><strong>Example 2:</strong>  </p><pre><b>Input:</b> [1,2,3,4,5], k=4, x=-1<b>Output:</b> [1,2,3,4]</pre><p><strong>Note:</strong>  </p><ol><li>The value k is positive and will always be smaller than the length of the sorted array.</li><li>Length of the given array is positive and will not exceed 10<sup>4</sup></li><li>Absolute value of elements in the array and x will not exceed 10<sup>4</sup></li></ol><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个排序数组，两个整数k和x，求数组中距离x最近的k个数字。结果应该有序，距离相同时优先选择较小的数字。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><ol><li>进阶二分法找出第一个大于等于key值的元素。</li><li>左右两指针搜索k个元素。</li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>指针不能越界</li><li>根据题意，与key距离一样时，取较小元素。</li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findClosestElements</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> upperIdx = firstEqualOrGreater(arr, x);</span><br><span class="line"><span class="keyword">int</span> lowerIdx = upperIdx-<span class="number">1</span>;</span><br><span class="line">List result = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(lowerIdx&lt;<span class="number">0</span>)</span><br><span class="line">result.add(arr[upperIdx++]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(upperIdx&gt;=arr.length)</span><br><span class="line">result.add(arr[lowerIdx--]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x-arr[lowerIdx]&lt;=arr[upperIdx]-x)</span><br><span class="line">result.add(arr[lowerIdx--]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">result.add(arr[upperIdx++]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Collections.sort(result);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstEqualOrGreater</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> lo = <span class="number">0</span>, hi = a.length-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(lo&lt;=hi)&#123;</span><br><span class="line"><span class="keyword">int</span> mid =  lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(a[mid]&lt;key)</span><br><span class="line">lo = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">hi = mid-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn+k)</code>，空间复杂度<code>O(1)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/find-k-closest-elements&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 658 Find K Closest Elemen
      
    
    </summary>
    
    
      <category term="Binary Search" scheme="https://shineboy2013.github.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 698 Partition to K Equal Sum Subsets</title>
    <link href="https://shineboy2013.github.com/2018/01/28/lee-698/"/>
    <id>https://shineboy2013.github.com/2018/01/28/lee-698/</id>
    <published>2018-01-28T19:18:14.135Z</published>
    <updated>2018-01-29T09:54:03.195Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/partition-to-k-equal-sum-subsets" target="_blank" rel="noopener">LeetCode 698 Partition to K Equal Sum Subsets</a></strong></p><p>Given an array of integers <code>nums</code> and a positive integer <code>k</code>, find whether it’s possible to divide this array into <code>k</code> non-empty subsets whose sums are all equal.</p><p><strong>Example 1:</strong>  </p><pre><b>Input:</b> nums = [4, 3, 2, 3, 5, 2, 1], k = 4<b>Output:</b> True<b>Explanation:</b> It's possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.</pre><p><strong>Note:</strong></p><ul><li><code>1 &lt;= k &lt;= len(nums) &lt;= 16</code>.</li><li><code>0 &lt; nums[i] &lt; 10000</code>.</li></ul><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>判断数组nums是否可以划分为k个和相等的子数组</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这题与416类似，所以一开始考虑用0-1背包问题思路，但是0-1背包问题得出的解为2,2,1，与答案不同。因为背包问题只能求出第一个解，并不能求出k个解。所以类似于排列组合，<br>需要DFS来一个个数来试。参数为visited数组为记录该数是否用了，curSum，k，若curSum等于target(sum/k)，找到第一个解，k–，curSum=0，找下一个解。这个方法是用k次排列组合法组成最终解。</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>数组和为不能被k整除，无解</li><li>引入st，排列组合必须，用于for循环的起始点。</li><li>k=1立刻剪枝，因为前三个解都是等于sum/k,最后一个也一定是sum/k</li><li>当curSum==target时，进行k-1，curSum=0的下一轮dfs。</li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartitionKSubsets0</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i : nums)</span><br><span class="line">sum+=i;</span><br><span class="line"><span class="keyword">if</span>(sum%k!=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line"><span class="keyword">return</span> dfs0(nums, k, sum/k, <span class="number">0</span>, visited, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs0</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> target, <span class="keyword">int</span> curSum, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span>(curSum==target)</span><br><span class="line"><span class="keyword">return</span> dfs0(nums, k-<span class="number">1</span>, target, <span class="number">0</span>, visited, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;nums.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(visited[i])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(curSum+nums[i]&lt;=target)&#123;</span><br><span class="line">visited[i] = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span>(dfs0(nums, k, target, curSum+nums[i], visited, i+<span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">visited[i] = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>这是NP问题。  </p><hr><p>另一个方法是，将k次排列组合法整合成一次，途径是开一个k大小数组，每一个数肯定属于其中一个。visited数组替换成ksum数组和idx控制遍历数组顺序。某一个数肯定是属于ksum数组的任一个，<br>所以所有可能性都考虑到，可以求得解。先对原数组排序，贪心算法可以帮助剪枝，提高算法效率但若不排序的话会得到LTE。</p><ol><li>数组和为不能被k整除，无解</li><li>对数组排序</li><li>DFS四部曲，从后往前遍历数组加入ksum</li></ol><h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>数组和为不能被k整除，无解</li><li>从后往前遍历数组</li></ol><h3 id="Java代码：-1"><a href="#Java代码：-1" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i : nums)</span><br><span class="line">sum+=i;</span><br><span class="line"><span class="keyword">if</span>(sum%k!=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">Arrays.sort(nums);</span><br><span class="line"><span class="keyword">int</span>[] ksum = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line"><span class="keyword">return</span> dfs(nums, k, sum/k, ksum, nums.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> target, <span class="keyword">int</span>[] ksum, <span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(idx==-<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> a : ksum)</span><br><span class="line"><span class="keyword">if</span>(a!=target)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(ksum[i]+nums[idx]&lt;=target)&#123;</span><br><span class="line">ksum[i] += nums[idx];</span><br><span class="line"><span class="keyword">if</span>(dfs(nums, k, target, ksum, idx-<span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">ksum[i] -= nums[idx];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>这是NP问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/partition-to-k-equal-sum-subsets&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 698 Partition to
      
    
    </summary>
    
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
      <category term="Recursion" scheme="https://shineboy2013.github.com/tags/Recursion/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 416 Partition Equal Subset Sum</title>
    <link href="https://shineboy2013.github.com/2018/01/27/lee-416/"/>
    <id>https://shineboy2013.github.com/2018/01/27/lee-416/</id>
    <published>2018-01-28T04:36:12.780Z</published>
    <updated>2018-01-28T05:07:57.798Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/partition-equal-subset-sum" target="_blank" rel="noopener">LeetCode 416 Partition Equal Subset Sum</a></strong></p><p>Given a <strong>non-empty</strong> array containing <strong>only positive integers</strong>, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p><p><strong>Note:</strong>  </p><ol><li>Each of the array element will not exceed 100.</li><li>The array size will not exceed 200.</li></ol><p><strong>Example 1:</strong></p><pre>Input: [1, 5, 11, 5]Output: trueExplanation: The array can be partitioned as [1, 5, 5] and [11].</pre><p><strong>Example 2:</strong></p><pre>Input: [1, 2, 3, 5]Output: falseExplanation: The array cannot be partitioned into equal sum subsets.</pre><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个只包含正整数的非空数组，判断数组是否可以分成两个和相等的子数组。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这题转化为求是否有子序列的和等于数组和的一半，这就是0-1背包问题。价值和重量是一样数组的背包问题。背包问题递归式：<br>f[j] = Math.max(f[j], f[j-w[i]]+v[i]);<br>背包问题最后的解为容量为C的背包能装的最大价值，也就是在这题中，容量为数组一半和的背包能装的最大价值是否为数组一半。如果能，即有解。</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>数组和为奇数，无解</li><li>背包问题的解若为数组一半的和即有解</li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">sum+=nums[i];</span><br><span class="line"><span class="keyword">if</span>(sum%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span>[] result = knapsack(nums,nums,sum/<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(sum/<span class="number">2</span>==result[result.length-<span class="number">1</span>])</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] knapsack(<span class="keyword">int</span> v[], <span class="keyword">int</span> w[], <span class="keyword">int</span> C)&#123;</span><br><span class="line"><span class="keyword">int</span> n = v.length;</span><br><span class="line"><span class="comment">//int[][] re = new int[n][C+1];</span></span><br><span class="line"><span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[C+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=C;j&gt;=w[i];j--)&#123;</span><br><span class="line">f[j] = Math.max(f[j], f[j-w[i]]+v[i]);</span><br><span class="line"><span class="comment">//if(f[j]==f[j-w[i]]+v[i])</span></span><br><span class="line">   <span class="comment">// re[i][j] = 1;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nC)</code>，空间复杂度<code>O(C)</code>。C为数组和的一半，n为数组个数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/partition-equal-subset-sum&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 416 Partition Equal Su
      
    
    </summary>
    
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 329 Longest Increasing Path in a Matrix</title>
    <link href="https://shineboy2013.github.com/2018/01/10/lee-329/"/>
    <id>https://shineboy2013.github.com/2018/01/10/lee-329/</id>
    <published>2018-01-10T09:46:52.076Z</published>
    <updated>2018-01-26T07:07:27.772Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/longest-increasing-path-in-a-matrix" target="_blank" rel="noopener">LeetCode 329 Longest Increasing Path in a Matrix</a></strong></p><p>Given an integer matrix, find the length of the longest increasing path.</p><p>From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).</p><p><strong>Example 1:</strong></p><pre>nums = [  [<font color="red">9</font>,9,4],  [<font color="red">6</font>,6,8],  [<font color="red">2</font>,<font color="red">1</font>,1]]</pre><p>Return <code>4</code><br>The longest increasing path is <code>[1, 2, 6, 9]</code>.</p><p><strong>Example 2:</strong></p><pre>nums = [  [<font color="red">3</font>,<font color="red">4</font>,<font color="red">5</font>],  [3,2,<font color="red">6</font>],  [2,2,1]]</pre><p>Return <code>4</code><br>The longest increasing path is <code>[3, 4, 5, 6]</code>. Moving diagonally is not allowed.</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个整数矩阵，计算其最长递增路径的长度。<br>从每一个单元格出发，你可以向四个方向移动：左右上下。你不可以沿着对角线移动也不能移出边界。（亦即，环绕是不允许的）。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这是经典题，类似于LIS题，只要将以每个点为终点的最长路径长度存起来，就可以类推它的邻近点的最长长度（DP）。f(x,y)=max{f(x,y),4个邻近点的f+1}<br>由于这是求最长路径题且为矩阵，可以考虑按步长计算，就是Floyd的思路，就是先计算步长为1,2一直到所以最长路径长度矩阵长度不再更新为止。<br>另一个思路也是用矩阵存起每个点最长路径长度，但用DFS搜索，直至这个点的值不为初始值为止，详见书影博客。</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>矩阵为空或长度为0</li><li>当任何值没有更新时，Floyd停止计算</li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (matrix==<span class="keyword">null</span> || matrix.length==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>[][] path = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix.length;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;matrix[<span class="number">0</span>].length;j++)</span><br><span class="line">path[i][j] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> nextPath = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">while</span>(nextPath)&#123;</span><br><span class="line">nextPath = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix.length;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;matrix[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(changeCell(matrix, path, i, j))</span><br><span class="line">nextPath = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix.length;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;matrix[<span class="number">0</span>].length;j++)</span><br><span class="line"><span class="keyword">if</span>(path[i][j]&gt;max)</span><br><span class="line">max = path[i][j];</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">changeCell</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span>[][] path, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pre = path[i][j];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; matrix[i-<span class="number">1</span>][j]&lt;matrix[i][j] &amp;&amp;  path[i-<span class="number">1</span>][j]+<span class="number">1</span>&gt;path[i][j])</span><br><span class="line">path[i][j] = path[i-<span class="number">1</span>][j]+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i+<span class="number">1</span>&lt;matrix.length &amp;&amp; matrix[i+<span class="number">1</span>][j]&lt;matrix[i][j] &amp;&amp;  path[i+<span class="number">1</span>][j]+<span class="number">1</span>&gt;path[i][j])</span><br><span class="line">path[i][j] = path[i+<span class="number">1</span>][j]+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(j-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; matrix[i][j-<span class="number">1</span>]&lt;matrix[i][j] &amp;&amp;  path[i][j-<span class="number">1</span>]+<span class="number">1</span>&gt;path[i][j])</span><br><span class="line">path[i][j] = path[i][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(j+<span class="number">1</span>&lt;matrix[<span class="number">0</span>].length &amp;&amp; matrix[i][j+<span class="number">1</span>]&lt;matrix[i][j] &amp;&amp;  path[i][j+<span class="number">1</span>]+<span class="number">1</span>&gt;path[i][j])</span><br><span class="line">path[i][j] = path[i][j+<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pre!=path[i][j])</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>k为最长路径长度，时间复杂度为<code>O(k<em>n</em><sup>2</sup>)</code>，空间复杂度<code>O(<em>n</em><sup>2</sup>)</code>。   </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-increasing-path-in-a-matrix&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 329 Longest I
      
    
    </summary>
    
    
      <category term="Depth-first Search" scheme="https://shineboy2013.github.com/tags/Depth-first-Search/"/>
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
      <category term="Topological Sort" scheme="https://shineboy2013.github.com/tags/Topological-Sort/"/>
    
      <category term="Memoization" scheme="https://shineboy2013.github.com/tags/Memoization/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 332 Reconstruct Itinerary</title>
    <link href="https://shineboy2013.github.com/2018/01/09/lee-332/"/>
    <id>https://shineboy2013.github.com/2018/01/09/lee-332/</id>
    <published>2018-01-10T06:17:56.450Z</published>
    <updated>2018-01-10T07:33:18.967Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/reconstruct-itinerary" target="_blank" rel="noopener">LeetCode 332 Reconstruct Itinerary</a></strong></p><p>Given a list of airline tickets represented by pairs of departure and arrival airports <code>[from, to]</code>, reconstruct the itinerary in order. All of the tickets belong to a man who departs from <code>JFK</code>. Thus, the itinerary must begin with <code>JFK</code>.</p><p><strong>Note:</strong>  </p><ol><li>If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary <code>[&quot;JFK&quot;, &quot;LGA&quot;]</code> has a smaller lexical order than <code>[&quot;JFK&quot;, &quot;LGB&quot;]</code>.</li><li>All airports are represented by three capital letters (IATA code).</li><li>You may assume all tickets form at least one valid itinerary.</li></ol><p><strong>Example 1:</strong><br><code>tickets</code> = <code>[[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]]</code><br>Return <code>[&quot;JFK&quot;, &quot;MUC&quot;, &quot;LHR&quot;, &quot;SFO&quot;, &quot;SJC&quot;]</code>.  </p><p><strong>Example 2:</strong><br><code>tickets</code> = <code>[[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]</code><br>Return <code>[&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]</code>.<br>Another possible reconstruction is <code>[&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;]</code>. But it is larger in lexical order.</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一组机票，用出发机场和到达机场[from, to]来表示，重建行程的顺序。所有的机票都属于一个从JFK（肯尼迪国际机场）出发的旅客。因此，行程必须从JFK开始。</p><p>注意：</p><p>如果存在多重有效的行程，你应当返回字典序最小的那个。例如，行程[“JFK”, “LGA”]的字典序比[“JFK”, “LGB”]要小。<br>所有的机场用3个大写字母表示（IATA编码）。<br>你可以假设所有的机票均至少包含一条有效的行程。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这条题实质是记录DFS路径的题目，且对儿子节点的选择是有顺序的。值得注意的是并不是所有路径都是可形成回路，所以需要DFS搜索。<br>既然是要记录路径就需要用数组保存结果，而有顺序则表示要排序。</p><ol><li>建图，用邻接表来表示HashMap<string, linkedlist<string="">&gt; graph</string,></li><li>对每个节点的邻节点LinkList进行排序</li><li>从JFK开始dfs。1)终止条件为所有ticket都遍历了(达成回路)或者不能够遍历完。2)路径存在数组中。 3)通过删除节点表示已访问DFS该节点后图要恢复成原状态。</li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>终止条件为所有ticket都遍历了(达成完整路)或者不能够遍历完。如{“JFK”,”KUL”},{“JFK”,”NRT”},{“NRT”,”JFK”}，虽然KUL在NRT前，但KUL不能组成回路。</li><li>DFS路径尽量存在数组中，否则用ArrayList中就要先add再remove。</li><li>通过删除节点表示已访问DFS该节点后图要恢复成原状态。</li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findItinerary</span><span class="params">(String[][] tickets)</span> </span>&#123;</span><br><span class="line">HashMap&lt;String, LinkedList&lt;String&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;String, LinkedList&lt;String&gt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tickets.length;i++)&#123;</span><br><span class="line">LinkedList&lt;String&gt; neighbor = graph.get(tickets[i][<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span>(neighbor==<span class="keyword">null</span>)</span><br><span class="line">neighbor = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">neighbor.add(tickets[i][<span class="number">1</span>]);</span><br><span class="line">graph.put(tickets[i][<span class="number">0</span>], neighbor);</span><br><span class="line">&#125;</span><br><span class="line">Iterator&lt;String&gt; it = graph.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">String key = it.next();</span><br><span class="line">LinkedList&lt;String&gt; neighbor = graph.get(key);</span><br><span class="line">Collections.sort(neighbor);</span><br><span class="line">graph.put(key, neighbor);</span><br><span class="line">&#125;</span><br><span class="line">String[] re = <span class="keyword">new</span> String[tickets.length+<span class="number">1</span>];</span><br><span class="line">String cur = <span class="string">"JFK"</span>;</span><br><span class="line">re[<span class="number">0</span>] = cur;</span><br><span class="line">isDFS(graph,cur,tickets.length,tickets.length,re);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(re));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDFS</span><span class="params">(HashMap&lt;String, LinkedList&lt;String&gt;&gt; graph, String departCity</span></span></span><br><span class="line"><span class="function"><span class="params">,<span class="keyword">int</span> ticketLeft, <span class="keyword">int</span> ticketNum, String[] re)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ticketLeft==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;    </span><br><span class="line">LinkedList&lt;String&gt; desCity = graph.get(departCity);</span><br><span class="line"><span class="keyword">if</span>(desCity==<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;desCity.size();i++)&#123;</span><br><span class="line">String cur = desCity.get(i);</span><br><span class="line">re[ticketNum-ticketLeft+<span class="number">1</span>] = cur;</span><br><span class="line">desCity.remove(i);</span><br><span class="line">graph.put(departCity, desCity);</span><br><span class="line"><span class="keyword">if</span>(isDFS(graph,cur,ticketLeft-<span class="number">1</span>,ticketNum,re))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;;</span><br><span class="line">desCity.add(i,cur);</span><br><span class="line">graph.put(departCity, desCity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>。    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/reconstruct-itinerary&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 332 Reconstruct Itinerary&lt;/
      
    
    </summary>
    
    
      <category term="Depth-first Search" scheme="https://shineboy2013.github.com/tags/Depth-first-Search/"/>
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
      <category term="Graph" scheme="https://shineboy2013.github.com/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 347 Top K Frequent Elements</title>
    <link href="https://shineboy2013.github.com/2017/12/31/lee-347/"/>
    <id>https://shineboy2013.github.com/2017/12/31/lee-347/</id>
    <published>2018-01-01T00:16:23.505Z</published>
    <updated>2018-01-31T06:16:55.009Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/top-k-frequent-elements" target="_blank" rel="noopener">LeetCode 347 Top K Frequent Elements</a></strong></p><p>Given a non-empty array of integers, return the <strong><em>k</em></strong> most frequent elements.</p><p>For example,<br>Given <code>[1,1,1,2,2,3]</code> and k = 2, return <code>[1,2]</code>.</p><p><strong>Note:</strong>  </p><ul><li>You may assume <em>k</em> is always valid, 1 ≤ <em>k</em> ≤ number of unique elements.</li><li>Your algorithm’s time complexity <strong>must be</strong> better than O(<em>n</em> log <em>n</em>), where <em>n</em> is the array’s size.</li></ul><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个非空整数数组，返回其前k个出现次数最多的元素。</p><p>注意：<br>你可以假设k总是有效的，1 ≤ k ≤ 独立元素的个数。<br>你的算法时间复杂度必须优于O(n log n)，其中n是数组的长度。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这是经典题，解法是HeapSelect：求最大k个数，就先对前k个元素建最小堆，然后遍历k到最后一个数，若它大于栈顶就替换且做minHeapify。最后结果是<br>最大的k个数在数组的前k个位置且堆顶（数组第一个数）为k个数的最小。堆并没有排序。<br>结果并不需要从大到小输出。</p><ol><li>统计词频</li><li>建key-value数组</li><li>heapSelect</li><li>把数组前k个数加入到结果集中</li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>如果需要按大到小输出结果，需要对result进行排序O(klogk)，数组第一个也就是最小堆堆顶是这k个数中最小。</li><li>key-pair版堆选择算法。</li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(map.containsKey(nums[i]))</span><br><span class="line">map.put(nums[i], map.get(nums[i])+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">map.put(nums[i], <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">Node[] f = <span class="keyword">new</span> Node[map.size()];</span><br><span class="line">Iterator it = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">Map.Entry pair = (Map.Entry)it.next();</span><br><span class="line">Node node = <span class="keyword">new</span> Node((<span class="keyword">int</span>)pair.getKey(), (<span class="keyword">int</span>)pair.getValue());</span><br><span class="line">f[j++] = node;</span><br><span class="line">&#125;</span><br><span class="line">hselect(f, k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">result.add(f[i].key);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hselect</span><span class="params">(Node a[], <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="comment">// min heap with size=k</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = k / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">minHeapify(a, i, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; a.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i].value &gt; a[<span class="number">0</span>].value) &#123;</span><br><span class="line">swap(a, i, <span class="number">0</span>);</span><br><span class="line">minHeapify(a, <span class="number">0</span>, k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">minHeapify</span><span class="params">(Node[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> smallest = i;</span><br><span class="line"><span class="keyword">int</span> l = left(i);</span><br><span class="line"><span class="keyword">int</span> r = l + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (l &lt; n &amp;&amp; arr[l].key &lt; arr[smallest].key)</span><br><span class="line">smallest = l;</span><br><span class="line"><span class="keyword">if</span> (r &lt; n &amp;&amp; arr[r].key &lt; arr[smallest].key)</span><br><span class="line">smallest = r;</span><br><span class="line"><span class="keyword">if</span> (smallest != i) &#123;</span><br><span class="line">swap(arr, i, smallest);</span><br><span class="line">minHeapify(arr, smallest, n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Node[] arr, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">Node tmp = arr[index1];</span><br><span class="line">arr[index1] = arr[index2];</span><br><span class="line">arr[index2] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> key;</span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">key = k;</span><br><span class="line">value = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"("</span>+key+<span class="string">","</span>+value+<span class="string">")"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogk)</code>，空间复杂度<code>O(1)</code>。时间复杂度是O(n)+O(nlogk),空间复杂度为O(m)+O(1),m为不重复的元素个数(unique element)。</p><hr><h3 id="算法II解题思路："><a href="#算法II解题思路：" class="headerlink" title="算法II解题思路："></a><strong>算法II解题思路：</strong></h3><p>此题关于数组频数，所以考虑用桶排序(bucket sort)</p><ol><li>统计词频（元素-&gt;频数）</li><li>桶排序：n+1个桶（n为原数组大小），把元素放入频数对应的桶号（频数-&gt;元素），用List把这些元素串起来。</li><li>逆序（从大到小）遍历不为空的桶，输入结果直至k个。<br>与上面算法不同的是结果是从大到小输出。数据类型有两个HashMap存储元素对应的频数，而List数组List<integer>[]反过来存储频数对应的元素。</integer></li></ol><h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>桶排序要用List串联起元素，例如[1,2],k=2，频数为1的元素有两个，所以桶的内容应该是List。</li><li>桶数量为原数组大小+1，例如一个元素[1], 它的频数为1，而频数为0是不会出现。</li><li>逆序遍历所有桶，只要结果集个数为k，就停止循环。</li></ol><h3 id="Java代码：-1"><a href="#Java代码：-1" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent2</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"> List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"> HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(map.containsKey(nums[i]))</span><br><span class="line">map.put(nums[i], map.get(nums[i])+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">map.put(nums[i], <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> List&lt;Integer&gt;[] f = <span class="keyword">new</span> List[nums.length+<span class="number">1</span>];</span><br><span class="line"> Iterator it = map.entrySet().iterator();</span><br><span class="line"> <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line"> Map.Entry pair = (Map.Entry)it.next();</span><br><span class="line"> <span class="keyword">if</span>(f[(<span class="keyword">int</span>)pair.getValue()]==<span class="keyword">null</span>)</span><br><span class="line"> f[(<span class="keyword">int</span>)pair.getValue()] = <span class="keyword">new</span> ArrayList();</span><br><span class="line"> f[(<span class="keyword">int</span>)pair.getValue()].add((<span class="keyword">int</span>)pair.getKey());</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=f.length-<span class="number">1</span>;i&gt;<span class="number">0</span> &amp;&amp; result.size()&lt;k;i--)</span><br><span class="line"> <span class="keyword">if</span>(f[i]!=<span class="keyword">null</span>)&#123;</span><br><span class="line"> result.addAll(f[i]);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>。时间复杂度是O(n)+O(n),空间复杂度为O(m)+O(n),m为不重复的元素个数(unique element)。</p><h3 id="Follow-up"><a href="#Follow-up" class="headerlink" title="Follow-up:"></a><strong>Follow-up:</strong></h3><ol><li>题目可以包装成：给定一个文档，返回其前k个出现次数最多的单词。<br>Given a document, return the k most frequent words. Assume punctuation are removed.<br>Given a non-empty array of strings, return the k most frequent elements.  </li><li>如果写出了桶排序，可以考虑假设机器memory有限，只够O(m)，不能一次性读出整个文档，也就是不能用桶排序，只能用堆选择。</li><li>如果写出了堆选择，可以考虑k比较大，如果进一步提高时间复杂度，也就是只能O(n),符合这个要求就只有计数排序，基数排序和桶排序。</li></ol><p>这是priorityQueue实现的Heap，由于PQ需要额外空间，所以较少用。</p><h3 id="Java代码：-2"><a href="#Java代码：-2" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent3</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"> List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"> HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(map.containsKey(nums[i]))</span><br><span class="line">map.put(nums[i], map.get(nums[i])+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">map.put(nums[i], <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> Node[] f = <span class="keyword">new</span> Node[map.size()];</span><br><span class="line"> Iterator it = map.entrySet().iterator();</span><br><span class="line"> <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">Map.Entry pair = (Map.Entry)it.next();</span><br><span class="line">Node node = <span class="keyword">new</span> Node((<span class="keyword">int</span>)pair.getKey(), (<span class="keyword">int</span>)pair.getValue());</span><br><span class="line">f[j++] = node;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> PriorityQueue&lt;Node&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;Node&gt;(k,</span><br><span class="line"><span class="keyword">new</span> Comparator&lt;Node&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> o1.value - o2.value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; f.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; k) &#123;</span><br><span class="line">minHeap.offer(f[i]);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">Node minNode = minHeap.peek();</span><br><span class="line"><span class="keyword">if</span> (f[i].value &gt; minNode.value) &#123;</span><br><span class="line">minHeap.poll();</span><br><span class="line">minHeap.offer(f[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!minHeap.isEmpty())</span><br><span class="line">result.add(minHeap.poll().key);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/top-k-frequent-elements&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 347 Top K Frequent Elemen
      
    
    </summary>
    
    
      <category term="Interviewer" scheme="https://shineboy2013.github.com/tags/Interviewer/"/>
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
      <category term="Heap" scheme="https://shineboy2013.github.com/tags/Heap/"/>
    
      <category term="Hash Table" scheme="https://shineboy2013.github.com/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 350 Intersection of Two Arrays II</title>
    <link href="https://shineboy2013.github.com/2017/12/31/lee-350/"/>
    <id>https://shineboy2013.github.com/2017/12/31/lee-350/</id>
    <published>2017-12-31T21:41:43.968Z</published>
    <updated>2018-01-03T05:37:14.627Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/intersection-of-two-arrays-ii" target="_blank" rel="noopener">LeetCode 350 Intersection of Two Arrays II</a></strong></p><p>Given two arrays, write a function to compute their intersection.</p><p><strong>Example:</strong><br>Given <em>nums1</em> = <code>[1, 2, 2, 1]</code>, <em>nums2</em> = <code>[2, 2]</code>, return <code>[2, 2]</code>.</p><p><strong>Note:</strong>  </p><ul><li>Each element in the result should appear as many times as it shows in both arrays.</li><li>The result can be in any order.</li></ul><p><strong>Follow up:</strong>  </p><ul><li>What if the given array is already sorted? How would you optimize your algorithm?</li><li>What if <em>nums1</em>‘s size is small compared to <em>nums2</em>‘s size? Which algorithm is better?</li><li>What if elements of <em>nums2</em> are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</li></ul><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定两个数组，编写函数计算它们的交集。  </p><p>注意：<br>结果中的每个元素的出现次数应与其在两个数组中同时出现的次数一样多。 结果可以采用任意顺序。  </p><p>进一步思考：<br>如果数组已经排好序，怎样优化你的算法？<br>如果nums1的长度＜nums2的长度？哪一种算法更好？<br>如果nums2的元素存储在磁盘上，并且内存大小有限，不足以将其一次性的加载到内存中。此时应当怎样做？  </p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于L349，但由于可允许重复，所以改hashSet成hashMap记录频数。具体而言，将较小的数组的所有元素放入hashMap且统计频数，<br>然后遍历另一个数组判断是否相同，相同的话放入ArrayList的结果集中且频数减一。</p><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line"><span class="comment">//swap and make sure length of nums1 is smaller</span></span><br><span class="line"><span class="keyword">if</span>(nums1.length&gt;nums2.length)&#123;</span><br><span class="line"><span class="keyword">int</span>[] tmp = nums1;</span><br><span class="line">nums1 = nums2;</span><br><span class="line">nums2 = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Map&lt;Integer, Integer&gt; map=<span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">List&lt;Integer&gt; result=<span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums1.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(map.containsKey(nums1[i]))</span><br><span class="line">map.put(nums1[i], map.get(nums1[i])+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">map.put(nums1[i],<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums2.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(map.containsKey(nums2[i]) &amp;&amp; map.get(nums2[i])&gt;<span class="number">0</span>)&#123;</span><br><span class="line">result.add(nums2[i]);</span><br><span class="line">map.put(nums2[i], map.get(nums2[i])-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result.stream().mapToInt(i-&gt;i).toArray();      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>m和n为数组长度m&gt;n，时间复杂度为<code>O(m)</code>，空间复杂度<code>O(n)</code>。    </p><hr><h3 id="算法II解题思路："><a href="#算法II解题思路：" class="headerlink" title="算法II解题思路："></a><strong>算法II解题思路：</strong></h3><p>另一个解题思路是，先对它们排序，然后类似于mergeSort算法维持两个指针分别在两个数组搜索相同元素。</p><h3 id="Java代码：-1"><a href="#Java代码：-1" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">List&lt;Integer&gt; result=<span class="keyword">new</span> ArrayList();</span><br><span class="line">Arrays.sort(nums1);</span><br><span class="line">Arrays.sort(nums2);</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;nums1.length &amp;&amp; j&lt;nums2.length)&#123;</span><br><span class="line"><span class="keyword">if</span>(nums1[i]==nums2[j])&#123;</span><br><span class="line">result.add(nums1[i]);</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(nums1[i]&lt;nums2[j])</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">else</span> j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result.stream().mapToInt(k-&gt;k).toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>m和n为数组长度m&gt;n，时间复杂度为<code>O(mlogm)</code>，空间复杂度<code>O(1)</code>。此算法空间较优，但时间稍逊。</p><ol><li>如果数组已经排好序，怎样优化你的算法？<br>用第二个算法，时间复杂度为O(m),但空间复杂度可以优化为O(1)  </li><li>如果nums1的长度＜nums2的长度？哪一种算法更好？<br>方法一更优，因为nums1空间用的比较少情况下</li><li>如果nums2的元素存储在磁盘上，并且内存大小有限，不足以将其一次性的加载到内存中。此时应当怎样做？<br>也应该用方法一，因为它不需要把nums2数组一次性加载到内存中。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/intersection-of-two-arrays-ii&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 350 Intersection of
      
    
    </summary>
    
    
      <category term="Binary Search" scheme="https://shineboy2013.github.com/tags/Binary-Search/"/>
    
      <category term="Sort" scheme="https://shineboy2013.github.com/tags/Sort/"/>
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
      <category term="Hash Table" scheme="https://shineboy2013.github.com/tags/Hash-Table/"/>
    
      <category term="Two Pointers" scheme="https://shineboy2013.github.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 349 Intersection of Two Arrays</title>
    <link href="https://shineboy2013.github.com/2017/12/31/lee-349/"/>
    <id>https://shineboy2013.github.com/2017/12/31/lee-349/</id>
    <published>2017-12-31T20:40:30.982Z</published>
    <updated>2018-01-03T05:38:10.240Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/intersection-of-two-arrays" target="_blank" rel="noopener">LeetCode 349 Intersection of Two Arrays</a></strong></p><p>Given two arrays, write a function to compute their intersection.</p><p><strong>Example:</strong><br>Given <em>nums1</em> = <code>[1, 2, 2, 1]</code>, <em>nums2</em> = <code>[2, 2]</code>, return <code>[2]</code>.</p><p><strong>Note:</strong>  </p><ul><li>Each element in the result must be unique.</li><li>The result can be in any order.</li></ul><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定两个数组，编写函数计算它们的交集。  </p><p>注意：<br>结果中的每个元素一定是唯一的。<br>结果可以采用任意顺序。  </p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>将较小的数组的所有元素放入hashSet，然后遍历另一个数组判断是否相同，相同的话放入hashSet的结果集中。所以需要两个hashSet。</p><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line"><span class="comment">//swap and make sure length of nums1 is smaller</span></span><br><span class="line"><span class="keyword">if</span>(nums1.length&gt;nums2.length)&#123;</span><br><span class="line"><span class="keyword">int</span>[] tmp = nums1;</span><br><span class="line">nums1 = nums2;</span><br><span class="line">nums2 = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Set&lt;Integer&gt; hash=<span class="keyword">new</span> HashSet();</span><br><span class="line">Set&lt;Integer&gt; result=<span class="keyword">new</span> HashSet();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums1.length;i++)</span><br><span class="line">hash.add(nums1[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums2.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(hash.contains(nums2[i]))</span><br><span class="line">result.add(nums2[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span>[] r=<span class="keyword">new</span> <span class="keyword">int</span>[result.size()];</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i : result)</span><br><span class="line">r[k++]=i;</span><br><span class="line"><span class="keyword">return</span> r;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>m和n为数组长度m&gt;n，时间复杂度为<code>O(m)</code>，空间复杂度<code>O(n)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/intersection-of-two-arrays&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 349 Intersection of Tw
      
    
    </summary>
    
    
      <category term="Binary Search" scheme="https://shineboy2013.github.com/tags/Binary-Search/"/>
    
      <category term="Sort" scheme="https://shineboy2013.github.com/tags/Sort/"/>
    
      <category term="Hash Table" scheme="https://shineboy2013.github.com/tags/Hash-Table/"/>
    
      <category term="Two Pointers" scheme="https://shineboy2013.github.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 316 Remove Duplicate Letters</title>
    <link href="https://shineboy2013.github.com/2017/12/31/lee-316/"/>
    <id>https://shineboy2013.github.com/2017/12/31/lee-316/</id>
    <published>2017-12-31T19:07:51.935Z</published>
    <updated>2018-01-03T05:38:30.464Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/remove-duplicate-letters" target="_blank" rel="noopener">LeetCode 316 Remove Duplicate Letters</a></strong></p><p>Given a string which contains only lowercase letters, remove duplicate letters so that every letter appear once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.</p><p><strong>Example:</strong>  </p><p>Given <code>&quot;bcabc&quot;</code><br>Return <code>&quot;abc&quot;</code></p><p>Given <code>&quot;cbacdcbc&quot;</code><br>Return <code>&quot;acdb&quot;</code></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个只包含小写字母的字符串，从中移除重复字母使得每个字母只出现一次。你必须确保结果的字典序最小。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这题是保持原顺序输出结果，所以考虑用递减栈。先看例子bcabc-&gt;abc，a入栈倒逼bc出栈，可解此题。再看cbacdcbc，acd时候b入栈，不能倒逼cd出栈<br>因为d是唯一一个，所以还要维护一个hashMap来记录每个字母的词频。所以入栈条件为准入栈元素小于栈顶元素且栈顶元素为最后一个（频数&gt;0）。<br>hashMap作用有两个，第一个为统计词频，第二个为记录未处理（未入for循环）的字母的频数。<br>resultSet记录stack中所有唯一元素，用于判断是否需要入栈。</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>已在栈内的<strong>重复元素</strong>不入栈，也不倒逼任何元素出栈，也就是直接忽略它，只要将其频数减一即可，表示已处理。比如abacb，第二个a不能倒逼b。  </li><li>进入循环后频数立刻减一，不要出列时候才做，参见BFS。  </li><li>入栈条件：栈不为空，准入栈元素小于栈顶元素，栈顶元素频数&gt;0。  </li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicateLetters</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line">Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">Set&lt;Character&gt; result = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">Character c = s.charAt(i);</span><br><span class="line"><span class="keyword">if</span>(map.containsKey(c))</span><br><span class="line">map.put(c, map.get(c)+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">map.put(c, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">Character c = s.charAt(i);</span><br><span class="line">map.put(c, map.get(c)-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Stack已经有c就不加入</span></span><br><span class="line"><span class="keyword">if</span>(result.contains(c))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; c&lt;stack.peek() &amp;&amp; map.get(stack.peek())&gt;<span class="number">0</span>)&#123;</span><br><span class="line">result.remove(stack.peek());</span><br><span class="line">stack.pop();</span><br><span class="line">&#125;</span><br><span class="line">stack.push(c);</span><br><span class="line">result.add(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">while</span>(!stack.isEmpty())</span><br><span class="line">sb.append(stack.pop());</span><br><span class="line"><span class="keyword">return</span> sb.reverse().toString();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>所有元素入栈出栈最多一次，所以时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/remove-duplicate-letters&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 316 Remove Duplicate Let
      
    
    </summary>
    
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
      <category term="Greedy" scheme="https://shineboy2013.github.com/tags/Greedy/"/>
    
      <category term="Stack" scheme="https://shineboy2013.github.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 312 Burst Balloons</title>
    <link href="https://shineboy2013.github.com/2017/12/28/lee-312/"/>
    <id>https://shineboy2013.github.com/2017/12/28/lee-312/</id>
    <published>2017-12-28T17:58:22.880Z</published>
    <updated>2018-01-03T05:43:09.228Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/burst-balloons" target="_blank" rel="noopener">LeetCode 312 Burst Balloons</a></strong></p><p>Given <code>n</code> balloons, indexed from <code>0</code> to <code>n-1</code>. Each balloon is painted with a number on it represented by array <code>nums</code>. You are asked to burst all the balloons. If the you burst balloon <code>i</code> you will get <code>nums[left] * nums[i] * nums[right]</code> coins. Here <code>left</code> and <code>right</code> are adjacent indices of <code>i</code>. After the burst, the <code>left</code> and <code>right</code> then becomes adjacent.</p><p>Find the maximum coins you can collect by bursting the balloons wisely.</p><p><strong>Note:</strong><br>(1) You may imagine <code>nums[-1] = nums[n] = 1</code>. They are not real therefore you can not burst them.<br>(2) 0 ≤ <code>n</code> ≤ 500, 0 ≤ <code>nums[i]</code> ≤ 100</p><p><strong>Example:</strong></p><p>Given <code>[3, 1, 5, 8]</code></p><p>Return <code>167</code></p><pre>    nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []   coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167</pre><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定n个气球，下标为0到n-1。每个气球上都标有一个数字，用数组nums表示。你被要求扎破所有气球。扎破第i个气球可以获得nums[left] &times; nums[i] &times; nums[right]枚硬币。这里left和right是与i相邻的下标。扎破气球以后，left和right就变成相邻的了。<br>寻找最优策略下可以获得的硬币数。</p><p>注意：<br>(1) 你可以假设nums[-1] = nums[n] = 1. 它们并非真实的因此不能扎破。<br>(2) 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><ol><li>此题遍历所有可能性，所以考虑用DP  </li><li>因为一个参数不足以描述问题，因为并不能固定nums左端或右端，所以考虑二元DP，左右边界为参数。DP流程一：定义函数f(i,j)为nums[i..j]之间的最大硬币数。  </li><li>下一步写递归式，由于这是二元DP，参考Floyd和矩阵链乘法算法，一遍要定义一个k，二分法得到两个子问题的解f(i,k)和f(k,j)，求解它们的关系是难点。先写几个例子培养下思路：<br> 2,3,4<br> f([2,4])=2&times;3&times;4同时消去了3变成[2,4],再写一个<br> 2,3,4,5,6,7,8<br> k=5, 数组变成[2,5,8]所以我们定义中忽略了一个重要事实，修改为f(i,j)为nums[i..j]之间的最大硬币数<strong>及其它们之间的元素已经消去。</strong><br> 这样的话，关系就很明朗了，只要消去5就可以得到f([2,8])，k的定义要可以清晰了：最后一个消去的元素。<br> <strong>f(i,j)=max{f(i,m)+ nums[i]&times;nums[m]&times;nums[j] +f(m,j)}, i&lt;m&lt;j，m为整数</strong>  </li><li>我们还要试试nums为单元素和双元素情况下是否适用。比如单元素5，根据题目意思首先前后补1<br>1,5,1 -&gt; f(1,5)+1&times;5&times;1+f(5,1)=5这是正确的因为f(x,y)默认为0.<br>1,5,3,1, k=5, f(1,5)+1&times;5&times;1+f(5,1)=0+5+(5&times;3&times;1)=20 | k=3, f(1,3)+1&times;3&times;1+f(3,1)=(1&times;5&times;3)+3+0=18.所以也是正确，且f(x,y)默认为0没问题。  </li><li>遍历顺序。一开始我用i,j,m三重循环，但结果不对。主要因为这个计算过程与演算过程不一致，我们刚才的演算过程是先计算所有i和j之间的值。例如，<br>1,                      5,                               3,          1<br>i &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                   j<br>i &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       j<br>&nbsp;&nbsp;&nbsp;&nbsp;i &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       j<br>在第二次循环的时候f(i,j)已经计算出来很显然是不对的。</li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>二元DP+二分法。 二元DP中k的引入参考Floyd。  </li><li>原数组前后补1，这样巧妙地让递归式适用于一个元素的情况，避免特别处理。  </li><li>便利顺序也类似于Floyd，先k(步长且至少为2)，再遍历矩阵i和j。<strong>特别注意i&lt;n-k</strong>而不是i&lt;n  </li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = nums.length+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span>[] coins = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">coins[i+<span class="number">1</span>]=nums[i];</span><br><span class="line">coins[<span class="number">0</span>] = coins[n-<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>;k&lt;n;k++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n - k;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = i+k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> m=i+<span class="number">1</span>;m&lt;j;m++)</span><br><span class="line">dp[i][j] = Math.max(dp[i][j], dp[i][m]+coins[i]*coins[m]*coins[j] + dp[m][j]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>三重循环，时间复杂度为<code>O(n<sup>3</sup>)</code>，空间复杂度<code>O(n<sup>2</sup>)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/burst-balloons&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 312 Burst Balloons&lt;/a&gt;&lt;/strong&gt;&lt;/p
      
    
    </summary>
    
    
      <category term="Divide and Conquer" scheme="https://shineboy2013.github.com/tags/Divide-and-Conquer/"/>
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>DFS</title>
    <link href="https://shineboy2013.github.com/2017/12/24/dfs/"/>
    <id>https://shineboy2013.github.com/2017/12/24/dfs/</id>
    <published>2017-12-25T04:52:56.090Z</published>
    <updated>2018-01-10T08:59:44.580Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>图用邻接表为输入，思路递归实现, 还要一个机制记录节点访问过没有，可以用HashSet，同时它作为结果存储BFS访问结果。<br><strong>BFS多用于找最短路径</strong><br><strong>DFS多用于快速发现底部节点和具体路劲问题（如路径和或打印路径）。</strong></p><p>BFS优缺点：<br>同一层的所有节点都会加入队列，所以耗用大量空间<br>仅能非递归实现<br>相比DFS较快，空间换时间<br>适合广度大的图</p><p>DFS优缺点：<br>无论是系统栈还是用户栈保存的节点数都只是树的深度，所以空间耗用小<br>有递归和非递归实现<br>由于有大量栈操作（特别是递归实现时候的系统调用），执行速度较BFS慢<br>适合深度大的图</p><h3 id="算法步骤："><a href="#算法步骤：" class="headerlink" title="算法步骤："></a><strong>算法步骤：</strong></h3><ol><li>不合法情况（已访问、越界、trivial情况等）返回。</li><li>标记为已访问。</li><li>递归访问相邻节点。</li><li>DFS路径尽量记录在数组中而非ArrayList中，路径(图)再DFS后要恢复为原状态L332。</li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * graph: 邻接表</span></span><br><span class="line"><span class="comment"> * visited: 记录已访问节点，避免重复访问</span></span><br><span class="line"><span class="comment"> * start: DFS的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(HashMap&lt;Integer, LinkedList&lt;Integer&gt;&gt; graph, HashSet&lt;Integer&gt; visited, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(visited.contains(start))&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">visited.add(start);</span><br><span class="line">System.out.print(start+<span class="string">","</span>);</span><br><span class="line"><span class="keyword">for</span>(Integer child : graph.get(start))&#123;</span><br><span class="line">dfs(graph, visited, child);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，h为树的高度，空间复杂度<code>O(h)</code>，如果用系统栈，可理解其为O(1)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;图用邻接表为输入，思路递归实现, 还要一个机制记录节点访问过没有，可以用HashS
      
    
    </summary>
    
    
      <category term="Knowledge Base" scheme="https://shineboy2013.github.com/tags/Knowledge-Base/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 123 Best Time to Buy and Sell Stock III</title>
    <link href="https://shineboy2013.github.com/2017/12/24/lee-123/"/>
    <id>https://shineboy2013.github.com/2017/12/24/lee-123/</id>
    <published>2017-12-24T23:08:14.538Z</published>
    <updated>2017-12-31T06:27:35.429Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii" target="_blank" rel="noopener">LeetCode 123 Best Time to Buy and Sell Stock III</a></strong></p><p>Say you have an array for which the <em>i</em><sup>th</sup> element is the price of a given stock on day <em>i</em>.</p><p>Design an algorithm to find the maximum profit. You may complete at most <em>two</em> transactions.</p><p><strong>Note:</strong><br>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>假设你有一个数组，它的第i个元素是一支给定的股票在第i天的价格。设计一个算法来找到最大的利润。你最多可以完成两笔交易。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>回顾一下前两题：只能进行一次交易和可以无数次交易。分别是用(min, p),sum(prices[i]-prices[-1])的方法。这题很明显比较接近只能进行一次交易的题。<br>如果考虑将此问题分为两个子问题(Divide &amp; Conquer,二分法)，prices[0,k]和prices[k,n-1]，只要将k取遍所有值就得到解。</p><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> p = maxProfitSingle(Arrays.copyOfRange(prices,<span class="number">0</span>, i+<span class="number">1</span>))</span><br><span class="line">+ maxProfitSingle(Arrays.copyOfRange(prices,i, prices.length));</span><br><span class="line"><span class="keyword">if</span>(max&lt;p)</span><br><span class="line">max = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(<em>n</em><sup>2</sup>)</code>，空间复杂度<code>O(1)</code>。</p><p>上述解法并非最优，因为计算prices[0,k-1]到prices[0,k]时候再次重复计算用了O(n)，但由只能进行一次交易题解中知道，其实O(1)可得，只要在计算过程中把结果存入left数组中即可。<br>下面的难点在于计算prices[k,n-1]。右端点固定，从右到左计算，所以其实是只能进行一次交易题解的逆运算并把结果存入到right数组。区别是(max, p)。最后只要遍历left[k]+right[k],即可得到最大利润。</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>数组长度为0。</li><li>二分法</li><li>用数组存储重复计算结果(DP)</li></ol><h3 id="Java代码：-1"><a href="#Java代码：-1" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(prices.length==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//前i天最大利润，并非需要第i天卖出</span></span><br><span class="line"><span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line"><span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> min = prices[<span class="number">0</span>], maxPL = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> p = prices[i] - min;</span><br><span class="line"><span class="keyword">if</span>(maxPL&lt;p)</span><br><span class="line">maxPL = p;</span><br><span class="line">left[i] = maxPL;</span><br><span class="line"><span class="keyword">if</span>(min&gt;prices[i])</span><br><span class="line">min=prices[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> max=prices[prices.length-<span class="number">1</span>],maxPR=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=prices.length-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line"><span class="keyword">int</span> p=max-prices[j];</span><br><span class="line"><span class="keyword">if</span>(maxPR&lt;p)</span><br><span class="line">maxPR = p;</span><br><span class="line">right[j] = maxPR;</span><br><span class="line"><span class="keyword">if</span>(max&lt;prices[j])</span><br><span class="line">max=prices[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> maxP = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;prices.length;k++)&#123;</span><br><span class="line"><span class="keyword">if</span>(maxP&lt;left[k]+right[k])</span><br><span class="line">maxP = left[k]+right[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>。</p><h3 id="相关题目："><a href="#相关题目：" class="headerlink" title="相关题目："></a><strong>相关题目：</strong></h3><p><a href="https://shineboy2013.github.io/2017/11/27/lee-121/" target="_blank" rel="noopener">LeetCode 121 Best Time to Buy and Sell Stock</a><br><a href="https://shineboy2013.github.io/2017/11/28/lee-122/" target="_blank" rel="noopener">LeetCode 122 Best Time to Buy and Sell Stock II</a><br><a href="https://shineboy2013.github.io/2017/12/11/lee-309/" target="_blank" rel="noopener">LeetCode 309 Best Time to Buy and Sell Stock with Cooldown</a><br><a href="https://shineboy2013.github.io/2017/12/24/lee-123/" target="_blank" rel="noopener">LeetCode 123 Best Time to Buy and Sell Stock III</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 123 Best Time
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>Union Find</title>
    <link href="https://shineboy2013.github.com/2017/12/24/union-find/"/>
    <id>https://shineboy2013.github.com/2017/12/24/union-find/</id>
    <published>2017-12-24T18:51:12.340Z</published>
    <updated>2017-12-25T01:25:07.662Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>DFS用于需要知道具体路径的问题，而并查集方法用于不需知道具体路径只关心连通性的问题。<br>此算法把同一个连通集归结为同一个根节点，作为判断是否一个连通集的标识。它用深度为2的扁平树组织起来。这是查找操作。<br>另一个关键操作是联合两个不同连通集，就是直接把根节点直接作为另一课树的子节点。在这个过程中，新的树深度可能会大于2，但当要union路径大于2的节点是，会对其进行路径压缩。<br>最巧妙的操作当属find操作，将路径进行压缩，变成长度为1的路径，见步骤4。<br>可能有人会考虑用HashMap而不是树，HashMap查找也是很高效，但联合操作比较费时，因为要更新另一个树的所有节点的根节点。</p><h3 id="算法步骤："><a href="#算法步骤：" class="headerlink" title="算法步骤："></a><strong>算法步骤：</strong></h3><ol><li>初始化UnionFind类，包括3个属性：count（独立连通数）, parent（某节点的父节点）, rank（连通集排名）。合格的节点的parent初始化为自己的id，rank为0，count为所有合格节点数量。</li><li>遍历所有节点，<strong>union</strong>此节点及其相邻的节点（如上下左右）</li><li>union时候，先<strong>find</strong>两节点的根节点，若相同忽略。若不同，合并此两连通集：rank大的连通集，作为rank小的连通集的父节点。若rank相等，选任一作为另一个的父节点且把它的rank加1。count减1。<br>如下图，union 6和11的，find(6)会进行压缩路径，把6接到5下。<br><img src="/images/union-find-2.png" alt=""></li><li>find寻找根节点的同时，压缩成与根节点路径为1的连通。<br><img src="/images/union-find.png" alt=""></li></ol><p>例子矩阵：<br>{‘0’,’1’,’1’,’0’,’0’}<br>{‘1’,’1’,’1’,’0’,’0’}</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><p>find要注意压缩路径parent[i] = find(parent[i])</p><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count; <span class="comment">// # of connected components</span></span><br><span class="line"><span class="keyword">int</span>[] parent;</span><br><span class="line"><span class="keyword">int</span>[] rank;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123; <span class="comment">// for problem 200</span></span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> m = grid.length;</span><br><span class="line"><span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">parent = <span class="keyword">new</span> <span class="keyword">int</span>[m * n];</span><br><span class="line">rank = <span class="keyword">new</span> <span class="keyword">int</span>[m * n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">parent[i * n + j] = i * n + j;</span><br><span class="line">++count;</span><br><span class="line">&#125;</span><br><span class="line">rank[i * n + j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (parent[i] != i) &#123;</span><br><span class="line">parent[i] = find(parent[i]); <span class="comment">// path compression</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> parent[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// union with rank</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> rootx = find(x);</span><br><span class="line"><span class="keyword">int</span> rooty = find(y);</span><br><span class="line"><span class="keyword">if</span> (rootx != rooty) &#123;</span><br><span class="line"><span class="keyword">if</span> (rank[rootx] &gt; rank[rooty]) &#123;</span><br><span class="line">parent[rooty] = rootx;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootx] &lt; rank[rooty]) &#123;</span><br><span class="line">parent[rootx] = rooty;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">parent[rooty] = rootx;</span><br><span class="line">rank[rootx] += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">--count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands3</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nr = grid.length;</span><br><span class="line"><span class="keyword">int</span> nc = grid[<span class="number">0</span>].length;</span><br><span class="line"><span class="keyword">int</span> num_islands = <span class="number">0</span>;</span><br><span class="line">UnionFind uf = <span class="keyword">new</span> UnionFind(grid);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; nr; ++r) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; nc; ++c) &#123;</span><br><span class="line"><span class="keyword">if</span> (grid[r][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">grid[r][c] = <span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">if</span> (r - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r - <span class="number">1</span>][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">uf.union(r * nc + c, (r - <span class="number">1</span>) * nc + c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (r + <span class="number">1</span> &lt; nr &amp;&amp; grid[r + <span class="number">1</span>][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">uf.union(r * nc + c, (r + <span class="number">1</span>) * nc + c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (c - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r][c - <span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">uf.union(r * nc + c, r * nc + c - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (c + <span class="number">1</span> &lt; nc &amp;&amp; grid[r][c + <span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">uf.union(r * nc + c, r * nc + c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> uf.getCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(MN)</code>，空间复杂度<code>O(MN)</code>。M,N分别为矩阵长宽。遍历每个节点，而每个节点只会遍历4个相邻节点。</p><h3 id="Ref："><a href="#Ref：" class="headerlink" title="Ref："></a><strong>Ref：</strong></h3><p><a href="http://blog.csdn.net/dm_vincent/article/details/7655764" target="_blank" rel="noopener">并查集(Union-Find)算法介绍</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;DFS用于需要知道具体路径的问题，而并查集方法用于不需知道具体路径只关心连通性的问
      
    
    </summary>
    
    
      <category term="Knowledge Base" scheme="https://shineboy2013.github.com/tags/Knowledge-Base/"/>
    
  </entry>
  
</feed>
