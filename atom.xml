<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jiajie&#39;s blog</title>
  
  <subtitle>每天积累多一些</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shineboy2013.github.com/"/>
  <updated>2020-05-05T06:26:40.855Z</updated>
  <id>https://shineboy2013.github.com/</id>
  
  <author>
    <name>KK Shum</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 146 LRU Cache</title>
    <link href="https://shineboy2013.github.com/2020/05/04/lee-146/"/>
    <id>https://shineboy2013.github.com/2020/05/04/lee-146/</id>
    <published>2020-05-05T05:58:23.494Z</published>
    <updated>2020-05-05T06:26:40.855Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/lru-cache/" target="_blank" rel="noopener">LeetCode 146 LRU Cache</a></strong></p><div><br><br>Design and implement a data structure for <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU" target="_blank" rel="noopener">Least Recently Used (LRU) cache</a>. It should support the following operations: <code>get</code> and <code>put</code>.<br><br><code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br><code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.<br><br>The cache is initialized with a <strong>positive</strong> capacity.<br><br><strong>Follow up:</strong><br>Could you do both operations in <strong>O(1)</strong> time complexity?<br><br><strong>Example:</strong><br><br><pre>LRUCache cache = new LRUCache( 2 /<em> capacity </em>/ );<br><br>cache.put(1, 1);<br>cache.put(2, 2);<br>cache.get(1);       // returns 1<br>cache.put(3, 3);    // evicts key 2<br>cache.get(2);       // returns -1 (not found)<br>cache.put(4, 4);    // evicts key 1<br>cache.get(1);       // returns -1 (not found)<br>cache.get(3);       // returns 3<br>cache.get(4);       // returns 4<br></pre><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>设计LRU。就是最就的cache会先被删除。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>因为是Cache，get是O(1)，自然想到用HashMap。如果不限容量，get，put都可以O(1)。限容量的情况下，<br>就要删除部分数据，这里要求按key的时间排序，所以考虑用一个串将keys串联起来。而key的添加和删除<br>也要O(1)，所以考虑用LinkedList。HashMap和LinkedList的组合很常见。这里value就指向LL中的Node，<br>而Node中含key和value，key又可以让Node只向HashMap，做到互相索引。分析get和set，get就只要从Map<br>中读Node的value即可。set比较复杂，含三种情况：  </p><ol><li>已有节点  </li><li>不含节点且少于容量  </li><li>不含节点且大于等于容量  </li></ol><p>对应链表操作为：  </p><ol><li>删除该节点且插入到末尾  </li><li>插入新节点到末尾  </li><li>删除头节点且插入新节点到末尾  </li></ol><p>总结链表操作为两个：  </p><ol><li>删除某节点  </li><li>插入新节点到末尾  </li></ol><p>实现上可以分为单链表和双链表。单链表要让Map指向节点的父节点。实现上很麻烦，因为更新节点都会涉及<br>两个keys上HashMap更新，即使已有节点换到末尾同样要两次更新Map。但双链表对此情况就避免了Map的更新。  </p><p>DummyNode的选择：一开始我只选用了DummyHead，但capacity=1的时候要判断末节点是否为空很麻烦，由于<br>经常性的插入末节点，所以根据若头结点涉及插入删除就应该用dummyNode的原则，末节点也增加dummyNode<br>程序就简洁很多。</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>set中，若节点存在，更更新value。  </li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, ListNode&gt; map;</span><br><span class="line">ListNode head; <span class="comment">// from oldest to newest</span></span><br><span class="line">ListNode tail;</span><br><span class="line"><span class="keyword">int</span> capacity;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">L146LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">tail = <span class="keyword">new</span> ListNode(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">head.next = tail;</span><br><span class="line">tail.prev = head;</span><br><span class="line">map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!map.containsKey(key))</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">pushback(key);</span><br><span class="line"><span class="keyword">return</span> map.get(key).val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(map.containsKey(key)) &#123;</span><br><span class="line">pushback(key);</span><br><span class="line">map.get(key).val = value; <span class="comment">// remember to update the value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(map.size() == capacity) &#123;</span><br><span class="line">map.remove(head.next.key);</span><br><span class="line">deleteNode(head.next);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// add new key</span></span><br><span class="line">ListNode newNode = <span class="keyword">new</span> ListNode(key, value);</span><br><span class="line">addNodeToTail(newNode);</span><br><span class="line">map.put(key, newNode);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushback</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">ListNode curNode = map.get(key);</span><br><span class="line">deleteNode(curNode);</span><br><span class="line">addNodeToTail(curNode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addNodeToTail</span><span class="params">(ListNode curNode)</span> </span>&#123;</span><br><span class="line">ListNode prevTailNode = tail.prev;</span><br><span class="line">prevTailNode.next = curNode;</span><br><span class="line">curNode.prev = prevTailNode;</span><br><span class="line">curNode.next = tail;</span><br><span class="line">tail.prev = curNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// delete head node and updated node</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode curNode)</span> </span>&#123;</span><br><span class="line">ListNode nextNode = curNode.next;</span><br><span class="line">ListNode prevNode = curNode.prev;</span><br><span class="line">prevNode.next = nextNode;</span><br><span class="line">nextNode.prev = prevNode;</span><br><span class="line">curNode.next = <span class="keyword">null</span>;</span><br><span class="line">curNode.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> key;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line"><span class="keyword">public</span> ListNode next;</span><br><span class="line"><span class="keyword">public</span> ListNode prev;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.key = key;</span><br><span class="line"><span class="keyword">this</span>.val = val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(1)</code>，空间复杂度为<code>O(n)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/lru-cache/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 146 LRU Cache&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;b
      
    
    </summary>
    
    
      <category term="Hash Table" scheme="https://shineboy2013.github.com/tags/Hash-Table/"/>
    
      <category term="Linked List" scheme="https://shineboy2013.github.com/tags/Linked-List/"/>
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 126 Word Ladder II</title>
    <link href="https://shineboy2013.github.com/2020/05/03/lee-126/"/>
    <id>https://shineboy2013.github.com/2020/05/03/lee-126/</id>
    <published>2020-05-04T01:09:53.727Z</published>
    <updated>2020-05-04T08:15:59.088Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/word-ladder-ii/" target="_blank" rel="noopener">LeetCode 126 Word Ladder</a></strong></p><div><br><br>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find all shortest transformation sequence(s) from <em>beginWord</em> to <em>endWord</em>, such that:<br><br>1.  Only one letter can be changed at a time<br>2.  Each transformed word must exist in the word list. Note that <em>beginWord</em> is <em>not</em> a transformed word.<br><br><strong>Note:</strong><br><br><em>   Return an empty list if there is no such transformation sequence.</em>   All words have the same length.<br><em>   All words contain only lowercase alphabetic characters.</em>   You may assume no duplicates in the word list.<br><em>   You may assume <em>beginWord</em> and <em>endWord</em> are non-empty and are not the same.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong><br>beginWord = “hit”,<br>endWord = “cog”,<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]<br><br><strong>Output:</strong><br>[<br>  [“hit”,”hot”,”dot”,”dog”,”cog”],<br>  [“hit”,”hot”,”lot”,”log”,”cog”]<br>]<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong><br>beginWord = “hit”<br>endWord = “cog”<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”]<br><br><strong>Output:</strong> []<br><br><em>*Explanation:</em></pre></em> The endWord “cog” is not in wordList, therefore no possibletransformation.<br><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个字典和两个单词。每次变换一个字母的得到新单词且该词要在字典中。求所有最少的变换路径。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>更难于Leetcode 127，BFS用于找最短路径而DFS找路径，此题正是贯彻这一思想，先用BFS找出最短路径，<br>然后根据最短路径值找出所有路径。找BFS解的同时建图用邻接表表示Map<string, list<string="">&gt;(这是<br>部分图，与解相关的图)和解集合Map<string, integer="">(从始点到不同节点的最短距离)，这两个信息正是<br>Dijkistra的图输入和解。DFS从始点开始遍历邻接节点，确保沿着最短路径走，最短路径为<br>map.get(cur)+1=map.get(next)表示当前节点到始点距离+1=儿节点到始点距离，终止条件为找到目标节点。  </string,></string,></p><ol><li>在遍历所有邻接节点的时候，如果不加筛选对所有邻接节点都做DFS会造成LTE。关键是要利用BFS中所有<br>节点到单源的最短路径来剪枝。只需DFS最短路径上的节点，否则跳过。  </li><li>利用了单源最短路径映射表distance后，不需要记录visited，因为重复的节点不会在最短路劲上。  </li><li>Cache nextWords的结果。     </li></ol><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>这题是最短路径题，第一时间想到BFS。这是一条典型的单源最短路径问题。  </p><ol><li>建字典。  </li><li>BFS访问，得到图和单源最短路径Map，以及最短路径距离。  </li><li>DFS求路径，按最短路径剪枝。    </li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>建图要先建点，再建边。若不先建点， graph.get(cur)会NPE。</li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;</span><br><span class="line">List&lt;String&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span>(beginWord == <span class="keyword">null</span> || endWord == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is a dict and also keeps track of distance</span></span><br><span class="line">Map&lt;String, Integer&gt; dict = getDict(wordList);</span><br><span class="line"><span class="comment">// Make sure endWord is in the dict and can be the next word </span></span><br><span class="line"><span class="comment">//dict.put(endWord, 0);</span></span><br><span class="line">dict.put(beginWord, <span class="number">1</span>);</span><br><span class="line">HashMap&lt;String, List&lt;String&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">ladderLength(beginWord, endWord, dict, graph);</span><br><span class="line">path.add(beginWord);</span><br><span class="line">dfs(beginWord, endWord, dict, graph, path, res);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String cur, String endWord, Map&lt;String, Integer&gt; distance,</span></span></span><br><span class="line"><span class="function"><span class="params">HashMap&lt;String, List&lt;String&gt;&gt; graph, List&lt;String&gt; path, List&lt;List&lt;String&gt;&gt; res)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(endWord.equals(cur)) &#123;</span><br><span class="line">res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(String word : graph.get(cur)) &#123;</span><br><span class="line">path.add(word);</span><br><span class="line"><span class="keyword">if</span>(distance.get(word) - <span class="number">1</span> == distance.get(cur)) <span class="comment">// use distance, resolve LTE the most important</span></span><br><span class="line">dfs(word, endWord, distance, graph, path, res);</span><br><span class="line">path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cache getNextWords</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, Map&lt;String, Integer&gt; dict, Map&lt;String, List&lt;String&gt;&gt; graph)</span> </span>&#123;</span><br><span class="line">Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">q.offer(beginWord);</span><br><span class="line">visited.add(beginWord);</span><br><span class="line"><span class="keyword">for</span>(String s : dict.keySet()) &#123;<span class="comment">// remember</span></span><br><span class="line">graph.put(s, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">String word = q.poll();</span><br><span class="line"><span class="keyword">if</span>(endWord.equals(word))</span><br><span class="line"><span class="keyword">return</span> dict.get(word);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; nextWords = getNextWords(word, dict);</span><br><span class="line">graph.put(word, <span class="keyword">new</span> ArrayList&lt;&gt;(nextWords));</span><br><span class="line"><span class="keyword">for</span>(String s : nextWords) &#123;</span><br><span class="line"><span class="keyword">if</span>(visited.contains(s))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">q.offer(s);</span><br><span class="line">visited.add(s);</span><br><span class="line">dict.put(s, dict.get(word) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Map&lt;String, Integer&gt; <span class="title">getDict</span><span class="params">(List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(String word : wordList) &#123;</span><br><span class="line">map.put(word, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;String&gt; <span class="title">getNextWords</span><span class="params">(String word, Map&lt;String, Integer&gt; dict)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123; </span><br><span class="line"><span class="keyword">char</span> newChar = (<span class="keyword">char</span>)(<span class="string">'a'</span> + j);</span><br><span class="line"><span class="keyword">if</span>(word.charAt(i) == newChar) <span class="comment">// exclude itself</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">String newWord = word.substring(<span class="number">0</span>, i) + </span><br><span class="line">newChar + word.substring(i + <span class="number">1</span>, word.length());</span><br><span class="line"><span class="keyword">if</span>(dict.containsKey(newWord))</span><br><span class="line">result.add(newWord);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>getNextWords是L<em>26</em>L=<code>O(<em>L</em><sup>2</sup>)</code><br>时间复杂度为<code>O(n<em><em>L</em><sup>2</sup> + m</em>k)</code>，空间复杂度<code>O(n)</code>，m为答案个数, k为最短路径值。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/word-ladder-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 126 Word Ladder&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
      <category term="Breadth-first Search" scheme="https://shineboy2013.github.com/tags/Breadth-first-Search/"/>
    
      <category term="Depth-first Search" scheme="https://shineboy2013.github.com/tags/Depth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>组合</title>
    <link href="https://shineboy2013.github.com/2020/05/03/combination/"/>
    <id>https://shineboy2013.github.com/2020/05/03/combination/</id>
    <published>2020-05-03T21:53:45.466Z</published>
    <updated>2020-05-03T22:00:12.843Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>Leetcode 078的题目。这里作为知识点归纳。  </p><ol><li>递归中i=st开始。  </li><li>回溯： path递归后去恢复状态。  </li><li>dfs中传入i+1。  </li><li>结果要复制new ArrayList&lt;&gt;(path)  </li><li>一般来说，终止条件才加入结果，但由于子集任何path修改都是子集，所有立即加入。  </li></ol><h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a><strong>应用：</strong></h3><ol><li>找所有可能性</li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path)); <span class="comment">//empty set</span></span><br><span class="line"><span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">dfs(nums, <span class="number">0</span>, path, res);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> st, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(st == nums.length)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = st; i &lt; nums.length; i++) &#123;</span><br><span class="line">path.add(nums[i]);</span><br><span class="line">res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">dfs(nums, i + <span class="number">1</span>, path, res);</span><br><span class="line">path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(<em>2</em><sup>n</sup>)</code> ，空间复杂度<code>O(1)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;Leetcode 078的题目。这里作为知识点归纳。  &lt;/p&gt;
&lt;ol&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="Knowledge Base" scheme="https://shineboy2013.github.com/tags/Knowledge-Base/"/>
    
  </entry>
  
  <entry>
    <title>排列</title>
    <link href="https://shineboy2013.github.com/2020/05/03/permutation/"/>
    <id>https://shineboy2013.github.com/2020/05/03/permutation/</id>
    <published>2020-05-03T21:48:49.111Z</published>
    <updated>2020-05-03T21:57:41.620Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>Leetcode 046的题目。这里作为知识点归纳。  </p><ol><li>类似于组合题，但用到了visited数组且递归中从i=0开始。  </li></ol><h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a><strong>应用：</strong></h3><ol><li>找所有可能性</li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span>(nums == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">dfs(nums, <span class="keyword">new</span> HashSet&lt;&gt;(), path, res);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, Set&lt;Integer&gt; visited, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(path.size() == nums.length) &#123;</span><br><span class="line">res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(visited.contains(i))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">visited.add(i);</span><br><span class="line">path.add(nums[i]);</span><br><span class="line">dfs(nums, visited, path, res);</span><br><span class="line">visited.remove(i);</span><br><span class="line">path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n!)</code>，空间复杂度<code>O(1)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;Leetcode 046的题目。这里作为知识点归纳。  &lt;/p&gt;
&lt;ol&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="Knowledge Base" scheme="https://shineboy2013.github.com/tags/Knowledge-Base/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="https://shineboy2013.github.com/2020/04/26/quick-sort/"/>
    <id>https://shineboy2013.github.com/2020/04/26/quick-sort/</id>
    <published>2020-04-27T06:45:44.547Z</published>
    <updated>2020-04-27T06:54:06.249Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><ol><li>递归找pivot，然后按小于pivot和大于等于pivot分成两组。每轮递归，pivot肯定在正确（最终）位置上</li><li>partition方法类似于Leetcode75的sort colors一样用两个指针i和noSmallerIdx。i是循环指针，而<br>noSmallerIdx是第二组大于等于pivot的首元素，或者理解为将要交换的位置。  </li><li>循环结束后，将pivot交换到正确的位置上。</li></ol><h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a><strong>应用：</strong></h3><ol><li>排序</li><li>快速选择quick select</li><li>partition，如Leetcode 75</li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> pivotPos = partition(arr, left, right);</span><br><span class="line">quickSort(arr, left, pivotPos - <span class="number">1</span>);</span><br><span class="line">quickSort(arr, pivotPos + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> noSmallerIdx = left;</span><br><span class="line"><span class="keyword">int</span> pivot = arr[right];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt; right; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i] &lt; pivot) </span><br><span class="line">swap(arr, noSmallerIdx++, i);</span><br><span class="line">&#125;</span><br><span class="line">swap(arr, noSmallerIdx, right);</span><br><span class="line"><span class="keyword">return</span> noSmallerIdx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogn)</code>，空间复杂度<code>O(1)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;递归找pivot，然后按小于pivot和大于等于pivot分成两组。每
      
    
    </summary>
    
    
      <category term="Knowledge Base" scheme="https://shineboy2013.github.com/tags/Knowledge-Base/"/>
    
  </entry>
  
  <entry>
    <title>BST的非递归中序遍历</title>
    <link href="https://shineboy2013.github.com/2020/04/26/bst-iterative/"/>
    <id>https://shineboy2013.github.com/2020/04/26/bst-iterative/</id>
    <published>2020-04-26T18:52:08.235Z</published>
    <updated>2020-04-26T19:01:10.387Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><ol><li>首先初始化将root的所有左儿子加入到stack。</li><li>开始循环，取出节点，判断其右儿子不为空，因为左儿子已经访问过。  </li><li>若右子树不为空，跟初始化一样，将右子树的所有左儿子加入到栈中。  </li><li>用到两个指针node和n，分别指向出栈节点和遍历所有左儿子节点。  </li></ol><h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a><strong>应用：</strong></h3><ol><li>BST的关于Iterator的题目<a href="https://shineboy2013.github.io/2020/04/26/lee-173/" target="_blank" rel="noopener">Leetcode 173</a></li><li>不需要遍历所有节点而需要遍历某些节点的题目如求某target最接近N个节点。<a href="https://shineboy2013.github.io/2020/04/26/lee-272/" target="_blank" rel="noopener">Leetcode 272</a></li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">iterativeInorder</span><span class="params">(BinaryNode p)</span> </span>&#123;  </span><br><span class="line">Stack&lt;BinaryNode&gt; stack = <span class="keyword">new</span> Stack&lt;BinaryNode&gt;();  </span><br><span class="line">BinaryNode head = p;</span><br><span class="line"><span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">stack.push(head);</span><br><span class="line">head = head.left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BinaryNode node = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> (stack.size() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">node = stack.pop();</span><br><span class="line">System.out.print(node.data);</span><br><span class="line"><span class="keyword">if</span>(node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">BinaryNode n = node.right; </span><br><span class="line"><span class="keyword">while</span>(n != <span class="keyword">null</span>) &#123;</span><br><span class="line">stack.push(n);</span><br><span class="line">n = n.left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，n为字符串长度，空间复杂度<code>O(logn)</code>，最差为<code>O(n)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;首先初始化将root的所有左儿子加入到stack。&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="Knowledge Base" scheme="https://shineboy2013.github.com/tags/Knowledge-Base/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 272 Closest Binary Search Tree Value II</title>
    <link href="https://shineboy2013.github.com/2020/04/26/lee-272/"/>
    <id>https://shineboy2013.github.com/2020/04/26/lee-272/</id>
    <published>2020-04-26T18:31:21.211Z</published>
    <updated>2020-04-26T19:13:39.012Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/closest-binary-search-tree-value-ii/" target="_blank" rel="noopener">LeetCode 272 Closest Binary Search Tree Value II</a></strong></p><p>Given a non-empty binary search tree and a target value, find <em>k</em> values in the BST that are closest to the target.</p><p>Note:</p><ul><li>Given target value is a floating point.</li><li>You may assume <em>k</em> is always valid, that is: <em>k</em>≤ total nodes.</li><li>You are guaranteed to have only one unique set of <em>k</em> values in the BST that are closest to the target.</li></ul><p>Example:</p><pre>Input: root = [4,2,5,1,3], target = 3.714286, and _k_ = 2    4   / \  2   5 / \1   3Output: [4,3]</pre><p>Follow up:<br>Assume that the BST is balanced, could you solve it in less than <em>O</em>(<em>n</em>) runtime (where <em>n</em> = total nodes)?</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>找BST中给定目标的最接近的k个值。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>首先观察得到最接近的节点一定在二叉树的搜索路径上的节点的其中一个。这样可以分成两组<br>前驱节点和后驱节点（比target大），加入到两个stack中，由BST的iterator可以知道这两个<br>stack的越靠近栈首就越接近target，所以出栈的一定是最接近target的。只要比较两栈首元素<br>即可。如果某个节点出栈要找其儿子节点填充。找前驱节点和后驱节点的方法是相反的。这里可<br>参照KB的BST非递归中序遍历。    </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>target - preOrder.peek().val &lt; postOrder.peek().val - target的条件前<br>记得加上!preOrder.isEmpty()</li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; closestKValues(TreeNode root, double target, int k) &#123;</span><br><span class="line">List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">if(root == null)</span><br><span class="line">return res;</span><br><span class="line">Stack&lt;TreeNode&gt; preOrder = new Stack&lt;&gt;();</span><br><span class="line">Stack&lt;TreeNode&gt; postOrder = new Stack&lt;&gt;();</span><br><span class="line">findTargetAndPopulateStacks(preOrder, postOrder, root, target);</span><br><span class="line"></span><br><span class="line">while(k-- &gt; 0) &#123;</span><br><span class="line">if(postOrder.isEmpty() || (!preOrder.isEmpty() &amp;&amp; </span><br><span class="line">target - preOrder.peek().val &lt; postOrder.peek().val - target))</span><br><span class="line">getPredecessor(preOrder, res);</span><br><span class="line">else </span><br><span class="line">getSuccessor(postOrder, res);</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void findTargetAndPopulateStacks(Stack&lt;TreeNode&gt; preOrder, Stack&lt;TreeNode&gt; postOrder, </span><br><span class="line">TreeNode root, double target) &#123;</span><br><span class="line">TreeNode node = root;</span><br><span class="line">while(node != null) &#123;</span><br><span class="line">if(node.val &lt; target) &#123; </span><br><span class="line">preOrder.push(node);</span><br><span class="line">node = node.right;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">postOrder.push(node);</span><br><span class="line">node = node.left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void getSuccessor(Stack&lt;TreeNode&gt; postOrder, List&lt;Integer&gt; res) &#123;</span><br><span class="line">TreeNode node = postOrder.pop();</span><br><span class="line">res.add(node.val);</span><br><span class="line">if(node.right != null) &#123;</span><br><span class="line">TreeNode n = node.right;</span><br><span class="line">while(n != null) &#123;</span><br><span class="line">postOrder.push(n);</span><br><span class="line">n = n.left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void getPredecessor(Stack&lt;TreeNode&gt; preOrder, List&lt;Integer&gt; res) &#123;</span><br><span class="line">TreeNode node = preOrder.pop();</span><br><span class="line">res.add(node.val);</span><br><span class="line">if(node.left != null) &#123;</span><br><span class="line">TreeNode n = node.left;</span><br><span class="line">while(n != null) &#123;</span><br><span class="line">preOrder.push(n);</span><br><span class="line">n = n.right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为O(k + logn)，空间复杂度O(logn)。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/closest-binary-search-tree-value-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 272 Closest 
      
    
    </summary>
    
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
      <category term="Stack" scheme="https://shineboy2013.github.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 173 Binary Search Tree Iterator</title>
    <link href="https://shineboy2013.github.com/2020/04/26/lee-173/"/>
    <id>https://shineboy2013.github.com/2020/04/26/lee-173/</id>
    <published>2020-04-26T07:02:25.769Z</published>
    <updated>2020-04-26T19:05:51.968Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/binary-search-tree-iterator/" target="_blank" rel="noopener">LeetCode 173 Binary Search Tree Iterator</a></strong></p><div><br><br>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.<br><br>Calling <code>next()</code> will return the next smallest number in the BST.<br><br><strong>Example:</strong><br><br><strong><img src="https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png" alt=""></strong><br><br><pre>BSTIterator iterator = new BSTIterator(root);<br>iterator.next();    // return 3<br>iterator.next();    // return 7<br>iterator.hasNext(); // return true<br>iterator.next();    // return 9<br>iterator.hasNext(); // return true<br>iterator.next();    // return 15<br>iterator.hasNext(); // return true<br>iterator.next();    // return 20<br>iterator.hasNext(); // return false<br></pre><br><br><strong>Note:</strong><br><br><em>   <code>next()</code> and <code>hasNext()</code> should run in average O(1) time and uses O(<em>h</em>) memory, where <em>h</em> is the height of the tree.</em>   You may assume that <code>next()</code> call will always be valid, that is, there will be at least a next smallest number in the BST when <code>next()</code> is called.<br><br></div><h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>参照KB中BST的非递归中序遍历。将其分拆为初始化以及去掉stack不为空的循环分别为所求。 </p><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">L173BinarySearchTreeIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">TreeNode head = root;</span><br><span class="line"><span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">s.push(head);</span><br><span class="line">head = head.left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Recommended</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">TreeNode node = s.pop(); </span><br><span class="line"><span class="keyword">if</span>(node.right != <span class="keyword">null</span>) &#123;<span class="comment">// left node has been visited</span></span><br><span class="line">TreeNode n = node.right; </span><br><span class="line"><span class="keyword">while</span>(n != <span class="keyword">null</span>) &#123;</span><br><span class="line">s.push(n);</span><br><span class="line">n = n.left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> node.val;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@return</span> whether we have a next smallest number */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> !s.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>next的平均时间复杂度(amortized complexity)为<code>O(1)</code>，n为字符串长度，空间复杂度<code>O(logn)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/binary-search-tree-iterator/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 173 Binary Search Tr
      
    
    </summary>
    
    
      <category term="Stack" scheme="https://shineboy2013.github.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>Binary Search</title>
    <link href="https://shineboy2013.github.com/2020/04/21/binary-search/"/>
    <id>https://shineboy2013.github.com/2020/04/21/binary-search/</id>
    <published>2020-04-22T00:28:02.383Z</published>
    <updated>2020-04-22T00:34:42.800Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><ol><li>循环条件start + 1 &lt; end。 当跳出循环时，start和end的关系只能是相等或相邻。<br>相等是若数组只有一个元素，没有进入循环时出现。当进入过循环，一定是相邻。</li><li>跳出循环后比较start和end的关系从而判断答案。  </li></ol><p>这可以满足二分法找first position或者last position, peak element的题目。<br>first position中若等于target，end = mid，因为要在左半部分找，相反last<br>position在右半部分找，所以start = mid。</p><h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a><strong>应用：</strong></h3><ol><li>有序数组找目标</li><li>没给定目标情况下，找峰值</li><li>没给定目标情况下，求数值，如求根号</li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastPosition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>, end = nums.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(start + <span class="number">1</span> &lt; end) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">start = mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) </span><br><span class="line"><span class="comment">// Depends on the target on the right side or left side. For fist pos, use end = mid</span></span><br><span class="line">start = mid; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">end = mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(nums[end] == target)</span><br><span class="line"><span class="keyword">return</span> end;</span><br><span class="line"><span class="keyword">if</span>(nums[start] == target)</span><br><span class="line"><span class="keyword">return</span> start;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn)</code>，空间复杂度<code>O(1)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;循环条件start + 1 &amp;lt; end。 当跳出循环时，star
      
    
    </summary>
    
    
      <category term="Knowledge Base" scheme="https://shineboy2013.github.com/tags/Knowledge-Base/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1197 Minimum Knight Moves</title>
    <link href="https://shineboy2013.github.com/2020/04/20/lee-1197/"/>
    <id>https://shineboy2013.github.com/2020/04/20/lee-1197/</id>
    <published>2020-04-21T02:01:15.387Z</published>
    <updated>2020-04-21T02:14:46.630Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/minimum-knight-moves/" target="_blank" rel="noopener">LeetCode 1197 Minimum Knight Moves</a></strong></p><p>In an infinite chess board with coordinates from <code>-infinity</code> to <code>+infinity</code>, you have a knight at square <code>[0, 0]</code>.</p><p>A knight has 8 possible moves it can make, as illustrated below. Each move is two squares in a cardinal direction, then one square in an orthogonal direction.</p><p><img src="https://assets.leetcode.com/uploads/2018/10/12/knight.png" alt=""></p><p>Return the minimum number of steps needed to move the knight to the square <code>[x, y]</code>.  It is guaranteed the answer exists.</p><p>Example 1:</p><pre>Input: x = 2, y = 1Output: 1Explanation: [0, 0] → [2, 1]</pre><p>Example 2:</p><pre>Input: x = 5, y = 5Output: 4Explanation: [0, 0] → [2, 1] → [4, 2] → [3, 4] → [5, 5]</pre><p>Constraints:</p><ul><li><code>|x| + |y| &lt;= 300</code></li></ul><p>Because x and y are constrained to be in range[-300, 300], we can use BFS to find the minimum steps needed to reach target(x, y). Furthermore, we can only consider the case that x &gt;=0 &amp;&amp; y &gt;=0 since the chess board is symmetric.  The bfs implementation is pretty straightforward. There are two important points you need to be careful with.</p><ol><li>Pruning. We can limit the search dimension within 310 * 310. Any moves that lead to a position that is outside this box will not yield an optimal result.</li></ol><p>2. Initially, you used a Set of type int[] to track visited positions. This caused TLE because you didn’t overwrite the hashCode and equals methods for int[]. As a result, Set uses the default hashCode and equals method when checking if an element is already in the set. For equals(), The default implementation provided by the JDK is based on memory location — two objects are equal if and only if they are stored in the same memory address. For a comprehensive reading, refer to <a href="https://dzone.com/articles/working-with-hashcode-and-equals-in-java" target="_blank" rel="noopener">https://dzone.com/articles/working-with-hashcode-and-equals-in-java</a></p><p>O(x * y) runtime and space</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>象棋一样，走日字到达目标点的最小次数。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这题是最短路径题，第一时间想到BFS。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>这题是最短路径题，第一时间想到BFS。这是一条典型的单源最短路径问题。  </p><ol><li>建距离map。  </li><li>BFS访问。  </li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li><strong>用map记录距离一定要将首节点加入到map中，否则求距离时候会NPE。</strong>  </li><li>visited我一开始实现用HashSet但因为没有实现equals导致LTE，改成矩阵即可。  </li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] directX = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] directY = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,-<span class="number">2</span>,<span class="number">2</span>,-<span class="number">2</span>,<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestPath</span><span class="params">(<span class="keyword">boolean</span>[][] grid, Point source, Point destination)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Queue&lt;Point&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">Map&lt;Point, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(source, <span class="number">0</span>); <span class="comment">// remember</span></span><br><span class="line"><span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line">q.offer(source);</span><br><span class="line">visited[source.x][source.y] = <span class="keyword">true</span>; <span class="comment">// use hashSet is wrong.</span></span><br><span class="line"><span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">Point p = q.poll();</span><br><span class="line"><span class="keyword">if</span>(p.x == destination.x &amp;&amp; p.y == destination.y)</span><br><span class="line"><span class="keyword">return</span> map.get(p);</span><br><span class="line"><span class="keyword">for</span>(Point neighbor : getNeighbors(p)) &#123;</span><br><span class="line"><span class="keyword">if</span>(!isValid(grid, neighbor) || visited[neighbor.x][neighbor.y])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">q.offer(neighbor);</span><br><span class="line">visited[neighbor.x][neighbor.y] = <span class="keyword">true</span>;</span><br><span class="line">map.put(neighbor, map.get(p) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;Point&gt; <span class="title">getNeighbors</span><span class="params">(Point point)</span> </span>&#123;</span><br><span class="line">List&lt;Point&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">result.add(<span class="keyword">new</span> Point(point.x + directX[i], point.y + directY[i]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">boolean</span>[][] grid, Point point)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(point.x &gt;= <span class="number">0</span> &amp;&amp; point.x &lt; grid.length &amp;&amp; point.y &gt;= <span class="number">0</span> &amp;&amp; point.y &lt; grid[<span class="number">0</span>].length </span><br><span class="line">&amp;&amp; !grid[point.x][point.y])</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为棋盘大小<code>O(n*m)</code>，空间复杂度<code>O(n)</code>。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/minimum-knight-moves/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 1197 Minimum Knight Moves&lt;/
      
    
    </summary>
    
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
      <category term="Breadth-first Search" scheme="https://shineboy2013.github.com/tags/Breadth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 127 Word Ladder</title>
    <link href="https://shineboy2013.github.com/2020/04/20/lee-127/"/>
    <id>https://shineboy2013.github.com/2020/04/20/lee-127/</id>
    <published>2020-04-20T22:08:38.780Z</published>
    <updated>2020-05-04T01:11:35.704Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/word-ladder/" target="_blank" rel="noopener">LeetCode 127 Word Ladder</a></strong></p><div><br><br>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find the length of shortest transformation sequence from <em>beginWord</em> to <em>endWord</em>, such that:<br><br>1.  Only one letter can be changed at a time.<br>2.  Each transformed word must exist in the word list.<br><br><strong>Note:</strong><br><br><em>   Return 0 if there is no such transformation sequence.</em>   All words have the same length.<br><em>   All words contain only lowercase alphabetic characters.</em>   You may assume no duplicates in the word list.<br><em>   You may assume <em>beginWord</em> and <em>endWord</em> are non-empty and are not the same.<br><br><strong>Example 1:</strong><br><br><pre><strong>Input:</strong><br>beginWord = “hit”,<br>endWord = “cog”,<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]<br><br><strong>Output:</strong> 5<br><br><strong>Explanation:</strong> As one shortest transformation is “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,<br>return its length 5.<br></pre><br><br><strong>Example 2:</strong><br><br><pre><strong>Input:</strong><br>beginWord = “hit”<br>endWord = “cog”<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”]<br><br><strong>Output:</strong> 0<br><br><em>*Explanation:</em></pre></em> The endWord “cog” is not in wordList, therefore no possibletransformation.<br><br><br></div><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个字典和两个单词。每次变换一个字母的得到新单词且该词要在字典中。求最少变换次数。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这题是最短路径题，第一时间想到BFS。这是一条典型的单源最短路径问题。  </p><ol><li>这是图，所以要有visited记录是否重复访问。</li><li>字典的实现两个作用： 快速查找，以及记录距离可以省下一轮循环。总共两重循环。  </li><li>getNextWords的实现。通过变换每位上字母，比较巧妙。    </li></ol><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><p>这题是最短路径题，第一时间想到BFS。这是一条典型的单源最短路径问题。  </p><ol><li>建字典。  </li><li>BFS访问。  </li><li>求所有距离为1的相邻单词getNextWords。    </li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>getNextWords的实现不含自己。  </li><li>注意题目条件，开始词和终结词不一定在字典中，要将它们加入去。  </li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line"><span class="comment">// This is a dict and also keeps track of distance</span></span><br><span class="line">Map&lt;String, Integer&gt; dict = getDict(wordList);</span><br><span class="line"><span class="comment">// Make sure endWord is in the dict and can be the next word </span></span><br><span class="line"><span class="comment">//dict.put(endWord, 0);</span></span><br><span class="line">dict.put(beginWord, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">q.offer(beginWord);</span><br><span class="line">visited.add(beginWord);</span><br><span class="line"><span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">String word = q.poll();</span><br><span class="line"><span class="keyword">if</span>(endWord.equals(word))</span><br><span class="line"><span class="keyword">return</span> dict.get(word);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; nextWords = getNextWords(word, dict);</span><br><span class="line"><span class="keyword">for</span>(String s : nextWords) &#123;</span><br><span class="line"><span class="keyword">if</span>(visited.contains(s))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">q.offer(s);</span><br><span class="line">visited.add(s);</span><br><span class="line">dict.put(s, dict.get(word) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Map&lt;String, Integer&gt; <span class="title">getDict</span><span class="params">(List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(String word : wordList) &#123;</span><br><span class="line">map.put(word, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;String&gt; <span class="title">getNextWords</span><span class="params">(String word, Map&lt;String, Integer&gt; dict)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123; </span><br><span class="line"><span class="keyword">char</span> newChar = (<span class="keyword">char</span>)(<span class="string">'a'</span> + j);</span><br><span class="line"><span class="keyword">if</span>(word.charAt(i) == newChar) <span class="comment">// exclude itself</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">String newWord = word.substring(<span class="number">0</span>, i) + </span><br><span class="line">newChar + word.substring(i + <span class="number">1</span>, word.length());</span><br><span class="line"><span class="keyword">if</span>(dict.containsKey(newWord))</span><br><span class="line">result.add(newWord);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>getNextWords是L<em>26</em>L=<code>O(<em>L</em><sup>2</sup>)</code><br>时间复杂度为<code>O(n*<em>L</em><sup>2</sup>)</code>，空间复杂度<code>O(n)</code>。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/word-ladder/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 127 Word Ladder&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;di
      
    
    </summary>
    
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
      <category term="Breadth-first Search" scheme="https://shineboy2013.github.com/tags/Breadth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 297 Serialize and Deserialize Binary Tree</title>
    <link href="https://shineboy2013.github.com/2020/04/20/lee-297/"/>
    <id>https://shineboy2013.github.com/2020/04/20/lee-297/</id>
    <published>2020-04-20T18:36:09.608Z</published>
    <updated>2020-04-21T00:48:36.188Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">LeetCode 297 Serialize and Deserialize Binary Tree</a></strong></p><p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p><p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p><p><strong>Example: </strong></p><pre>You may serialize the following tree:    1   / \  2   3     / \    4   5as `"[1,2,3,null,null,4,5]"`</pre><p><strong>Clarification:</strong> The above format is the same as <a href="/faq/#binary-tree">how LeetCode serializes a binary tree</a>. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p><p><strong>Note: </strong>Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>序列化和反序列化二叉树。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>BFS可以涉及三重循环</p><ol><li>q不为空  </li><li>是否按层遍历  </li><li>是否为图  </li></ol><p>这题不需要按层遍历，所以不用第二重。而且只是二叉树，不用第三重循环。</p><p>编码方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">      1</span><br><span class="line">    /   \</span><br><span class="line">   #     3</span><br><span class="line">        /  \</span><br><span class="line">       2   #</span><br><span class="line">      / \</span><br><span class="line">     #   #</span><br><span class="line">=&gt; 1,#,3,2,#,#,#</span><br></pre></td></tr></table></figure></p><h3 id="BFS解题步骤："><a href="#BFS解题步骤：" class="headerlink" title="BFS解题步骤："></a><strong>BFS解题步骤：</strong></h3><p>serialize:  </p><ol><li>建queue，然后首节点入列</li><li>进入q的非空循环，队首出列，分别加入左右子树。由于左右子树可能为空，所以队首为空时continue<br>且val加入到结果字符串<br>乘以下标距离即为横向藏水增量，更新底部进入下一次出栈。  </li><li>用#代替null且删去末尾的#和，  </li></ol><p>deserialize:<br>这方法难实现点。用两个指针来代表遍历上一层和该层节点们。q出列的节点是上一层节点head，而idx指向的是<br>该层节点。这样head.left = Node(tokens[idx])就建立了它们的关系。两指针分别向后一位。每轮循环父指针<br>向后一位，而idx向后两位，因为有左右儿子。</p><ol><li>建queue，然后首节点入列</li><li>进入q的非空循环，队首出列，分别生成非空左右子树，且建立父子关系。idx走两步，非空儿子加入q。  </li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>字符串相等判断用equals，不用==。  </li><li>deserialize中循环条件要加入idx &lt; tokens.length因为serialize末尾#已经删除。  </li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serialize2</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">"&#123;&#125;"</span>;</span><br><span class="line"></span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">q.add(root);</span><br><span class="line"><span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">TreeNode n = q.poll();</span><br><span class="line">sb.append(n == <span class="keyword">null</span> ? <span class="string">"null"</span> : n.val);</span><br><span class="line">sb.append(<span class="string">","</span>);</span><br><span class="line"><span class="keyword">if</span>(n == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">q.add(n.left);</span><br><span class="line">q.add(n.right);</span><br><span class="line">&#125;</span><br><span class="line">String res = sb.toString().replaceAll(<span class="string">"null"</span>, <span class="string">"#"</span>);</span><br><span class="line"><span class="keyword">int</span> endIdx = res.length() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(res.charAt(endIdx) == <span class="string">','</span> || res.charAt(endIdx) == <span class="string">'#'</span>)</span><br><span class="line">endIdx--;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"&#123;"</span> + res.substring(<span class="number">0</span>, endIdx + <span class="number">1</span>) + <span class="string">"&#125;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize2</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">String str = data.substring(<span class="number">1</span>, data.length() - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="string">""</span>.equals(str))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">String[] tokens = str.split(<span class="string">","</span>);</span><br><span class="line"><span class="keyword">int</span> idx = <span class="number">1</span>;</span><br><span class="line">Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(tokens[<span class="number">0</span>]));</span><br><span class="line">q.offer(root);</span><br><span class="line"><span class="keyword">while</span>(!q.isEmpty() &amp;&amp; idx &lt; tokens.length) &#123;</span><br><span class="line">TreeNode head = q.poll();</span><br><span class="line"><span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">head.left = generateChildNode(idx++, tokens, q);</span><br><span class="line">head.right = generateChildNode(idx++, tokens, q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode <span class="title">generateChildNode</span><span class="params">(<span class="keyword">int</span> idx, String[] tokens, Queue&lt;TreeNode&gt; q)</span> </span>&#123;</span><br><span class="line">TreeNode root = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(idx &lt; tokens.length &amp;&amp; !<span class="string">"#"</span>.equals(tokens[idx])) &#123;</span><br><span class="line">root = <span class="keyword">new</span> TreeNode(Integer.parseInt(tokens[idx]));</span><br><span class="line">q.offer(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="DFS算法II解题思路："><a href="#DFS算法II解题思路：" class="headerlink" title="DFS算法II解题思路："></a><strong>DFS算法II解题思路：</strong></h3><p>DFS的serialize很简单，但deserialize比较难。有点类似于前序遍历的递归版，需要维护一个指针p来记录<br>已处理的字符串。  </p><p>编码方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">  2   3</span><br><span class="line">5  6</span><br><span class="line">=&gt; 1,2,5,#,#,6,#,#,3,#,#</span><br></pre></td></tr></table></figure></p><h3 id="Java代码：-1"><a href="#Java代码：-1" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">"#"</span>;</span><br><span class="line">String rootStr = root.val+<span class="string">""</span>;</span><br><span class="line">String lStr = serialize(root.left);</span><br><span class="line">String rStr = serialize(root.right);</span><br><span class="line"><span class="keyword">return</span> rootStr+<span class="string">","</span>+lStr+<span class="string">","</span>+rStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span></span>&#123;</span><br><span class="line">p = <span class="number">0</span>;</span><br><span class="line">items = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span> deserializeR(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserializeR</span><span class="params">(String data)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(data==<span class="keyword">null</span>||data.length()==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(p&gt;=data.length())</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">String curVal = getNext(data);</span><br><span class="line"><span class="keyword">if</span>(curVal.equals(<span class="string">"#"</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">TreeNode newRoot = <span class="keyword">new</span> TreeNode(Integer.parseInt(curVal));</span><br><span class="line">newRoot.left = deserializeR(data);</span><br><span class="line">newRoot.right = deserializeR(data);</span><br><span class="line"><span class="keyword">return</span> newRoot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">String[] items = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getNext</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(items==<span class="keyword">null</span>)</span><br><span class="line">items = s.split(<span class="string">","</span>);</span><br><span class="line"><span class="keyword">return</span> items[p++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/serialize-and-deserialize-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 297 Serial
      
    
    </summary>
    
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
      <category term="Breadth-first Search" scheme="https://shineboy2013.github.com/tags/Breadth-first-Search/"/>
    
      <category term="Depth-first Search" scheme="https://shineboy2013.github.com/tags/Depth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 133 Clone Graph</title>
    <link href="https://shineboy2013.github.com/2020/04/19/lee-133/"/>
    <id>https://shineboy2013.github.com/2020/04/19/lee-133/</id>
    <published>2020-04-20T06:41:45.806Z</published>
    <updated>2020-04-21T00:48:42.315Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/clone-graph/" target="_blank" rel="noopener">LeetCode 133 Clone Graph</a></strong></p><p>Given a reference of a node in a <strong><a href="https://en.wikipedia.org/wiki/Connectivity_(graph_theory" target="_blank" rel="noopener">connected</a>#Connected_graph)</strong> undirected graph.</p><p>Return a <a href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy" target="_blank" rel="noopener"><strong>deep copy</strong></a> (clone) of the graph.</p><p>Each node in the graph contains a val (<code>int</code>) and a list (<code>List[Node]</code>) of its neighbors.</p><pre>class Node {    public int val;    public List<node> neighbors;}</node></pre><p><strong>Test case format:</strong></p><p>For simplicity sake, each node’s value is the same as the node’s index (1-indexed). For example, the first node with <code>val = 1</code>, the second node with <code>val = 2</code>, and so on. The graph is represented in the test case using an adjacency list.</p><p><strong>Adjacency list</strong> is a collection of unordered <strong>lists</strong> used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.</p><p>The given node will always be the first node with <code>val = 1</code>. You must return the <strong>copy of the given node</strong> as a reference to the cloned graph.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2019/11/04/133_clone_graph_question.png" alt=""></p><pre>**Input:** adjList = [[2,4],[1,3],[2,4],[1,3]]**Output:** [[2,4],[1,3],[2,4],[1,3]]**Explanation:** There are 4 nodes in the graph.1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).</pre><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/01/07/graph.png" alt=""></p><pre>**Input:** adjList = [[]]**Output:** [[]]**Explanation:** Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.</pre><p><strong>Example 3:</strong></p><pre>**Input:** adjList = []**Output:** []**Explanation:** This an empty graph, it does not have any nodes.</pre><p><strong>Example 4:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/01/07/graph-1.png" alt=""></p><pre>**Input:** adjList = [[2],[1]]**Output:** [[2],[1]]</pre><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= Node.val &lt;= 100</code></li><li><code>Node.val</code> is unique for each node.</li><li>Number of Nodes will not exceed 100.</li><li>There is no repeated edges and no self-loops in the graph.</li><li>The Graph is connected and all nodes can be visited starting from the given node.</li></ul><p></p><p></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>深度复制图。注意要复制所有邻接节点。 </p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>BFS。</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>空节点判断。  </li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> UndirectedGraphNode <span class="title">cloneGraph2</span><span class="params">(UndirectedGraphNode node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">HashMap&lt;UndirectedGraphNode, UndirectedGraphNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">bfs(node, map);</span><br><span class="line"><span class="keyword">return</span> map.get(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(UndirectedGraphNode node, HashMap&lt;UndirectedGraphNode, UndirectedGraphNode&gt; map)</span> </span>&#123;</span><br><span class="line">Queue&lt;UndirectedGraphNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">q.offer(node);</span><br><span class="line">map.put(node, <span class="keyword">new</span> UndirectedGraphNode(node.label));</span><br><span class="line"><span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">UndirectedGraphNode head = q.poll();</span><br><span class="line"><span class="keyword">for</span>(UndirectedGraphNode neighbor : head.neighbors) &#123;</span><br><span class="line"><span class="keyword">if</span>(!map.containsKey(neighbor)) &#123;</span><br><span class="line">q.offer(neighbor);</span><br><span class="line"><span class="comment">// Clone vertex</span></span><br><span class="line">map.put(neighbor, <span class="keyword">new</span> UndirectedGraphNode(neighbor.label));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Clone edge</span></span><br><span class="line">map.get(head).neighbors.add(map.get(neighbor));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="算法II解题思路："><a href="#算法II解题思路：" class="headerlink" title="算法II解题思路："></a><strong>算法II解题思路：</strong></h3><p>三步走。分开写逻辑会显得清晰点。第一步，BFS搜索所有节点，变成邻接表。第二步，复制节点。第三步，复制边。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// another bfs3 method uses 3 steps, convert graph to adjacent list by bfs (flatten the graph), </span><br><span class="line">//clone vertices, clone edges</span><br><span class="line">public void bfs3(UndirectedGraphNode node, HashMap&lt;UndirectedGraphNode, UndirectedGraphNode&gt; map) &#123;</span><br><span class="line">ArrayList&lt;UndirectedGraphNode&gt; nodes = getNodes(node);</span><br><span class="line"></span><br><span class="line">// Copy vertices</span><br><span class="line">for(UndirectedGraphNode old : nodes) &#123;</span><br><span class="line">UndirectedGraphNode newNode = new UndirectedGraphNode(old.label);</span><br><span class="line">map.put(old, newNode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Copy edges</span><br><span class="line">for(UndirectedGraphNode old : nodes) &#123;</span><br><span class="line">for(UndirectedGraphNode neighbor : old.neighbors) &#123;</span><br><span class="line">map.get(old).neighbors.add(map.get(neighbor));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ArrayList&lt;UndirectedGraphNode&gt; getNodes(UndirectedGraphNode node) &#123;</span><br><span class="line">Queue&lt;UndirectedGraphNode&gt; q = new LinkedList&lt;&gt;();</span><br><span class="line">Set&lt;UndirectedGraphNode&gt; result = new HashSet&lt;&gt;();</span><br><span class="line">q.offer(node);</span><br><span class="line">result.add(node); // Use result set so we can save the visited set</span><br><span class="line">while(!q.isEmpty()) &#123;</span><br><span class="line">UndirectedGraphNode n = q.poll();</span><br><span class="line">for(UndirectedGraphNode neighbor : n.neighbors) &#123;</span><br><span class="line">if(result.contains(neighbor))</span><br><span class="line">continue;</span><br><span class="line">q.offer(neighbor);</span><br><span class="line">result.add(neighbor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ArrayList&lt;UndirectedGraphNode&gt; reList = new ArrayList&lt;UndirectedGraphNode&gt;();</span><br><span class="line">reList.addAll(result);</span><br><span class="line">return reList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="算法II解题思路：-1"><a href="#算法II解题思路：-1" class="headerlink" title="算法II解题思路："></a><strong>算法II解题思路：</strong></h3><p>DFS。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) &#123;</span><br><span class="line">HashMap&lt;Integer, UndirectedGraphNode&gt; map = new HashMap&lt;Integer, UndirectedGraphNode&gt;();</span><br><span class="line">return cloneGraphR(node, map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public UndirectedGraphNode cloneGraphR(UndirectedGraphNode node,</span><br><span class="line">HashMap&lt;Integer, UndirectedGraphNode&gt; map) &#123;</span><br><span class="line">if (node == null)</span><br><span class="line">return node;</span><br><span class="line">if (map.containsKey(node.label))</span><br><span class="line">return map.get(node.label);</span><br><span class="line"></span><br><span class="line">UndirectedGraphNode result = new UndirectedGraphNode(node.label);</span><br><span class="line">map.put(node.label, result);</span><br><span class="line">for (UndirectedGraphNode child : node.neighbors) &#123;</span><br><span class="line">result.neighbors.add(cloneGraphR(child, map));</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(# of results)</code>，空间复杂度<code>O(lengh(high))</code>。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/clone-graph/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 133 Clone Graph&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
      <category term="Breadth-first Search" scheme="https://shineboy2013.github.com/tags/Breadth-first-Search/"/>
    
      <category term="Depth-first Search" scheme="https://shineboy2013.github.com/tags/Depth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 248 Strobogrammatic Number III</title>
    <link href="https://shineboy2013.github.com/2020/03/08/lee-248/"/>
    <id>https://shineboy2013.github.com/2020/03/08/lee-248/</id>
    <published>2020-03-09T01:39:06.644Z</published>
    <updated>2020-04-21T00:48:50.595Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/strobogrammatic-number-iii/" target="_blank" rel="noopener">LeetCode 248 Strobogrammatic Number III</a></strong></p><p>A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).<br>Write a function to count the total strobogrammatic numbers that exist in the range of low &lt;= num &lt;= high.</p><p><strong>Example:</strong> </p><pre>**Input: low = "50", high = "100"**Output:** 3 Explanation: 69, 88, and 96 are three strobogrammatic numbers.</pre><p><strong>Note:</strong> Because the range might be a large number, the lowand high numbers are represented as string.</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>求某范围的旋转数的个数。旋转数是这个数旋转180度还是一样，如0, 1, 8， 还含两位的如69， 96. </p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这是M公司的题目。类似于L351安卓解码种数，数字间有关系，求[m, n]范围间种数。用DFS将每一位填上合法位，此题区别是<br>需要它有对称性，所以DFS从中间向两边。API为f(res, low, high, map), res为当前结果字符串，map为旋转数的映射关系，<br>终止条件为res超过high，若在范围内，结果+1，也就是先将自己加入到结果中，然后两边加入旋转字符，进入下一轮递归，<br>累加到结果中。  </p><p>注意: 与上题一样，和最左位不能为0除了0自己本身。</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>奇偶位。对称中心既可以是奇数位也可以是偶数位。  </li><li>最左位为0，不合法如0880，但0本身除外。  </li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strobogrammaticInRange</span><span class="params">(String low, String high)</span> </span>&#123;</span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"6"</span>, <span class="string">"9"</span>);</span><br><span class="line">map.put(<span class="string">"9"</span>, <span class="string">"6"</span>);</span><br><span class="line">map.put(<span class="string">"1"</span>, <span class="string">"1"</span>);</span><br><span class="line">map.put(<span class="string">"8"</span>, <span class="string">"8"</span>);</span><br><span class="line">map.put(<span class="string">"0"</span>, <span class="string">"0"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">result += dfs(<span class="string">""</span>, low, high, map);</span><br><span class="line">result += dfs(<span class="string">"1"</span>, low, high, map);</span><br><span class="line">result += dfs(<span class="string">"0"</span>, low, high, map);</span><br><span class="line">result += dfs(<span class="string">"8"</span>, low, high, map);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(String res, String low, String high, Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(res.length() &gt; high.length() || (res.length() == high.length() &amp;&amp; res.compareTo(high) &gt; <span class="number">0</span>)) </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>((res.length() == low.length() &amp;&amp; res.compareTo(low) &gt;= <span class="number">0</span>)  || res.length() &gt; low.length()) </span><br><span class="line">result = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(res.length() &gt; <span class="number">1</span> &amp;&amp; res.charAt(<span class="number">0</span>) == <span class="string">'0'</span>)</span><br><span class="line">result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">result += dfs(entry.getKey() + res + entry.getValue(), low, high, map);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(# of results)</code>，空间复杂度<code>O(lengh(high))</code>。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/strobogrammatic-number-iii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 248 Strobogrammatic N
      
    
    </summary>
    
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
      <category term="Depth-first Search" scheme="https://shineboy2013.github.com/tags/Depth-first-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 540 Single Element in a Sorted Array</title>
    <link href="https://shineboy2013.github.com/2019/02/26/lee-540/"/>
    <id>https://shineboy2013.github.com/2019/02/26/lee-540/</id>
    <published>2019-02-26T08:35:31.937Z</published>
    <updated>2019-03-23T07:52:07.794Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/single-element-in-a-sorted-array" target="_blank" rel="noopener">LeetCode 540 Single Element in a Sorted Array</a></strong></p><p>Given a sorted array consisting of only integers where every element appears twice except for one element which appears once. Find this single element that appears only once.</p><p><strong>Example 1:</strong>  </p><pre>**Input:** [1,1,2,3,3,4,4,8,8]**Output:** 2</pre><p><strong>Example 2:</strong>  </p><pre>**Input:** [3,3,7,7,10,11,11]**Output:** 10</pre><p><strong>Note:</strong> Your solution should run in O(log n) time and O(1) space.</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>一个有序数组中，每个数字都出现了两次，只有一个数字出现了一次，求出现一次的数字。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这是A公司Problem solving的题目。类似于L136。此题数组有序且要求O(logn)时间，所以考虑用二分法。由于没有输入tgt，有点似<br>算法文档中用二分法求峰值，就是用相邻两个数做二分法。考虑一个结论，若数组为偶数个数，就一定不存在只出现一次的元素。<br>所以必须考虑奇偶位，若下标mid为偶数，其后一位与其相等，就一定在右半边搜索left=mid+2(不会是mid和mid+1)，如第二个<br>例子，因为mid左边个数为偶数，利用结论可知不会在左边。同理与后一位不等，搜左边right=mid(可能为mid)。注意边界。<br>若mid为奇数，mid前面有奇数个，mid包括自己的后面有偶数个，所以mid和mid+1上的数相等，就应在左半搜，所以与偶数位的<br>情况正好相反，但是边界不同，产生了4个if语句。<br>法二：改进一下，若mid为奇数位，就mid–归结为偶数位的情况，这样if变成两个。  </p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>边界也就是mid的赋值，写出例子来理解。  </li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> N = nums.length;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = N - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line"><span class="keyword">boolean</span> isEven = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (mid % <span class="number">2</span> == <span class="number">1</span>) isEven = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> ((isEven &amp;&amp; nums[mid] != nums[mid + <span class="number">1</span>]) )</span><br><span class="line">right = mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (isEven &amp;&amp; nums[mid] == nums[mid + <span class="number">1</span>])</span><br><span class="line">left = mid + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!isEven &amp;&amp; nums[mid] == nums[mid + <span class="number">1</span>])</span><br><span class="line">right = mid-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNonDuplicate2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N = nums.length;</span><br><span class="line">  <span class="keyword">int</span> left = <span class="number">0</span>, right = N - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">  <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">  <span class="keyword">if</span> (mid % <span class="number">2</span> == <span class="number">1</span>) mid--;</span><br><span class="line">  <span class="keyword">if</span> (nums[mid] != nums[mid + <span class="number">1</span>])</span><br><span class="line">  right = mid;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  left = mid + <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(logn)</code>，空间复杂度<code>O(1)</code>。  </p><h3 id="Follow-up"><a href="#Follow-up" class="headerlink" title="Follow-up:"></a><strong>Follow-up:</strong></h3><p>首先问L316 Given a non-empty array of integers, every element appears twice except for one. Find that single one.<br>XOR解法，不用实现。<br>Follow up问题是L260 Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.<br>分三步。若只有一个数出现1次，只要把所有数异或^即可(相同数异或=0)。如果有两个此数，异或结果是这两数不同的位。只要选为1且最低位(或任意为1的位)lowBit=a-(a&amp;(a-1))。再扫所有数，根据它们在lowBit上=0和=1分组异或num1, num2，最后分组异或后它们为所求</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/single-element-in-a-sorted-array&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 540 Single Eleme
      
    
    </summary>
    
    
      <category term="Interviewer" scheme="https://shineboy2013.github.com/tags/Interviewer/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 042 Trapping Rain Water</title>
    <link href="https://shineboy2013.github.com/2018/07/12/lee-042/"/>
    <id>https://shineboy2013.github.com/2018/07/12/lee-042/</id>
    <published>2018-07-12T07:19:43.024Z</published>
    <updated>2019-07-20T09:37:15.227Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/trapping-rain-water" target="_blank" rel="noopener">LeetCode 042 Trapping Rain Water</a></strong></p><p>Given <em>n</em> non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p><p><img src="http://www.leetcode.com/static/images/problemset/rainwatertrap.png" alt=""><br><small>The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. <strong>Thanks Marcos</strong> for contributing this image!</small></p><p><strong>Example:</strong></p><pre>**Input:** [0,1,0,2,1,0,1,3,2,1,2,1]**Output:** 6</pre><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给出 n 个非负整数，代表一张X轴上每个区域宽度为 1 的海拔图, 计算这个海拔图最多能接住多少（面积）雨水。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>画图解题。<br>比较直观的方法是找低谷，只有低谷才可以藏水。用一个递减栈来存所有呈递减趋势的下标，而当上升时就计算藏水量。<br><img src="/images/L042-3.png" alt=""><br>从图可以看出，栈中有最高的，3,2,1，最矮的已经出栈了。蓝色的bar准备入栈。计算水量是水平计算的。具体而言，<br>右边界是确定的，左边界以及高度都是由此bar相邻的在栈中的bar确定的。如1的水量由bar2的高度和位置确定。<br>同理bar2的水量由bar3确定。特殊之处是计算栈中最后一个将要被新bar踢出栈的bar3时，并没有相邻的bar作参考，<br>导致它需要用新bar作为参考，所以它不能在while中处理，需要特别处理，主要因为它是最后一个，属于edge case。</p><h3 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a><strong>解题步骤：</strong></h3><ol><li>遍历数组</li><li>若比上一个高度递增，出栈直至栈中下标对应高度大于当前高度（保持递减栈）。每次出栈，用上一轮的高度作为底部计算高度差<br>乘以下标距离即为横向藏水增量，更新底部进入下一次出栈。  </li><li>出栈完成后，根据新bar计算最后一个bar的水量，用当前高度计算藏水增量。</li><li>加入下标到栈中</li></ol><hr><h3 id="算法II解题思路："><a href="#算法II解题思路：" class="headerlink" title="算法II解题思路："></a><strong>算法II解题思路：</strong></h3><p>算法I主要从面考虑，现在我们从点来考虑。下标4的水量取决于向左最大值（下标0）和向右最大值（下标12）中的较小值。<br>问题转化为求每个点的向左向右最大值。数组从左到右扫描，把当前最大值存入leftHeight中，这是向左最大值。<br><img src="/images/L042-2.png" alt=""><br>同理，数组从又到左扫描，得到向右最大值。对每个点取向左向右最大值的较小者，从而计算水量。此法实现起来简单很多。  </p><h3 id="Ref："><a href="#Ref：" class="headerlink" title="Ref："></a><strong>Ref：</strong></h3><p><a href="http://bangbingsyb.blogspot.com/2014/11/leetcode-trapping-rain-water.html" target="_blank" rel="noopener">http://bangbingsyb.blogspot.com/2014/11/leetcode-trapping-rain-water.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/trapping-rain-water&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 042 Trapping Rain Water&lt;/a&gt;&lt;/
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Two Pointers" scheme="https://shineboy2013.github.com/tags/Two-Pointers/"/>
    
      <category term="Stack" scheme="https://shineboy2013.github.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>Design Distributed ID Generator</title>
    <link href="https://shineboy2013.github.com/2018/06/17/design-distributed-id/"/>
    <id>https://shineboy2013.github.com/2018/06/17/design-distributed-id/</id>
    <published>2018-06-18T06:16:29.341Z</published>
    <updated>2018-06-18T07:14:09.010Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>生成唯一ID如用户ID，订单ID。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>基本思路是将所有网站映射到一个整数。<br>三大核心需求：</p><ol><li>全局唯一(unique)</li><li>按照时间粗略有序(sortable by time)。按时间查询是普遍的请求，如得到最新的1000个用户。</li><li>尽可能短。省空间，查询要更有效率。</li></ol><h3 id="UUID："><a href="#UUID：" class="headerlink" title="UUID："></a><strong>UUID：</strong></h3><p>UUID是一类算法的统称，具体有不同的实现。UUID的有点是每台机器可以独立产生ID，理论上保证<br>不会重复，所以天然是分布式的，缺点是生成的ID太长，不仅占用内存，而且索引查询效率低。<br>4个字节表示的Unix timestamp,<br>3个字节表示的机器的ID<br>2个字节表示的进程ID<br>3个字节表示的计数器</p><h3 id="多机器分别自增："><a href="#多机器分别自增：" class="headerlink" title="多机器分别自增："></a><strong>多机器分别自增：</strong></h3><p>假设用8台MySQL服务器协同工作，第一台MySQL初始值是1，每次自增8，第二台MySQL初始值是2，<br>每次自增8，依次类推。前面用一个 round-robin load balancer 挡着，每来一个请求，由<br>round-robin balancer 随机地将请求发给8台MySQL中的任意一个，然后返回一个ID。<br>load balance可以确保请求平均分配到不同的机器，所以粗略有序，缺点是加机器要re-hash这些Id<br>且顺序不够稳定。</p><h3 id="Twitter-Snowflake："><a href="#Twitter-Snowflake：" class="headerlink" title="Twitter Snowflake："></a><strong>Twitter Snowflake：</strong></h3><p>原理与UUID基本一样。也是时间戳+机器id+自增序号。时间戳保证有序。<br><img src="/images/design-distributed-id.png" alt="">  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目大意：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;生成唯一ID如用户ID，订单ID。&lt;/p&gt;
&lt;h3 id=&quot;解题思路：&quot;&gt;&lt;a h
      
    
    </summary>
    
    
      <category term="Design" scheme="https://shineboy2013.github.com/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 155 Min Stack</title>
    <link href="https://shineboy2013.github.com/2018/06/14/lee-155/"/>
    <id>https://shineboy2013.github.com/2018/06/14/lee-155/</id>
    <published>2018-06-14T07:12:02.826Z</published>
    <updated>2018-06-17T19:21:12.809Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/min-stack" target="_blank" rel="noopener">LeetCode 155 Min Stack</a></strong></p><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p><ul><li>push(x) – Push element x onto stack.</li><li>pop() – Removes the element on top of the stack.</li><li>top() – Get the top element.</li><li>getMin() – Retrieve the minimum element in the stack.</li></ul><p><strong>Example:</strong>  </p><pre>MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin();   --> Returns -3.minStack.pop();minStack.top();      --> Returns 0.minStack.getMin();   --> Returns -2.</pre><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>设计一个栈，支持在常数时间内push，pop，top，和取最小值。</p><p>push(x) – 元素x压入栈<br>pop() – 弹出栈顶元素<br>top() – 获取栈顶元素<br>getMin() – 获取栈中的最小值</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这是考察Algorithm和data structure的经典问题。用stack即可实现push，top，pop。难点在于O(1)内实现getMin。看一个例子，<br>按以下顺序加入stack     5, 3, 6, 8, 2<br>最小值                 5, 3, 3, 3, 2<br>可以看出来，最小值是动态变化的，所以需要动态处理，由于存储的方式与stack一致，所以可以考虑再用一个stack来存最小值。<br>如果不用额外stack改用Node，将make_pair(x, curMin)一起压入栈stack<node<int,int>&gt;中，额外空间复杂度O(n)。 见算法2。<br>稍改进空间复杂度，最小值只存变化的值，也就是5,3,2，当最小值变化时再存入最小栈。出栈时候，若出栈元素等于最小栈中的元素，<br>最小栈的元素也要出栈。</node<int,int></p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>当前最小元素可能相等。相等元素也要入最小栈，如5,3,6,3，最小栈为5,3,3。x &lt;= minS.peek()一定要取等于。</li><li>考虑栈为空时，执行pop和peek的操作。这里存在一个decision point，设计原则与stack的操作一致，也就是暴露出exception。</li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        minS = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        s.push(x);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(minS.isEmpty() || x &lt;= minS.peek())</span><br><span class="line">        minS.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> top = s.pop();</span><br><span class="line">        <span class="keyword">if</span>(top == minS.peek())</span><br><span class="line">        minS.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minS.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;Integer&gt; s;</span><br><span class="line">    Stack&lt;Integer&gt; minS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(1)</code>，空间复杂度<code>O(n)</code>。</p><p>算法2也是可以通过leetcode测试的，虽然空间复杂度比上述差。<br><a href="https://dotblogs.com.tw/tsanmmmm2000/2017/05/19/leetcode-practice-min-stack" target="_blank" rel="noopener">存储每个新加值对应的min，更加浪费空间</a></p><h3 id="Follow-up"><a href="#Follow-up" class="headerlink" title="Follow-up:"></a><strong>Follow-up:</strong></h3><p>如果用O(1)额外空间，怎么改进算法？ </p><p>先考虑最简单的情况，用一个min来记录当前最小值，它可以满足最小值不需更新的情况：<br>x表示要加入的值，m表示最小值的变量，y是真正加入栈的值<br>x 1 5 3<br>m 1 1 1<br>y 1 5 3<br>可以看出无论入栈出栈，最小值均为1.  </p><p>比较难的是最小值需要更新时，如下一个要加入0，最小值要更新m=0，但0不能入栈，前一个最小值1的信息就丢失了，所以要设计一个计算y方法(push)满足  </p><ol><li>含有前一个最小值的的信息。x1&lt;m0.  </li><li>y&lt;m, 因为最小值不更新的时候y值永远大于等于m，必须区分开来，从而知道怎么pop，也就是还原入栈值（最小值）。y1&lt;m1=x1.</li></ol><p>以下解释如何推出y的计算方式，以及push和pop的方法：<br><img src="/images/L155.png" alt="">  </p><p>以下例子解释Push<br>x 1 5 3 0 6<br>m 1 1 1 0 0<br>y 1 5 3 -1 6</p><p>以下例子解释Pop<br>x 6 0 3 5 1<br>m 0 0 1 1 1<br>y 6 -1 3 5 1<br>可以看出真正入栈值可以是原数或者是计算值，取决它与最小值的关系。</p><h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>当前最小元素可能相等。相等元素不用更新最小值，也就是新值直接入栈。</li><li>以上递推式的初始条件为：第一个元素是直接加入栈且等于m，无论何种情况都不需任何计算。push时候注意当栈为空，m值为第一个元素的值。</li><li>数据溢出。涉及int的加减乘除法，都要预先将其转化为long，否则会溢出。</li></ol><h3 id="Java代码：-1"><a href="#Java代码：-1" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.isEmpty())</span><br><span class="line">    m = x;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> xx = (<span class="keyword">long</span>)x;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= m)</span><br><span class="line">    s.push(xx);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    s.push(<span class="number">2</span>*xx-m);</span><br><span class="line">    m = x;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> top = s.pop();</span><br><span class="line">        <span class="keyword">if</span>(top &lt; m)     </span><br><span class="line">        m = <span class="number">2</span>*m - top;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(s.peek() &gt;= m? s.peek() : m);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)m;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;Long&gt; s;</span><br><span class="line">    <span class="keyword">long</span> m = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(1)</code>，空间复杂度<code>O(1)</code>。</p><h3 id="考点"><a href="#考点" class="headerlink" title="考点:"></a><strong>考点:</strong></h3><ol><li>先不考虑getMin，用什么数据结构实现push, pop, top</li><li>暴力法可以实现getMin，怎么实现O(1)。用什么数据结构实现存储min，额外用一个stack</li><li>元素可能相等</li><li>考虑栈为空时，执行pop和peek的操作</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/min-stack&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 155 Min Stack&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Desig
      
    
    </summary>
    
    
      <category term="Design" scheme="https://shineboy2013.github.com/tags/Design/"/>
    
      <category term="Interviewer" scheme="https://shineboy2013.github.com/tags/Interviewer/"/>
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
      <category term="Stack" scheme="https://shineboy2013.github.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 128 Longest Consecutive Sequence</title>
    <link href="https://shineboy2013.github.com/2018/05/07/lee-128/"/>
    <id>https://shineboy2013.github.com/2018/05/07/lee-128/</id>
    <published>2018-05-08T06:57:44.775Z</published>
    <updated>2018-06-14T08:41:33.567Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/longest-consecutive-sequence" target="_blank" rel="noopener">LeetCode 128 Longest Consecutive Sequence</a></strong></p><p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p><p>Your algorithm should run in O(<em>n</em>) complexity.</p><p><strong>Example:</strong></p><pre>**Input:** [100, 4, 200, 1, 3, 2]**Output:** 4**Explanation:** The longest consecutive elements sequence is `[1, 2, 3, 4]`. Therefore its length is 4.</pre><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给出一个未排序的整数数组，找出最长的连续元素序列的长度。<br>如： 给出[100, 4, 200, 1, 3, 2]，最长的连续元素序列是[1, 2, 3, 4]。返回它的长度：4。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这是连通问题，如果用排序方法，很容易，但时间复杂度为O(nlogn)。考虑改进，因为连通集，容易想到HashMap，把每个元素加入到其中，<br>然后对每个元素进行相邻查找。相邻查找就是以此元素为中心，向上向下在Map查找，从而得到此元素的最大连续序列长度。查找过的元素<br>在Map中删除，以免重复计算。</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>Java中在for循环中不能修改hashSet，所以只能用HashMap且value存boolean替代。HashMap表示此Map还是否含有该元素。</li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">HashMap&lt;Integer,Boolean&gt; hm = <span class="keyword">new</span> HashMap&lt;Integer,Boolean&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i : nums)</span><br><span class="line">hm.put(i, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">Iterator it = hm.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line"><span class="keyword">int</span> key = (<span class="keyword">int</span>)it.next();</span><br><span class="line"><span class="keyword">int</span> i = key+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(hm.containsKey(i) &amp;&amp; hm.get(i))&#123;</span><br><span class="line">count++;</span><br><span class="line">hm.put(i, <span class="keyword">false</span>);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">i = key-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(hm.containsKey(i) &amp;&amp; hm.get(i))&#123;</span><br><span class="line">count++;</span><br><span class="line">hm.put(i, <span class="keyword">false</span>);</span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(count&gt;result)</span><br><span class="line">result = count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-consecutive-sequence&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 128 Longest Consecut
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Hash Table" scheme="https://shineboy2013.github.com/tags/Hash-Table/"/>
    
      <category term="Union Find" scheme="https://shineboy2013.github.com/tags/Union-Find/"/>
    
  </entry>
  
  <entry>
    <title>Design Chime</title>
    <link href="https://shineboy2013.github.com/2018/05/01/design-chime/"/>
    <id>https://shineboy2013.github.com/2018/05/01/design-chime/</id>
    <published>2018-05-02T05:21:57.460Z</published>
    <updated>2018-05-03T03:14:42.356Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>Design a chatting application like Chime  </p><h3 id="了解用户需求："><a href="#了解用户需求：" class="headerlink" title="了解用户需求："></a><strong>了解用户需求：</strong></h3><p>通过不断和面试官沟通，了解用户角度的需求。把这些需求逐一列举在白板上。面试者一开始会刻意只说出1-2点。面试者通过联系实际，不够构想<br>一些需求，若得到确认就要写入。</p><ol><li>用户可以单对单相互聊天(one-on-one chat)</li><li>用户可以群聊(group chat)</li><li>用户可登陆</li><li>用户可以添加好友(sending)，接受好友(accepting)，拒绝添加(rejecting). 好友相互添加(mutual)，不支持两人分别添加。</li><li>用户更新状态为offline, available, busy, don’t disturb，还有个性化签名</li></ol><p>面试者通过重新排序user life cycle更有助于理解和记忆</p><ol><li>用户可登陆</li><li>用户可以添加好友(sending)，接受好友(accepting)，拒绝添加(rejecting)</li><li>用户可以单对单相互聊天(one-on-one chat)</li><li>用户可以群聊(group chat)</li><li>用户更新状态为offline, available, busy, don’t disturb，还有个性化签名</li></ol><p>本面试不支持以下use cases<br>音频会议，视频会议，文件传输</p><h3 id="Block-Component-diagram："><a href="#Block-Component-diagram：" class="headerlink" title="Block/Component diagram："></a><strong>Block/Component diagram：</strong></h3><p>最简单的设计就是一系列的clients，一系列的servers，还有存储系统。<br><img src="/images/chime.png" alt=""><br>存储系统可以选择SQL或者No SQL。No SQL就会更加scalable.这里可以讨论它们之间的pros和cons。<br>传输协议(client-server)可用Java中的Socket和ServerSocket对象，它们建立一个TCP连接，用IO Stream传输。<br>服务器端用多个服务器避免single point of failure。server端的memory会存一些用户状态等数据（当然它也会被持久化），这表示它需要<br>    replicate一些数据减少不同机器之间的lookup时间。</p><p>这些大概讨论一下即可，本design主要针对OOD。</p><h3 id="Class-diagram："><a href="#Class-diagram：" class="headerlink" title="Class diagram："></a><strong>Class diagram：</strong></h3><p>从User开始写fields和key methods，因为需求就是针对用户，比较直观。当参数含有多个属性时，就应该考虑产生一个新的class，如Message，<br>因为Message不只内容String还有发送时间甚至styling等。 还有注意每个类是否存在状态(如UserStatus)，如果有，就要考虑用enum。</p><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">User:</span><br><span class="line">   <span class="keyword">int</span> id;</span><br><span class="line">   String fullName;</span><br><span class="line">   String alias;</span><br><span class="line">   List&lt;User&gt; friends;</span><br><span class="line">   List&lt;GroupChat&gt; gChats;</span><br><span class="line">   List&lt;PrivateChat&gt; pChats;</span><br><span class="line">   UserStatus s;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">sign</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">signout</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">sendFriend</span><span class="params">(FriendRequest r)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">acceptFriend</span><span class="params">(FriendRequest r)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">rejectFriend</span><span class="params">(FriendRequest r)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setUserStatus</span><span class="params">(UserStatus s)</span></span>;</span><br><span class="line">   <span class="function">PrivateChat <span class="title">createConversation</span><span class="params">(User b)</span></span>;</span><br><span class="line">   <span class="function">GroupChat <span class="title">createConversation</span><span class="params">(List&lt;User&gt; c)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(PrivateChat s, String msg)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(GroupChat s, String msg)</span></span>;</span><br><span class="line"></span><br><span class="line">Conversation:</span><br><span class="line">   <span class="keyword">int</span> id;</span><br><span class="line">   List&lt;User&gt; users;</span><br><span class="line">   List&lt;Message&gt; messages;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">addMessage</span><span class="params">(Message msg)</span></span>;</span><br><span class="line">   </span><br><span class="line">PrivateChat extends Conversation:</span><br><span class="line">   PrivateChat(User user, User user2);</span><br><span class="line"></span><br><span class="line">GroupChat extends Conversation:</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User u)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">removeUser</span><span class="params">(User u)</span></span>;</span><br><span class="line">   </span><br><span class="line">Message:</span><br><span class="line">   <span class="keyword">int</span> id;</span><br><span class="line">   Date timestamp;</span><br><span class="line">   User user;<span class="comment">//I would like to know who sent this msg</span></span><br><span class="line">   String content;</span><br><span class="line"></span><br><span class="line">FriendRequest:</span><br><span class="line">   User from;</span><br><span class="line">   User to;</span><br><span class="line">   Date timestamp;</span><br><span class="line">   RequestStatus Status;</span><br><span class="line"></span><br><span class="line">UserStatus:</span><br><span class="line">   String message;</span><br><span class="line">   UserStatusType type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> RequestStatus:</span><br><span class="line">   ACCEPTED, REJECTED, PENDING</span><br><span class="line"> </span><br><span class="line"><span class="keyword">enum</span> UserStatusType:</span><br><span class="line">   offline, available, busy, DONT_disturb</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个类最为复杂，主要是维护用户关系和用户状态以及对应的数据库读写。这里有几个隐形需求。。可以根据alias搜索用户，  </span></span><br><span class="line"><span class="comment">//如果用户offline，即使是好友也不能发信息。它是singleton。</span></span><br><span class="line">UserManager:</span><br><span class="line">   HashMap&lt;String, User&gt; usersByAlias;</span><br><span class="line">   <span class="comment">//User类需要含有UserManager，查看要发送信息的对象是否在线，若不在线，不能发出信息。</span></span><br><span class="line">   HashMap&lt;Integer, User&gt; onlineUsers;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserManager <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (instance==<span class="keyword">null</span>) instance = <span class="keyword">new</span> UserManager();</span><br><span class="line">   <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//用observer模式，User调用UserManager这个接口来更新onlineUsers</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">signInUser</span><span class="params">(String alias)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">signOutUser</span><span class="params">(String alias)</span></span>;</span><br><span class="line">   <span class="comment">//User to的acceptFriend会调用这个函数来更新User a和User b的friend list同时更新FriendRequest的状态。</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">approveRequest</span><span class="params">(FriendRequest f)</span></span>;</span><br></pre></td></tr></table></figure><p>具体实现可以选择approveRequest或者某用户发信息怎么令group chat的其他用户收到该信息sendMessage(GroupChat s, String msg)。</p><p>void sendMessage(GroupChat s, String msg){<br>    List<user> users = s.getUsers();<br>}</user></p><h3 id="扩展问题："><a href="#扩展问题：" class="headerlink" title="扩展问题："></a><strong>扩展问题：</strong></h3><ol><li>怎么知道某用户真的在线</li><li>怎么处理内存和数据冲突的信息</li><li>怎么让server scale</li><li>怎么防止DDOS攻击</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目大意：&quot;&gt;&lt;a href=&quot;#题目大意：&quot; class=&quot;headerlink&quot; title=&quot;题目大意：&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目大意：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;Design a chatting application like Chime 
      
    
    </summary>
    
    
      <category term="Design" scheme="https://shineboy2013.github.com/tags/Design/"/>
    
      <category term="Object Oriented Design" scheme="https://shineboy2013.github.com/tags/Object-Oriented-Design/"/>
    
  </entry>
  
</feed>
