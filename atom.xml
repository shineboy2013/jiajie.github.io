<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jiajie&#39;s blog</title>
  
  <subtitle>每天积累多一些</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shineboy2013.github.com/"/>
  <updated>2018-01-10T07:33:18.967Z</updated>
  <id>https://shineboy2013.github.com/</id>
  
  <author>
    <name>KK Shum</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 332 Reconstruct Itinerary</title>
    <link href="https://shineboy2013.github.com/2018/01/09/lee-332/"/>
    <id>https://shineboy2013.github.com/2018/01/09/lee-332/</id>
    <published>2018-01-10T06:17:56.450Z</published>
    <updated>2018-01-10T07:33:18.967Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/reconstruct-itinerary" target="_blank" rel="noopener">LeetCode 332 Reconstruct Itinerary</a></strong></p><p>Given a list of airline tickets represented by pairs of departure and arrival airports <code>[from, to]</code>, reconstruct the itinerary in order. All of the tickets belong to a man who departs from <code>JFK</code>. Thus, the itinerary must begin with <code>JFK</code>.</p><p><strong>Note:</strong>  </p><ol><li>If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary <code>[&quot;JFK&quot;, &quot;LGA&quot;]</code> has a smaller lexical order than <code>[&quot;JFK&quot;, &quot;LGB&quot;]</code>.</li><li>All airports are represented by three capital letters (IATA code).</li><li>You may assume all tickets form at least one valid itinerary.</li></ol><p><strong>Example 1:</strong><br><code>tickets</code> = <code>[[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]]</code><br>Return <code>[&quot;JFK&quot;, &quot;MUC&quot;, &quot;LHR&quot;, &quot;SFO&quot;, &quot;SJC&quot;]</code>.  </p><p><strong>Example 2:</strong><br><code>tickets</code> = <code>[[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]</code><br>Return <code>[&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]</code>.<br>Another possible reconstruction is <code>[&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;]</code>. But it is larger in lexical order.</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一组机票，用出发机场和到达机场[from, to]来表示，重建行程的顺序。所有的机票都属于一个从JFK（肯尼迪国际机场）出发的旅客。因此，行程必须从JFK开始。</p><p>注意：</p><p>如果存在多重有效的行程，你应当返回字典序最小的那个。例如，行程[“JFK”, “LGA”]的字典序比[“JFK”, “LGB”]要小。<br>所有的机场用3个大写字母表示（IATA编码）。<br>你可以假设所有的机票均至少包含一条有效的行程。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这条题实质是记录DFS路径的题目，且对儿子节点的选择是有顺序的。值得注意的是并不是所有路径都是可形成回路，所以需要DFS搜索。<br>既然是要记录路径就需要用数组保存结果，而有顺序则表示要排序。</p><ol><li>建图，用邻接表来表示HashMap<string, linkedlist<string="">&gt; graph</string,></li><li>对每个节点的邻节点LinkList进行排序</li><li>从JFK开始dfs。1)终止条件为所有ticket都遍历了(达成回路)或者不能够遍历完。2)路径存在数组中。 3)通过删除节点表示已访问DFS该节点后图要恢复成原状态。</li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>终止条件为所有ticket都遍历了(达成完整路)或者不能够遍历完。如{“JFK”,”KUL”},{“JFK”,”NRT”},{“NRT”,”JFK”}，虽然KUL在NRT前，但KUL不能组成回路。</li><li>DFS路径尽量存在数组中，否则用ArrayList中就要先add再remove。</li><li>通过删除节点表示已访问DFS该节点后图要恢复成原状态。</li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findItinerary</span><span class="params">(String[][] tickets)</span> </span>&#123;</span><br><span class="line">HashMap&lt;String, LinkedList&lt;String&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;String, LinkedList&lt;String&gt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tickets.length;i++)&#123;</span><br><span class="line">LinkedList&lt;String&gt; neighbor = graph.get(tickets[i][<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span>(neighbor==<span class="keyword">null</span>)</span><br><span class="line">neighbor = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">neighbor.add(tickets[i][<span class="number">1</span>]);</span><br><span class="line">graph.put(tickets[i][<span class="number">0</span>], neighbor);</span><br><span class="line">&#125;</span><br><span class="line">Iterator&lt;String&gt; it = graph.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">String key = it.next();</span><br><span class="line">LinkedList&lt;String&gt; neighbor = graph.get(key);</span><br><span class="line">Collections.sort(neighbor);</span><br><span class="line">graph.put(key, neighbor);</span><br><span class="line">&#125;</span><br><span class="line">String[] re = <span class="keyword">new</span> String[tickets.length+<span class="number">1</span>];</span><br><span class="line">String cur = <span class="string">"JFK"</span>;</span><br><span class="line">re[<span class="number">0</span>] = cur;</span><br><span class="line">isDFS(graph,cur,tickets.length,tickets.length,re);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(re));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDFS</span><span class="params">(HashMap&lt;String, LinkedList&lt;String&gt;&gt; graph, String departCity</span></span></span><br><span class="line"><span class="function"><span class="params">,<span class="keyword">int</span> ticketLeft, <span class="keyword">int</span> ticketNum, String[] re)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ticketLeft==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;    </span><br><span class="line">LinkedList&lt;String&gt; desCity = graph.get(departCity);</span><br><span class="line"><span class="keyword">if</span>(desCity==<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;desCity.size();i++)&#123;</span><br><span class="line">String cur = desCity.get(i);</span><br><span class="line">re[ticketNum-ticketLeft+<span class="number">1</span>] = cur;</span><br><span class="line">desCity.remove(i);</span><br><span class="line">graph.put(departCity, desCity);</span><br><span class="line"><span class="keyword">if</span>(isDFS(graph,cur,ticketLeft-<span class="number">1</span>,ticketNum,re))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;;</span><br><span class="line">desCity.add(i,cur);</span><br><span class="line">graph.put(departCity, desCity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>。    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/reconstruct-itinerary&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 332 Reconstruct Itinerary&lt;/
      
    
    </summary>
    
    
      <category term="Depth-first Search" scheme="https://shineboy2013.github.com/tags/Depth-first-Search/"/>
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
      <category term="Graph" scheme="https://shineboy2013.github.com/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 347 Top K Frequent Elements</title>
    <link href="https://shineboy2013.github.com/2017/12/31/lee-347/"/>
    <id>https://shineboy2013.github.com/2017/12/31/lee-347/</id>
    <published>2018-01-01T00:16:23.505Z</published>
    <updated>2018-01-03T08:39:43.435Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/top-k-frequent-elements" target="_blank" rel="noopener">LeetCode 347 Top K Frequent Elements</a></strong></p><p>Given a non-empty array of integers, return the <strong><em>k</em></strong> most frequent elements.</p><p>For example,<br>Given <code>[1,1,1,2,2,3]</code> and k = 2, return <code>[1,2]</code>.</p><p><strong>Note:</strong>  </p><ul><li>You may assume <em>k</em> is always valid, 1 ≤ <em>k</em> ≤ number of unique elements.</li><li>Your algorithm’s time complexity <strong>must be</strong> better than O(<em>n</em> log <em>n</em>), where <em>n</em> is the array’s size.</li></ul><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个非空整数数组，返回其前k个出现次数最多的元素。</p><p>注意：<br>你可以假设k总是有效的，1 ≤ k ≤ 独立元素的个数。<br>你的算法时间复杂度必须优于O(n log n)，其中n是数组的长度。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这是经典题，解法是HeapSelect：求最大k个数，就先对前k个元素建最小堆，然后遍历k到最后一个数，若它大于栈顶就替换且做minHeapify。最后结果是<br>最大的k个数在数组的前k个位置且堆顶（数组第一个数）为k个数的最小。堆并没有排序。<br>结果并不需要从大到小输出。</p><ol><li>统计词频</li><li>建key-value数组</li><li>heapSelect</li><li>把数组前k个数加入到结果集中</li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>如果需要按大到小输出结果，需要对result进行排序O(klogk)，数组第一个也就是最小堆堆顶是这k个数中最小。</li><li>key-pair版堆选择算法。</li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(map.containsKey(nums[i]))</span><br><span class="line">map.put(nums[i], map.get(nums[i])+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">map.put(nums[i], <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">Node[] f = <span class="keyword">new</span> Node[map.size()];</span><br><span class="line">Iterator it = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">Map.Entry pair = (Map.Entry)it.next();</span><br><span class="line">Node node = <span class="keyword">new</span> Node((<span class="keyword">int</span>)pair.getValue(), (<span class="keyword">int</span>)pair.getKey());</span><br><span class="line">f[j++] = node;</span><br><span class="line">&#125;</span><br><span class="line">hselect(f, k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">result.add(f[i].value);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hselect</span><span class="params">(Node a[], <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="comment">// min heap with size=k</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = k / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">minHeapify(a, i, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; a.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i].key &gt; a[<span class="number">0</span>].key) &#123;</span><br><span class="line">swap(a, i, <span class="number">0</span>);</span><br><span class="line">minHeapify(a, <span class="number">0</span>, k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">minHeapify</span><span class="params">(Node[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> largest = i;</span><br><span class="line"><span class="keyword">int</span> l = left(i);</span><br><span class="line"><span class="keyword">int</span> r = l + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (l &lt; n &amp;&amp; arr[l].key &lt; arr[largest].key)</span><br><span class="line">largest = l;</span><br><span class="line"><span class="keyword">if</span> (r &lt; n &amp;&amp; arr[r].key &lt; arr[largest].key)</span><br><span class="line">largest = r;</span><br><span class="line"><span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">swap(arr, i, largest);</span><br><span class="line">minHeapify(arr, largest, n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Node[] arr, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">Node tmp = arr[index1];</span><br><span class="line">arr[index1] = arr[index2];</span><br><span class="line">arr[index2] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> key;</span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">key = k;</span><br><span class="line">value = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"("</span>+key+<span class="string">","</span>+value+<span class="string">")"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(nlogk)</code>，空间复杂度<code>O(1)</code>。   </p><hr><h3 id="算法II解题思路："><a href="#算法II解题思路：" class="headerlink" title="算法II解题思路："></a><strong>算法II解题思路：</strong></h3><p>此题关于数组频数，所以考虑用桶排序(bucket sort)</p><ol><li>统计词频（元素-&gt;频数）</li><li>桶排序：n+1个桶（n为原数组大小），把元素放入频数对应的桶号（频数-&gt;元素），用List把这些元素串起来。</li><li>逆序（从大到小）遍历不为空的桶，输入结果直至k个。<br>与上面算法不同的是结果是从大到小输出。数据类型有两个HashMap存储元素对应的频数，而List数组List<integer>[]反过来存储频数对应的元素。</integer></li></ol><h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>桶排序要用List串联起元素，例如[1,2],k=2，频数为1的元素有两个，所以桶的内容应该是List。</li><li>桶数量为原数组大小+1，例如一个元素[1], 它的频数为1，而频数为0是不会出现。</li><li>逆序遍历所有桶，只要结果集个数为k，就停止循环。</li></ol><h3 id="Java代码：-1"><a href="#Java代码：-1" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent2</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"> List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"> HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(map.containsKey(nums[i]))</span><br><span class="line">map.put(nums[i], map.get(nums[i])+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">map.put(nums[i], <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> List&lt;Integer&gt;[] f = <span class="keyword">new</span> List[nums.length+<span class="number">1</span>];</span><br><span class="line"> Iterator it = map.entrySet().iterator();</span><br><span class="line"> <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line"> Map.Entry pair = (Map.Entry)it.next();</span><br><span class="line"> <span class="keyword">if</span>(f[(<span class="keyword">int</span>)pair.getValue()]==<span class="keyword">null</span>)</span><br><span class="line"> f[(<span class="keyword">int</span>)pair.getValue()] = <span class="keyword">new</span> ArrayList();</span><br><span class="line"> f[(<span class="keyword">int</span>)pair.getValue()].add((<span class="keyword">int</span>)pair.getKey());</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=f.length-<span class="number">1</span>;i&gt;<span class="number">0</span> &amp;&amp; result.size()&lt;k;i--)</span><br><span class="line"> <span class="keyword">if</span>(f[i]!=<span class="keyword">null</span>)&#123;</span><br><span class="line"> result.addAll(f[i]);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/top-k-frequent-elements&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 347 Top K Frequent Elemen
      
    
    </summary>
    
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
      <category term="Heap" scheme="https://shineboy2013.github.com/tags/Heap/"/>
    
      <category term="Hash Table" scheme="https://shineboy2013.github.com/tags/Hash-Table/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 350 Intersection of Two Arrays II</title>
    <link href="https://shineboy2013.github.com/2017/12/31/lee-350/"/>
    <id>https://shineboy2013.github.com/2017/12/31/lee-350/</id>
    <published>2017-12-31T21:41:43.968Z</published>
    <updated>2018-01-03T05:37:14.627Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/intersection-of-two-arrays-ii" target="_blank" rel="noopener">LeetCode 350 Intersection of Two Arrays II</a></strong></p><p>Given two arrays, write a function to compute their intersection.</p><p><strong>Example:</strong><br>Given <em>nums1</em> = <code>[1, 2, 2, 1]</code>, <em>nums2</em> = <code>[2, 2]</code>, return <code>[2, 2]</code>.</p><p><strong>Note:</strong>  </p><ul><li>Each element in the result should appear as many times as it shows in both arrays.</li><li>The result can be in any order.</li></ul><p><strong>Follow up:</strong>  </p><ul><li>What if the given array is already sorted? How would you optimize your algorithm?</li><li>What if <em>nums1</em>‘s size is small compared to <em>nums2</em>‘s size? Which algorithm is better?</li><li>What if elements of <em>nums2</em> are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</li></ul><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定两个数组，编写函数计算它们的交集。  </p><p>注意：<br>结果中的每个元素的出现次数应与其在两个数组中同时出现的次数一样多。 结果可以采用任意顺序。  </p><p>进一步思考：<br>如果数组已经排好序，怎样优化你的算法？<br>如果nums1的长度＜nums2的长度？哪一种算法更好？<br>如果nums2的元素存储在磁盘上，并且内存大小有限，不足以将其一次性的加载到内存中。此时应当怎样做？  </p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>类似于L349，但由于可允许重复，所以改hashSet成hashMap记录频数。具体而言，将较小的数组的所有元素放入hashMap且统计频数，<br>然后遍历另一个数组判断是否相同，相同的话放入ArrayList的结果集中且频数减一。</p><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line"><span class="comment">//swap and make sure length of nums1 is smaller</span></span><br><span class="line"><span class="keyword">if</span>(nums1.length&gt;nums2.length)&#123;</span><br><span class="line"><span class="keyword">int</span>[] tmp = nums1;</span><br><span class="line">nums1 = nums2;</span><br><span class="line">nums2 = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Map&lt;Integer, Integer&gt; map=<span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">List&lt;Integer&gt; result=<span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums1.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(map.containsKey(nums1[i]))</span><br><span class="line">map.put(nums1[i], map.get(nums1[i])+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">map.put(nums1[i],<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums2.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(map.containsKey(nums2[i]) &amp;&amp; map.get(nums2[i])&gt;<span class="number">0</span>)&#123;</span><br><span class="line">result.add(nums2[i]);</span><br><span class="line">map.put(nums2[i], map.get(nums2[i])-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result.stream().mapToInt(i-&gt;i).toArray();      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>m和n为数组长度m&gt;n，时间复杂度为<code>O(m)</code>，空间复杂度<code>O(n)</code>。    </p><hr><h3 id="算法II解题思路："><a href="#算法II解题思路：" class="headerlink" title="算法II解题思路："></a><strong>算法II解题思路：</strong></h3><p>另一个解题思路是，先对它们排序，然后类似于mergeSort算法维持两个指针分别在两个数组搜索相同元素。</p><h3 id="Java代码：-1"><a href="#Java代码：-1" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">List&lt;Integer&gt; result=<span class="keyword">new</span> ArrayList();</span><br><span class="line">Arrays.sort(nums1);</span><br><span class="line">Arrays.sort(nums2);</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;nums1.length &amp;&amp; j&lt;nums2.length)&#123;</span><br><span class="line"><span class="keyword">if</span>(nums1[i]==nums2[j])&#123;</span><br><span class="line">result.add(nums1[i]);</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(nums1[i]&lt;nums2[j])</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">else</span> j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result.stream().mapToInt(k-&gt;k).toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>m和n为数组长度m&gt;n，时间复杂度为<code>O(mlogm)</code>，空间复杂度<code>O(1)</code>。此算法空间较优，但时间稍逊。</p><ol><li>如果数组已经排好序，怎样优化你的算法？<br>用第二个算法，时间复杂度为O(m),但空间复杂度可以优化为O(1)  </li><li>如果nums1的长度＜nums2的长度？哪一种算法更好？<br>方法一更优，因为nums1空间用的比较少情况下</li><li>如果nums2的元素存储在磁盘上，并且内存大小有限，不足以将其一次性的加载到内存中。此时应当怎样做？<br>也应该用方法一，因为它不需要把nums2数组一次性加载到内存中。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/intersection-of-two-arrays-ii&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 350 Intersection of
      
    
    </summary>
    
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
      <category term="Hash Table" scheme="https://shineboy2013.github.com/tags/Hash-Table/"/>
    
      <category term="Two Pointers" scheme="https://shineboy2013.github.com/tags/Two-Pointers/"/>
    
      <category term="Binary Search" scheme="https://shineboy2013.github.com/tags/Binary-Search/"/>
    
      <category term="Sort" scheme="https://shineboy2013.github.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 349 Intersection of Two Arrays</title>
    <link href="https://shineboy2013.github.com/2017/12/31/lee-349/"/>
    <id>https://shineboy2013.github.com/2017/12/31/lee-349/</id>
    <published>2017-12-31T20:40:30.982Z</published>
    <updated>2018-01-03T05:38:10.240Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/intersection-of-two-arrays" target="_blank" rel="noopener">LeetCode 349 Intersection of Two Arrays</a></strong></p><p>Given two arrays, write a function to compute their intersection.</p><p><strong>Example:</strong><br>Given <em>nums1</em> = <code>[1, 2, 2, 1]</code>, <em>nums2</em> = <code>[2, 2]</code>, return <code>[2]</code>.</p><p><strong>Note:</strong>  </p><ul><li>Each element in the result must be unique.</li><li>The result can be in any order.</li></ul><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定两个数组，编写函数计算它们的交集。  </p><p>注意：<br>结果中的每个元素一定是唯一的。<br>结果可以采用任意顺序。  </p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>将较小的数组的所有元素放入hashSet，然后遍历另一个数组判断是否相同，相同的话放入hashSet的结果集中。所以需要两个hashSet。</p><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line"><span class="comment">//swap and make sure length of nums1 is smaller</span></span><br><span class="line"><span class="keyword">if</span>(nums1.length&gt;nums2.length)&#123;</span><br><span class="line"><span class="keyword">int</span>[] tmp = nums1;</span><br><span class="line">nums1 = nums2;</span><br><span class="line">nums2 = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Set&lt;Integer&gt; hash=<span class="keyword">new</span> HashSet();</span><br><span class="line">Set&lt;Integer&gt; result=<span class="keyword">new</span> HashSet();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums1.length;i++)</span><br><span class="line">hash.add(nums1[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums2.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(hash.contains(nums2[i]))</span><br><span class="line">result.add(nums2[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span>[] r=<span class="keyword">new</span> <span class="keyword">int</span>[result.size()];</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i : result)</span><br><span class="line">r[k++]=i;</span><br><span class="line"><span class="keyword">return</span> r;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>m和n为数组长度m&gt;n，时间复杂度为<code>O(m)</code>，空间复杂度<code>O(n)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/intersection-of-two-arrays&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 349 Intersection of Tw
      
    
    </summary>
    
    
      <category term="Hash Table" scheme="https://shineboy2013.github.com/tags/Hash-Table/"/>
    
      <category term="Two Pointers" scheme="https://shineboy2013.github.com/tags/Two-Pointers/"/>
    
      <category term="Binary Search" scheme="https://shineboy2013.github.com/tags/Binary-Search/"/>
    
      <category term="Sort" scheme="https://shineboy2013.github.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 316 Remove Duplicate Letters</title>
    <link href="https://shineboy2013.github.com/2017/12/31/lee-316/"/>
    <id>https://shineboy2013.github.com/2017/12/31/lee-316/</id>
    <published>2017-12-31T19:07:51.935Z</published>
    <updated>2018-01-03T05:38:30.464Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/remove-duplicate-letters" target="_blank" rel="noopener">LeetCode 316 Remove Duplicate Letters</a></strong></p><p>Given a string which contains only lowercase letters, remove duplicate letters so that every letter appear once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.</p><p><strong>Example:</strong>  </p><p>Given <code>&quot;bcabc&quot;</code><br>Return <code>&quot;abc&quot;</code></p><p>Given <code>&quot;cbacdcbc&quot;</code><br>Return <code>&quot;acdb&quot;</code></p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个只包含小写字母的字符串，从中移除重复字母使得每个字母只出现一次。你必须确保结果的字典序最小。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这题是保持原顺序输出结果，所以考虑用递减栈。先看例子bcabc-&gt;abc，a入栈倒逼bc出栈，可解此题。再看cbacdcbc，acd时候b入栈，不能倒逼cd出栈<br>因为d是唯一一个，所以还要维护一个hashMap来记录每个字母的词频。所以入栈条件为准入栈元素小于栈顶元素且栈顶元素为最后一个（频数&gt;0）。<br>hashMap作用有两个，第一个为统计词频，第二个为记录未处理（未入for循环）的字母的频数。<br>resultSet记录stack中所有唯一元素，用于判断是否需要入栈。</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>已在栈内的<strong>重复元素</strong>不入栈，也不倒逼任何元素出栈，也就是直接忽略它，只要将其频数减一即可，表示已处理。比如abacb，第二个a不能倒逼b。  </li><li>进入循环后频数立刻减一，不要出列时候才做，参见BFS。  </li><li>入栈条件：栈不为空，准入栈元素小于栈顶元素，栈顶元素频数&gt;0。  </li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicateLetters</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line">Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">Set&lt;Character&gt; result = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">Character c = s.charAt(i);</span><br><span class="line"><span class="keyword">if</span>(map.containsKey(c))</span><br><span class="line">map.put(c, map.get(c)+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">map.put(c, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">Character c = s.charAt(i);</span><br><span class="line">map.put(c, map.get(c)-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Stack已经有c就不加入</span></span><br><span class="line"><span class="keyword">if</span>(result.contains(c))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; c&lt;stack.peek() &amp;&amp; map.get(stack.peek())&gt;<span class="number">0</span>)&#123;</span><br><span class="line">result.remove(stack.peek());</span><br><span class="line">stack.pop();</span><br><span class="line">&#125;</span><br><span class="line">stack.push(c);</span><br><span class="line">result.add(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">while</span>(!stack.isEmpty())</span><br><span class="line">sb.append(stack.pop());</span><br><span class="line"><span class="keyword">return</span> sb.reverse().toString();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>所有元素入栈出栈最多一次，所以时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/remove-duplicate-letters&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 316 Remove Duplicate Let
      
    
    </summary>
    
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
      <category term="Greedy" scheme="https://shineboy2013.github.com/tags/Greedy/"/>
    
      <category term="Stack" scheme="https://shineboy2013.github.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 312 Burst Balloons</title>
    <link href="https://shineboy2013.github.com/2017/12/28/lee-312/"/>
    <id>https://shineboy2013.github.com/2017/12/28/lee-312/</id>
    <published>2017-12-28T17:58:22.880Z</published>
    <updated>2018-01-03T05:43:09.228Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/burst-balloons" target="_blank" rel="noopener">LeetCode 312 Burst Balloons</a></strong></p><p>Given <code>n</code> balloons, indexed from <code>0</code> to <code>n-1</code>. Each balloon is painted with a number on it represented by array <code>nums</code>. You are asked to burst all the balloons. If the you burst balloon <code>i</code> you will get <code>nums[left] * nums[i] * nums[right]</code> coins. Here <code>left</code> and <code>right</code> are adjacent indices of <code>i</code>. After the burst, the <code>left</code> and <code>right</code> then becomes adjacent.</p><p>Find the maximum coins you can collect by bursting the balloons wisely.</p><p><strong>Note:</strong><br>(1) You may imagine <code>nums[-1] = nums[n] = 1</code>. They are not real therefore you can not burst them.<br>(2) 0 ≤ <code>n</code> ≤ 500, 0 ≤ <code>nums[i]</code> ≤ 100</p><p><strong>Example:</strong></p><p>Given <code>[3, 1, 5, 8]</code></p><p>Return <code>167</code></p><pre>    nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []   coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167</pre><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定n个气球，下标为0到n-1。每个气球上都标有一个数字，用数组nums表示。你被要求扎破所有气球。扎破第i个气球可以获得nums[left] &times; nums[i] &times; nums[right]枚硬币。这里left和right是与i相邻的下标。扎破气球以后，left和right就变成相邻的了。<br>寻找最优策略下可以获得的硬币数。</p><p>注意：<br>(1) 你可以假设nums[-1] = nums[n] = 1. 它们并非真实的因此不能扎破。<br>(2) 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><ol><li>此题遍历所有可能性，所以考虑用DP  </li><li>因为一个参数不足以描述问题，因为并不能固定nums左端或右端，所以考虑二元DP，左右边界为参数。DP流程一：定义函数f(i,j)为nums[i..j]之间的最大硬币数。  </li><li>下一步写递归式，由于这是二元DP，参考Floyd和矩阵链乘法算法，一遍要定义一个k，二分法得到两个子问题的解f(i,k)和f(k,j)，求解它们的关系是难点。先写几个例子培养下思路：<br> 2,3,4<br> f([2,4])=2&times;3&times;4同时消去了3变成[2,4],再写一个<br> 2,3,4,5,6,7,8<br> k=5, 数组变成[2,5,8]所以我们定义中忽略了一个重要事实，修改为f(i,j)为nums[i..j]之间的最大硬币数<strong>及其它们之间的元素已经消去。</strong><br> 这样的话，关系就很明朗了，只要消去5就可以得到f([2,8])，k的定义要可以清晰了：最后一个消去的元素。<br> <strong>f(i,j)=max{f(i,m)+ nums[i]&times;nums[m]&times;nums[j] +f(m,j)}, i&lt;m&lt;j，m为整数</strong>  </li><li>我们还要试试nums为单元素和双元素情况下是否适用。比如单元素5，根据题目意思首先前后补1<br>1,5,1 -&gt; f(1,5)+1&times;5&times;1+f(5,1)=5这是正确的因为f(x,y)默认为0.<br>1,5,3,1, k=5, f(1,5)+1&times;5&times;1+f(5,1)=0+5+(5&times;3&times;1)=20 | k=3, f(1,3)+1&times;3&times;1+f(3,1)=(1&times;5&times;3)+3+0=18.所以也是正确，且f(x,y)默认为0没问题。  </li><li>遍历顺序。一开始我用i,j,m三重循环，但结果不对。主要因为这个计算过程与演算过程不一致，我们刚才的演算过程是先计算所有i和j之间的值。例如，<br>1,                      5,                               3,          1<br>i &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                   j<br>i &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       j<br>&nbsp;&nbsp;&nbsp;&nbsp;i &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       j<br>在第二次循环的时候f(i,j)已经计算出来很显然是不对的。</li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>二元DP+二分法。 二元DP中k的引入参考Floyd。  </li><li>原数组前后补1，这样巧妙地让递归式适用于一个元素的情况，避免特别处理。  </li><li>便利顺序也类似于Floyd，先k(步长且至少为2)，再遍历矩阵i和j。<strong>特别注意i&lt;n-k</strong>而不是i&lt;n  </li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = nums.length+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span>[] coins = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">coins[i+<span class="number">1</span>]=nums[i];</span><br><span class="line">coins[<span class="number">0</span>] = coins[n-<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>;k&lt;n;k++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n - k;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j = i+k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> m=i+<span class="number">1</span>;m&lt;j;m++)</span><br><span class="line">dp[i][j] = Math.max(dp[i][j], dp[i][m]+coins[i]*coins[m]*coins[j] + dp[m][j]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>三重循环，时间复杂度为<code>O(n<sup>3</sup>)</code>，空间复杂度<code>O(n<sup>2</sup>)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/burst-balloons&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 312 Burst Balloons&lt;/a&gt;&lt;/strong&gt;&lt;/p
      
    
    </summary>
    
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
      <category term="Divide and Conquer" scheme="https://shineboy2013.github.com/tags/Divide-and-Conquer/"/>
    
  </entry>
  
  <entry>
    <title>DFS</title>
    <link href="https://shineboy2013.github.com/2017/12/24/dfs/"/>
    <id>https://shineboy2013.github.com/2017/12/24/dfs/</id>
    <published>2017-12-25T04:52:56.090Z</published>
    <updated>2018-01-10T07:34:02.866Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>图用邻接表为输入，思路递归实现, 还要一个机制记录节点访问过没有，可以用HashSet，同时它作为结果存储BFS访问结果。<br><strong>BFS多用于找最短路径</strong><br><strong>DFS多用于快速发现底部节点和路劲问题（如路径和）。</strong></p><p>BFS优缺点：<br>同一层的所有节点都会加入队列，所以耗用大量空间<br>仅能非递归实现<br>相比DFS较快，空间换时间<br>适合广度大的图</p><p>DFS优缺点：<br>无论是系统栈还是用户栈保存的节点数都只是树的深度，所以空间耗用小<br>有递归和非递归实现<br>由于有大量栈操作（特别是递归实现时候的系统调用），执行速度较BFS慢<br>适合深度大的图</p><h3 id="算法步骤："><a href="#算法步骤：" class="headerlink" title="算法步骤："></a><strong>算法步骤：</strong></h3><ol><li>不合法情况（已访问、越界、trivial情况等）返回。</li><li>标记为已访问。</li><li>递归访问相邻节点。</li><li>DFS路径尽量记录在数组中而非ArrayList中，路径(图)再DFS后要恢复为原状态L332。</li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * graph: 邻接表</span></span><br><span class="line"><span class="comment"> * visited: 记录已访问节点，避免重复访问</span></span><br><span class="line"><span class="comment"> * start: DFS的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(HashMap&lt;Integer, LinkedList&lt;Integer&gt;&gt; graph, HashSet&lt;Integer&gt; visited, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(visited.contains(start))&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">visited.add(start);</span><br><span class="line">System.out.print(start+<span class="string">","</span>);</span><br><span class="line"><span class="keyword">for</span>(Integer child : graph.get(start))&#123;</span><br><span class="line">dfs(graph, visited, child);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，h为树的高度，空间复杂度<code>O(h)</code>，如果用系统栈，可理解其为O(1)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;图用邻接表为输入，思路递归实现, 还要一个机制记录节点访问过没有，可以用HashS
      
    
    </summary>
    
    
      <category term="Knowledge Base" scheme="https://shineboy2013.github.com/tags/Knowledge-Base/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 123 Best Time to Buy and Sell Stock III</title>
    <link href="https://shineboy2013.github.com/2017/12/24/lee-123/"/>
    <id>https://shineboy2013.github.com/2017/12/24/lee-123/</id>
    <published>2017-12-24T23:08:14.538Z</published>
    <updated>2017-12-31T06:27:35.429Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii" target="_blank" rel="noopener">LeetCode 123 Best Time to Buy and Sell Stock III</a></strong></p><p>Say you have an array for which the <em>i</em><sup>th</sup> element is the price of a given stock on day <em>i</em>.</p><p>Design an algorithm to find the maximum profit. You may complete at most <em>two</em> transactions.</p><p><strong>Note:</strong><br>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>假设你有一个数组，它的第i个元素是一支给定的股票在第i天的价格。设计一个算法来找到最大的利润。你最多可以完成两笔交易。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>回顾一下前两题：只能进行一次交易和可以无数次交易。分别是用(min, p),sum(prices[i]-prices[-1])的方法。这题很明显比较接近只能进行一次交易的题。<br>如果考虑将此问题分为两个子问题(Divide &amp; Conquer,二分法)，prices[0,k]和prices[k,n-1]，只要将k取遍所有值就得到解。</p><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> p = maxProfitSingle(Arrays.copyOfRange(prices,<span class="number">0</span>, i+<span class="number">1</span>))</span><br><span class="line">+ maxProfitSingle(Arrays.copyOfRange(prices,i, prices.length));</span><br><span class="line"><span class="keyword">if</span>(max&lt;p)</span><br><span class="line">max = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(<em>n</em><sup>2</sup>)</code>，空间复杂度<code>O(1)</code>。</p><p>上述解法并非最优，因为计算prices[0,k-1]到prices[0,k]时候再次重复计算用了O(n)，但由只能进行一次交易题解中知道，其实O(1)可得，只要在计算过程中把结果存入left数组中即可。<br>下面的难点在于计算prices[k,n-1]。右端点固定，从右到左计算，所以其实是只能进行一次交易题解的逆运算并把结果存入到right数组。区别是(max, p)。最后只要遍历left[k]+right[k],即可得到最大利润。</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>数组长度为0。</li><li>二分法</li><li>用数组存储重复计算结果(DP)</li></ol><h3 id="Java代码：-1"><a href="#Java代码：-1" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(prices.length==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//前i天最大利润，并非需要第i天卖出</span></span><br><span class="line"><span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line"><span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> min = prices[<span class="number">0</span>], maxPL = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> p = prices[i] - min;</span><br><span class="line"><span class="keyword">if</span>(maxPL&lt;p)</span><br><span class="line">maxPL = p;</span><br><span class="line">left[i] = maxPL;</span><br><span class="line"><span class="keyword">if</span>(min&gt;prices[i])</span><br><span class="line">min=prices[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> max=prices[prices.length-<span class="number">1</span>],maxPR=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=prices.length-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line"><span class="keyword">int</span> p=max-prices[j];</span><br><span class="line"><span class="keyword">if</span>(maxPR&lt;p)</span><br><span class="line">maxPR = p;</span><br><span class="line">right[j] = maxPR;</span><br><span class="line"><span class="keyword">if</span>(max&lt;prices[j])</span><br><span class="line">max=prices[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> maxP = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;prices.length;k++)&#123;</span><br><span class="line"><span class="keyword">if</span>(maxP&lt;left[k]+right[k])</span><br><span class="line">maxP = left[k]+right[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，空间复杂度<code>O(n)</code>。</p><h3 id="相关题目："><a href="#相关题目：" class="headerlink" title="相关题目："></a><strong>相关题目：</strong></h3><p><a href="https://shineboy2013.github.io/2017/11/27/lee-121/" target="_blank" rel="noopener">LeetCode 121 Best Time to Buy and Sell Stock</a><br><a href="https://shineboy2013.github.io/2017/11/28/lee-122/" target="_blank" rel="noopener">LeetCode 122 Best Time to Buy and Sell Stock II</a><br><a href="https://shineboy2013.github.io/2017/12/11/lee-309/" target="_blank" rel="noopener">LeetCode 309 Best Time to Buy and Sell Stock with Cooldown</a><br><a href="https://shineboy2013.github.io/2017/12/24/lee-123/" target="_blank" rel="noopener">LeetCode 123 Best Time to Buy and Sell Stock III</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 123 Best Time
      
    
    </summary>
    
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>Union Find</title>
    <link href="https://shineboy2013.github.com/2017/12/24/union-find/"/>
    <id>https://shineboy2013.github.com/2017/12/24/union-find/</id>
    <published>2017-12-24T18:51:12.340Z</published>
    <updated>2017-12-25T01:25:07.662Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>DFS用于需要知道具体路径的问题，而并查集方法用于不需知道具体路径只关心连通性的问题。<br>此算法把同一个连通集归结为同一个根节点，作为判断是否一个连通集的标识。它用深度为2的扁平树组织起来。这是查找操作。<br>另一个关键操作是联合两个不同连通集，就是直接把根节点直接作为另一课树的子节点。在这个过程中，新的树深度可能会大于2，但当要union路径大于2的节点是，会对其进行路径压缩。<br>最巧妙的操作当属find操作，将路径进行压缩，变成长度为1的路径，见步骤4。<br>可能有人会考虑用HashMap而不是树，HashMap查找也是很高效，但联合操作比较费时，因为要更新另一个树的所有节点的根节点。</p><h3 id="算法步骤："><a href="#算法步骤：" class="headerlink" title="算法步骤："></a><strong>算法步骤：</strong></h3><ol><li>初始化UnionFind类，包括3个属性：count（独立连通数）, parent（某节点的父节点）, rank（连通集排名）。合格的节点的parent初始化为自己的id，rank为0，count为所有合格节点数量。</li><li>遍历所有节点，<strong>union</strong>此节点及其相邻的节点（如上下左右）</li><li>union时候，先<strong>find</strong>两节点的根节点，若相同忽略。若不同，合并此两连通集：rank大的连通集，作为rank小的连通集的父节点。若rank相等，选任一作为另一个的父节点且把它的rank加1。count减1。<br>如下图，union 6和11的，find(6)会进行压缩路径，把6接到5下。<br><img src="/images/union-find-2.png" alt=""></li><li>find寻找根节点的同时，压缩成与根节点路径为1的连通。<br><img src="/images/union-find.png" alt=""></li></ol><p>例子矩阵：<br>{‘0’,’1’,’1’,’0’,’0’}<br>{‘1’,’1’,’1’,’0’,’0’}</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><p>find要注意压缩路径parent[i] = find(parent[i])</p><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count; <span class="comment">// # of connected components</span></span><br><span class="line"><span class="keyword">int</span>[] parent;</span><br><span class="line"><span class="keyword">int</span>[] rank;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123; <span class="comment">// for problem 200</span></span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> m = grid.length;</span><br><span class="line"><span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">parent = <span class="keyword">new</span> <span class="keyword">int</span>[m * n];</span><br><span class="line">rank = <span class="keyword">new</span> <span class="keyword">int</span>[m * n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">parent[i * n + j] = i * n + j;</span><br><span class="line">++count;</span><br><span class="line">&#125;</span><br><span class="line">rank[i * n + j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (parent[i] != i) &#123;</span><br><span class="line">parent[i] = find(parent[i]); <span class="comment">// path compression</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> parent[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// union with rank</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> rootx = find(x);</span><br><span class="line"><span class="keyword">int</span> rooty = find(y);</span><br><span class="line"><span class="keyword">if</span> (rootx != rooty) &#123;</span><br><span class="line"><span class="keyword">if</span> (rank[rootx] &gt; rank[rooty]) &#123;</span><br><span class="line">parent[rooty] = rootx;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootx] &lt; rank[rooty]) &#123;</span><br><span class="line">parent[rootx] = rooty;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">parent[rooty] = rootx;</span><br><span class="line">rank[rootx] += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">--count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands3</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nr = grid.length;</span><br><span class="line"><span class="keyword">int</span> nc = grid[<span class="number">0</span>].length;</span><br><span class="line"><span class="keyword">int</span> num_islands = <span class="number">0</span>;</span><br><span class="line">UnionFind uf = <span class="keyword">new</span> UnionFind(grid);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; nr; ++r) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; nc; ++c) &#123;</span><br><span class="line"><span class="keyword">if</span> (grid[r][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">grid[r][c] = <span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">if</span> (r - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r - <span class="number">1</span>][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">uf.union(r * nc + c, (r - <span class="number">1</span>) * nc + c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (r + <span class="number">1</span> &lt; nr &amp;&amp; grid[r + <span class="number">1</span>][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">uf.union(r * nc + c, (r + <span class="number">1</span>) * nc + c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (c - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r][c - <span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">uf.union(r * nc + c, r * nc + c - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (c + <span class="number">1</span> &lt; nc &amp;&amp; grid[r][c + <span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">uf.union(r * nc + c, r * nc + c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> uf.getCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(MN)</code>，空间复杂度<code>O(MN)</code>。M,N分别为矩阵长宽。遍历每个节点，而每个节点只会遍历4个相邻节点。</p><h3 id="Ref："><a href="#Ref：" class="headerlink" title="Ref："></a><strong>Ref：</strong></h3><p><a href="http://blog.csdn.net/dm_vincent/article/details/7655764" target="_blank" rel="noopener">并查集(Union-Find)算法介绍</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;DFS用于需要知道具体路径的问题，而并查集方法用于不需知道具体路径只关心连通性的问
      
    
    </summary>
    
    
      <category term="Knowledge Base" scheme="https://shineboy2013.github.com/tags/Knowledge-Base/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 200 Number of Islands</title>
    <link href="https://shineboy2013.github.com/2017/12/23/lee-200/"/>
    <id>https://shineboy2013.github.com/2017/12/23/lee-200/</id>
    <published>2017-12-23T09:21:37.107Z</published>
    <updated>2017-12-31T06:27:55.061Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/number-of-islands" target="_blank" rel="noopener">LeetCode 200 Number of Islands</a></strong></p><p>Given a 2d grid map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. </p><p><strong><em>Example 1:</em></strong></p><pre><code>11110110101100000000</code></pre><p>Answer: 1</p><p><strong><em>Example 2:</em></strong></p><pre><code>11000110000010000011</code></pre><p>Answer: 3</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个由字符‘1’（陆地）和‘0’（水域）组成的二维网格地图，计算岛屿的个数。岛屿被水域环绕，由竖直或者水平方向邻接的陆地构成。你可以假设网格地图的四条边都被水域包围。</p><h3 id="DFS解题思路："><a href="#DFS解题思路：" class="headerlink" title="DFS解题思路："></a><strong>DFS解题思路：</strong></h3><p>遍历矩阵的每一个元素，对每个元素进行DFS四个方位搜索陆地，访问过的元素在原数组中进行标记。每次DFS搜索后，层数加1。</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>注意到题目给定输入数组的类型，用其来标记已访问的单元（节点）。</li><li>BFS入列后立即标记为已访问，否则会有空间和时间问题。</li><li>BFS和Union Find都可以二维变成一维，不但节省空间，还可以避免创建Point的新class。</li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> layer = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;grid.length;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].length;j++)</span><br><span class="line"><span class="keyword">if</span>(grid[i][j]==<span class="string">'1'</span>)&#123;</span><br><span class="line">dfs(grid,i,j);</span><br><span class="line">layer++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> layer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!isValid(grid,a,b))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">grid[a][b] = <span class="string">'x'</span>;</span><br><span class="line">dfs(grid, a+<span class="number">1</span>, b);</span><br><span class="line">dfs(grid, a-<span class="number">1</span>, b);</span><br><span class="line">dfs(grid, a, b+<span class="number">1</span>);</span><br><span class="line">dfs(grid, a, b-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;<span class="number">0</span>||x&gt;=grid.length||y&lt;<span class="number">0</span>||y&gt;=grid[<span class="number">0</span>].length||grid[x][y]!=<span class="string">'1'</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(MN)</code>，空间复杂度<code>O(MN)</code>。M,N分别为矩阵长宽。最坏情况，全为陆地，DFS退化成线性。</p><h3 id="BFS解题思路："><a href="#BFS解题思路：" class="headerlink" title="BFS解题思路："></a><strong>BFS解题思路：</strong></h3><p>遍历矩阵的每一个元素，对每个元素进行DFS四个方位搜索陆地，访问过的元素在原数组中进行标记。每次DFS搜索后，层数加1。<br>BFS入列后立即标记为已访问，否则会有空间和时间问题。<br>二维变成一维，不但节省空间，还可以避免创建Point的新class。a = x * C + y(C为列数) &lt;=&gt; x = a/C, y = a%C</p><h3 id="Java代码：-1"><a href="#Java代码：-1" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> layer = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;grid.length;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].length;j++)</span><br><span class="line"><span class="keyword">if</span>(grid[i][j]==<span class="string">'1'</span>)&#123;</span><br><span class="line">bfs(grid,i,j);</span><br><span class="line">layer++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> layer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">Queue q = <span class="keyword">new</span> LinkedList();</span><br><span class="line">q.offer(a*grid[<span class="number">0</span>].length+b);</span><br><span class="line">grid[a][b]=<span class="string">'x'</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line"><span class="keyword">int</span> parent=(<span class="keyword">int</span>) q.poll();</span><br><span class="line"><span class="keyword">int</span> x = parent/grid[<span class="number">0</span>].length, y = parent%grid[<span class="number">0</span>].length;</span><br><span class="line"><span class="keyword">if</span>(isValid(grid, x-<span class="number">1</span>, y))&#123;</span><br><span class="line">q.offer((x-<span class="number">1</span>)*grid[<span class="number">0</span>].length+y);</span><br><span class="line">grid[x-<span class="number">1</span>][y]=<span class="string">'x'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isValid(grid, x+<span class="number">1</span>, y))&#123;</span><br><span class="line">q.offer((x+<span class="number">1</span>)*grid[<span class="number">0</span>].length + y);</span><br><span class="line">grid[x+<span class="number">1</span>][y]=<span class="string">'x'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isValid(grid, x, y+<span class="number">1</span>))&#123;</span><br><span class="line">q.offer(x*grid[<span class="number">0</span>].length + y+<span class="number">1</span>);</span><br><span class="line">grid[x][y+<span class="number">1</span>]=<span class="string">'x'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isValid(grid, x, y-<span class="number">1</span>))&#123;</span><br><span class="line">q.offer(x*grid[<span class="number">0</span>].length + y-<span class="number">1</span>);</span><br><span class="line">grid[x][y-<span class="number">1</span>]=<span class="string">'x'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(MN)</code>，空间复杂度<code>O(min{M,N})</code>。M,N分别为矩阵长宽。因为最坏情况下，以矩形中心为root，最大的一层为矩形里面的最大正方形，它的长度为min{M,N}。<br><img src="/images/L200.png" alt=""></p><h3 id="Union-Find解题思路："><a href="#Union-Find解题思路：" class="headerlink" title="Union Find解题思路："></a><strong>Union Find解题思路：</strong></h3><p>见Union Find算法详解。</p><ol><li>初始化UnionFind类，包括3个属性：count（独立连通数）, parent（某节点的父节点）, rank（连通集排名）。合格的节点的parent初始化为自己的id，rank为0，count为所有合格节点数量。</li><li>遍历所有节点，<strong>union</strong>此节点及其相邻的节点（如上下左右）</li><li>union时候，先<strong>find</strong>两节点的根节点，若相同忽略。若不同，合并此两连通集：rank大的连通集，作为rank小的连通集的父节点。若rank相等，选任一作为另一个的父节点且把它的rank加1。count减1。<br>如下图，union 6和11的，find(6)会进行压缩路径，把6接到5下。<br><img src="/images/union-find-2.png" alt=""></li><li>find寻找根节点的同时，压缩成与根节点路径为1的连通。  </li></ol><h3 id="Java代码：-2"><a href="#Java代码：-2" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count; <span class="comment">// # of connected components</span></span><br><span class="line"><span class="keyword">int</span>[] parent;</span><br><span class="line"><span class="keyword">int</span>[] rank;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123; <span class="comment">// for problem 200</span></span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> m = grid.length;</span><br><span class="line"><span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">parent = <span class="keyword">new</span> <span class="keyword">int</span>[m * n];</span><br><span class="line">rank = <span class="keyword">new</span> <span class="keyword">int</span>[m * n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">parent[i * n + j] = i * n + j;</span><br><span class="line">++count;</span><br><span class="line">&#125;</span><br><span class="line">rank[i * n + j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (parent[i] != i) &#123;</span><br><span class="line">parent[i] = find(parent[i]); <span class="comment">// path compression</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> parent[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// union with rank</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> rootx = find(x);</span><br><span class="line"><span class="keyword">int</span> rooty = find(y);</span><br><span class="line"><span class="keyword">if</span> (rootx != rooty) &#123;</span><br><span class="line"><span class="keyword">if</span> (rank[rootx] &gt; rank[rooty]) &#123;</span><br><span class="line">parent[rooty] = rootx;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootx] &lt; rank[rooty]) &#123;</span><br><span class="line">parent[rootx] = rooty;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">parent[rooty] = rootx;</span><br><span class="line">rank[rootx] += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">--count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands3</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nr = grid.length;</span><br><span class="line"><span class="keyword">int</span> nc = grid[<span class="number">0</span>].length;</span><br><span class="line"><span class="keyword">int</span> num_islands = <span class="number">0</span>;</span><br><span class="line">UnionFind uf = <span class="keyword">new</span> UnionFind(grid);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; nr; ++r) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; nc; ++c) &#123;</span><br><span class="line"><span class="keyword">if</span> (grid[r][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">grid[r][c] = <span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">if</span> (r - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r - <span class="number">1</span>][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">uf.union(r * nc + c, (r - <span class="number">1</span>) * nc + c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (r + <span class="number">1</span> &lt; nr &amp;&amp; grid[r + <span class="number">1</span>][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">uf.union(r * nc + c, (r + <span class="number">1</span>) * nc + c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (c - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r][c - <span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">uf.union(r * nc + c, r * nc + c - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (c + <span class="number">1</span> &lt; nc &amp;&amp; grid[r][c + <span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">uf.union(r * nc + c, r * nc + c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> uf.getCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析：-2"><a href="#算法分析：-2" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(MN)</code>，空间复杂度<code>O(MN)</code>。M,N分别为矩阵长宽。遍历每个节点，而每个节点只会遍历4个相邻节点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/number-of-islands&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 200 Number of Islands&lt;/a&gt;&lt;/stro
      
    
    </summary>
    
    
      <category term="Depth-first Search" scheme="https://shineboy2013.github.com/tags/Depth-first-Search/"/>
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
      <category term="Breadth-first Search" scheme="https://shineboy2013.github.com/tags/Breadth-first-Search/"/>
    
      <category term="Union Find" scheme="https://shineboy2013.github.com/tags/Union-Find/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 124 Binary Tree Maximum Path Sum</title>
    <link href="https://shineboy2013.github.com/2017/12/13/lee-124/"/>
    <id>https://shineboy2013.github.com/2017/12/13/lee-124/</id>
    <published>2017-12-14T06:36:59.879Z</published>
    <updated>2017-12-31T23:06:21.005Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum" target="_blank" rel="noopener">LeetCode 124 Binary Tree Maximum Path Sum</a></strong></p><p>Given a binary tree, find the maximum path sum.</p><p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain <strong>at least one node</strong> and does not need to go through the root.</p><p>For example:<br>Given the below binary tree,</p><pre>              1      / \     2   3</pre><p>Return <code>6</code>.</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一棵二叉树，寻找最大路径和。路径指的是从任意起始节点出发沿着父亲-孩子链接到达某个终止节点的节点序列。路径不一定要穿过根节点。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>DFS搜索，二叉树的题。步骤主要是考虑</p><ol><li>空指针</li><li>一个node情况或多个node情况（可合并）<br>多个node情况下（比如3个节点），有4种情况下含根节点的和：左子树+根节点，右子树+跟节点，根节点，左子树+根节点+右子树。这些情况包含了所有可能的和的情况。但值得注意的是，前三种<br>情况可以是子问题的解，也就是它返回值将成为此根节点父亲的左或右子树的解，但第四种情况例外，因为此情况形成的路径与根节点父亲并不在一条路径上。所以此情况应在全局变量中比较<br>并不能作为返回值。<br>gmax = max {return max{val,left+val,right+val}  or left+val+right}</li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>4种情况</li><li>定义全局变量来比较最大值，因为左到右情况不能返回。全局变量初始值为负无穷。</li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> gsum = Integer.MIN_VALUE;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">gsum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a = max(root);</span><br><span class="line"><span class="keyword">return</span> gsum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> lmax = max(root.left);</span><br><span class="line"><span class="keyword">int</span> rmax = max(root.right);</span><br><span class="line"><span class="keyword">int</span> sum = Math.max(Math.max(lmax, rmax)+root.val,root.val);</span><br><span class="line">gsum = Math.max(Math.max(gsum, sum), lmax+root.val+rmax);</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>两种方法时间复杂度为<code>O(n)</code>，n为节点数。空间复杂度为<code>O(h)</code>，h为二叉树高度。</p><h3 id="相关题目："><a href="#相关题目：" class="headerlink" title="相关题目："></a><strong>相关题目：</strong></h3><p>LeetCode 112 Path Sum<br>LeetCode 124 Binary Tree Maximum Path Sum</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/binary-tree-maximum-path-sum&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 124 Binary Tree Maxi
      
    
    </summary>
    
    
      <category term="Tree" scheme="https://shineboy2013.github.com/tags/Tree/"/>
    
      <category term="Depth-first Search" scheme="https://shineboy2013.github.com/tags/Depth-first-Search/"/>
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 112 Path Sum</title>
    <link href="https://shineboy2013.github.com/2017/12/13/lee-112/"/>
    <id>https://shineboy2013.github.com/2017/12/13/lee-112/</id>
    <published>2017-12-14T06:08:39.112Z</published>
    <updated>2017-12-31T06:27:08.853Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/path-sum/" target="_blank" rel="noopener">LeetCode 112 Path Sum</a></strong></p><p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p><p>For example:<br>Given the below binary tree and <code>sum = 22</code>,</p><pre>                            5             / \            4   8           /   / \          11  13  4         /  \      \        7    2      1</pre><p>return true, as there exist a root-to-leaf path <code>5-&gt;4-&gt;11-&gt;2</code> which sum is 22.</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个二叉树root和一个和sum，决定这个树是否存在一条从根到叶子的路径使得沿路所有节点的和等于给定的sum。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>DFS搜索，二叉树的题。步骤主要是考虑</p><ol><li>空指针</li><li>一个node情况或多个node情况（可合并）</li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>叶子节点是不含左儿子和右儿子</li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span>(root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span> &amp;&amp; root.val==sum)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">return</span> hasPathSum(root.left, sum-root.val) || hasPathSum(root.right, sum-root.val);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>两种方法时间复杂度为<code>O(n)</code>，n为节点数。空间复杂度为<code>O(h)</code>，h为二叉树高度。</p><h3 id="相关题目："><a href="#相关题目：" class="headerlink" title="相关题目："></a><strong>相关题目：</strong></h3><p>LeetCode 112 Path Sum<br>LeetCode 124 Binary Tree Maximum Path Sum</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/path-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 112 Path Sum&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Given 
      
    
    </summary>
    
    
      <category term="Tree" scheme="https://shineboy2013.github.com/tags/Tree/"/>
    
      <category term="Depth-first Search" scheme="https://shineboy2013.github.com/tags/Depth-first-Search/"/>
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 309 Best Time to Buy and Sell Stock with Cooldown</title>
    <link href="https://shineboy2013.github.com/2017/12/11/lee-309/"/>
    <id>https://shineboy2013.github.com/2017/12/11/lee-309/</id>
    <published>2017-12-12T04:24:30.810Z</published>
    <updated>2018-01-03T05:28:27.018Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">LeetCode 309 Best Time to Buy and Sell Stock with Cooldown</a></strong></p><p>Say you have an array for which the <em>i</em><sup>th</sup> element is the price of a given stock on day <em>i</em>.</p><p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:</p><ul><li>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</li><li>After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)</li></ul><p><strong>Example:</strong>  </p><pre>prices = [1, 2, 3, 0, 2]maxProfit = 3transactions = [buy, sell, cooldown, buy, sell]</pre><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定一个数组，第i个元素代表某只股票在第i天的价格。 设计一个算法计算最大收益。你可以完成多次交易（多次买入、卖出同一只股票），需要满足下列限制：<br>你不可以在同一时间参与多个交易（在买入股票之前必须卖出）。<br>在卖出股票之后，你不可以在第二天马上买入。（需要一天的冷却（CD）时间）。<strong>也就是卖出后过两天才能买入。</strong></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>因为有限制条件，所以没有特别方法，只能计算所有结果，也就是用动态规划。动态规划首先是写出递归式（数学归纳法）。</p><ol><li>定义f(n)为第n日卖出股票（一定要卖出，不能持有）的利润，加强了命题。</li><li>递归式如下图，f(n)只能由f(n-1)卖出后立刻买入（相当于n-1时候不卖出）或者f(n-3)卖出n-1时候买入两种情况。<br><img src="/images/L309.png" alt=""><br>现在可以写出递归式：<br><img src="/images/L309-2.png" alt=""><br>F(x)=max{f(1),…,f(n)}求加强命题最大值即为本题解。<br>这里考虑到负数，方便程序实现，否则，f(n)的前3个值计算就不能放入循环而要特别处理了。</li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>数组为空或者1个</li><li>负数组的实现方法</li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sell[] = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">sell[i] = Math.max(f(i-<span class="number">3</span>, sell), f(i-<span class="number">1</span>, sell))+ prices[i]-prices[i-<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span>(sell[i]&gt;max)</span><br><span class="line">max = sell[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span>[] r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> r[i];</span><br></pre></td></tr></table></figure><p>这个实现有个错误就是忽略了一种重要的情况：f(n-4),…,f(1)的情况。看以下例子：[6,1,6,4,3,0,2]</p><table><thead><tr><th>Index</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th></tr></thead><tbody><tr><td>price</td><td style="text-align:center">6</td><td style="text-align:center">1</td><td style="text-align:center">6</td><td style="text-align:center">4</td><td style="text-align:center">3</td><td style="text-align:center">0</td><td style="text-align:center">2</td></tr><tr><td>f(n)</td><td style="text-align:center">0</td><td style="text-align:center">-5</td><td style="text-align:center">5</td><td style="text-align:center">3</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">5</td></tr></tbody></table><p>按照上面算法结果为5，但是很容易看出来1-&gt;6, 0-&gt;2结果是7。问题出在最后一个f(6)=max{f(3),f(5)}+2=max{3,2}+2。很明显，第3天卖出获利为3并不是最佳，第二天卖出获利为5才是最佳，我们忽略了f(n-3)之前的所有情况。解决方案是再创建一个数组维护前n天最大获利值。<br>定义g(n)为第n日（包括第n日）前卖出股票（不一定要第n天卖出）的利润。修改递归式为，把f(n-3)改为g(n-3)：<br><img src="/images/L309-3.png" alt=""></p><h3 id="Java代码：-1"><a href="#Java代码：-1" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit2</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sell[] = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line"><span class="keyword">int</span> preSell[] = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">sell[i] = Math.max(g(i-<span class="number">3</span>, preSell), f(i-<span class="number">1</span>, sell))+ prices[i]-prices[i-<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span>(sell[i]&gt;max)</span><br><span class="line">max = sell[i];</span><br><span class="line"></span><br><span class="line">preSell[i] = Math.max(preSell[i-<span class="number">1</span>], sell[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span>[] r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> r[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span>[] g)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> g[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，n为数组长度，空间复杂度<code>O(n)</code>。</p><h3 id="空间优化："><a href="#空间优化：" class="headerlink" title="空间优化："></a><strong>空间优化：</strong></h3><p>由于此题目，f(n)只与前三个状态有关f(n-1), f(n-2)(虽然没直接关系，但程序实现需要记录),g(n-3)。四个状态可以用三个变量<br>推进，如sell=Math.max(preSell, sell)，同一个变量旧状态更新到新状态，所以可以避免维护数组开销。<br>代入preSell=g(n-3), sell_1=f(n-2), sell=f(n-1)到公式即得<br>f(n) = sell = max{preSell, sell}+prices[n]-prices[i-1]<br>g(n-2) = preSell = max{g(n-3), f(n-2)} = max{preSell, sell_1}<br>f(n-1) = sell_1 = PreValue(sell)<br>本题解就是preSell, sell_1, sell的最大值。</p><h3 id="Java代码：-2"><a href="#Java代码：-2" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line"><span class="comment">//g(n-3), f(n-2), f(n-1)</span></span><br><span class="line"><span class="keyword">int</span> preSell=<span class="number">0</span>, sell_1=<span class="number">0</span>, sell = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = sell;</span><br><span class="line">sell = Math.max(preSell, sell)+ prices[i]-prices[i-<span class="number">1</span>];</span><br><span class="line">preSell = Math.max(preSell, sell_1);</span><br><span class="line">sell_1 = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Math.max(Math.max(preSell, sell_1), sell);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，n为数组长度，空间复杂度<code>O(1)</code>。本题有更简单解法但比较难想出。</p><h3 id="最后注意事项："><a href="#最后注意事项：" class="headerlink" title="最后注意事项："></a><strong>最后注意事项：</strong></h3><ol><li>数组为空或者1个</li><li>三种情况f(n-1),f(n-3),g(n-3)可以得到f(n)。解就是preSell, sell_1, sell的最大值。</li><li>DP流程，定义函数（是否加强）、递归式、空间优化。</li></ol><h3 id="相关题目："><a href="#相关题目：" class="headerlink" title="相关题目："></a><strong>相关题目：</strong></h3><p><a href="https://shineboy2013.github.io/2017/11/27/lee-121/" target="_blank" rel="noopener">LeetCode 121 Best Time to Buy and Sell Stock</a><br><a href="https://shineboy2013.github.io/2017/11/28/lee-122/" target="_blank" rel="noopener">LeetCode 122 Best Time to Buy and Sell Stock II</a><br><a href="https://shineboy2013.github.io/2017/12/11/lee-309/" target="_blank" rel="noopener">LeetCode 309 Best Time to Buy and Sell Stock with Cooldown</a><br><a href="https://shineboy2013.github.io/2017/12/24/lee-123/" target="_blank" rel="noopener">LeetCode 123 Best Time to Buy and Sell Stock III</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 30
      
    
    </summary>
    
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 310 Minimum Height Trees</title>
    <link href="https://shineboy2013.github.com/2017/12/04/lee-310/"/>
    <id>https://shineboy2013.github.com/2017/12/04/lee-310/</id>
    <published>2017-12-04T08:29:11.604Z</published>
    <updated>2017-12-31T06:28:10.436Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/minimum-height-trees" target="_blank" rel="noopener">LeetCode 310 Minimum Height Trees</a></strong></p><p>For a undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels.</p><p><strong>Format</strong><br>The graph contains <code>n</code> nodes which are labeled from <code>0</code> to <code>n - 1</code>. You will be given the number <code>n</code> and a list of undirected <code>edges</code> (each edge is a pair of labels).</p><p>You can assume that no duplicate edges will appear in <code>edges</code>. Since all edges are undirected, <code>[0, 1]</code> is the same as <code>[1, 0]</code> and thus will not appear together in <code>edges</code>.</p><p><strong>Example 1:</strong></p><p>Given <code>n = 4</code>, <code>edges = [[1, 0], [1, 2], [1, 3]]</code></p><pre>        0        |        1       / \      2   3</pre><p>return <code>[1]</code></p><p><strong>Example 2:</strong></p><p>Given <code>n = 6</code>, <code>edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]</code></p><pre>     0  1  2      \ | /        3        |        4        |        5</pre><p>return <code>[3, 4]</code></p><p><strong>Note</strong>:</p><p>(1) According to the <a href="https://en.wikipedia.org/wiki/Tree_(graph_theory" target="_blank" rel="noopener">definition of tree on Wikipedia</a>): “a tree is an undirected graph in which any two vertices are connected by <em>exactly</em> one path. In other words, any connected graph without simple cycles is a tree.”</p><p>(2) The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>对于一棵无向树，我们可以选择它的任意节点作为根。得到的结果就是有根树。在所有可能的有根树中，高度最小的称为最小高度树（MHT）。<br>给定一个无向图，编写函数找出所有的最小高度树，并返回其根标号的列表。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>此题本质上求最长路径上的中间1-2个节点。由于根节点不确定，从叶节点出发，层层剥离，这就是拓扑排序(inDegree数组)。而且需要知道最后一层的1-2个节点，所以考虑用按层遍历BFS（两数组）。见KB。</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>由于最后一层可能是1-2个节点，所以要用一个变量把最后一层记录下来。</li><li>还有一点要注意的是这是无向图，所以入度=1而不是0时候即入队列。</li></ol><p>Topological:</p><ol><li>根据边统计每个节点的入度数记入in[i]</li><li>找出度数为0的节点加入到Queue</li><li>取出队首节点，把此节点邻接的节点度数减1，如果度数为0，加入到队列，循环直到队列为空</li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findMinHeightTrees</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span> &amp;&amp; edges.length==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(<span class="keyword">new</span> Integer[]&#123;<span class="number">0</span>&#125;));</span><br><span class="line">&#125;</span><br><span class="line">ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line"><span class="keyword">int</span> num = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">graph.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line"><span class="keyword">int</span>[] inDegree = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="comment">//populate inDegree &amp; convert to graph</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edges.length;i++)&#123;</span><br><span class="line">inDegree[edges[i][<span class="number">0</span>]]++;</span><br><span class="line">inDegree[edges[i][<span class="number">1</span>]]++;</span><br><span class="line">graph.get(edges[i][<span class="number">1</span>]).add(edges[i][<span class="number">0</span>]);</span><br><span class="line">graph.get(edges[i][<span class="number">0</span>]).add(edges[i][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">Queue&lt;Integer&gt; q2 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inDegree.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(inDegree[i]==<span class="number">1</span>)</span><br><span class="line">q.offer(i);</span><br><span class="line">&#125;</span><br><span class="line">Queue&lt;Integer&gt; lastLayerQ = <span class="keyword">new</span> LinkedList&lt;Integer&gt;(q);</span><br><span class="line"><span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">Integer v = q.poll();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> neighbor : graph.get(v))&#123;</span><br><span class="line"><span class="keyword">if</span>(--inDegree[neighbor]==<span class="number">1</span>)</span><br><span class="line">q2.offer(neighbor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(q.isEmpty() &amp;&amp; !q2.isEmpty())&#123;</span><br><span class="line">q = q2;</span><br><span class="line">q2 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">lastLayerQ = <span class="keyword">new</span> LinkedList&lt;Integer&gt;(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (List)lastLayerQ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，w为树的所有层里面的最大长度，空间复杂度<code>O(w)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/minimum-height-trees&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 310 Minimum Height Trees&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
      <category term="Breadth-first Search" scheme="https://shineboy2013.github.com/tags/Breadth-first-Search/"/>
    
      <category term="Graph" scheme="https://shineboy2013.github.com/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>拓扑排序</title>
    <link href="https://shineboy2013.github.com/2017/12/03/topological/"/>
    <id>https://shineboy2013.github.com/2017/12/03/topological/</id>
    <published>2017-12-04T07:23:54.692Z</published>
    <updated>2017-12-24T07:58:55.742Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>对于拓扑排序来说， 我们的中心思想是要我们可以找到一个顺序，每一次我们可以进行的工序是现在没有先序依赖的工序，<br>按照这个顺序可以流畅的完成我们的任务。<br>思路基于BFS的队列实现。区别在于统计每个节点的入度数。此法也可用于无向图。</p><ol><li>根据边统计每个节点的入度数记入in[i]</li><li>找出度数为0的节点加入到Queue</li><li>取出队首节点，把此节点邻接的节点度数减1，如果度数为0，加入到队列，循环直到队列为空</li><li>如果队列为空但仍有节点度数不为0，存在循环，否则不存在</li></ol><h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a><strong>应用：</strong></h3><ol><li>求最长或最短路径</li><li>判断循环</li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * graph: 邻接表</span></span><br><span class="line"><span class="comment"> * num: 节点个数 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topologicalSort</span><span class="params">(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] inDegree = <span class="keyword">new</span> <span class="keyword">int</span>[num];</span><br><span class="line"><span class="comment">//populate inDegree</span></span><br><span class="line"><span class="keyword">for</span>(ArrayList&lt;Integer&gt; adjacencyList : graph)&#123;</span><br><span class="line"><span class="keyword">for</span>(Integer node : adjacencyList)&#123;</span><br><span class="line">inDegree[node]++;</span><br><span class="line">&#125;       </span><br><span class="line">&#125;</span><br><span class="line">Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inDegree.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(inDegree[i]==<span class="number">0</span>)</span><br><span class="line">q.offer(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">Integer v = q.poll();</span><br><span class="line">System.out.print(v + <span class="string">"-&gt;"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> neighbor : graph.get(v))&#123;</span><br><span class="line"><span class="keyword">if</span>(--inDegree[neighbor]==<span class="number">0</span>)</span><br><span class="line">q.offer(neighbor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* check isCyclic  or not</span></span><br><span class="line"><span class="comment">for(int i=0;i&lt;inDegree.length;i++)&#123;</span></span><br><span class="line"><span class="comment">if(inDegree[i]&gt;0)</span></span><br><span class="line"><span class="comment">return false;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">return true;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，w为树的所有层里面的最大长度，空间复杂度<code>O(w)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;对于拓扑排序来说， 我们的中心思想是要我们可以找到一个顺序，每一次我们可以进行的工
      
    
    </summary>
    
    
      <category term="Knowledge Base" scheme="https://shineboy2013.github.com/tags/Knowledge-Base/"/>
    
  </entry>
  
  <entry>
    <title>BFS</title>
    <link href="https://shineboy2013.github.com/2017/12/03/bfs/"/>
    <id>https://shineboy2013.github.com/2017/12/03/bfs/</id>
    <published>2017-12-04T06:20:41.008Z</published>
    <updated>2017-12-28T17:57:04.638Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a><strong>算法思路：</strong></h3><p>图用邻接表为输入，思路用Queue实现, 还要一个机制记录节点访问过没有，可以用HashSet，同时它作为结果存储BFS访问结果。<br><strong>BFS多用于找最短路径</strong><br><strong>DFS多用于快速发现底部节点和路劲问题（如路径和）。</strong></p><p>BFS优缺点：<br>同一层的所有节点都会加入队列，所以耗用大量空间<br>仅能非递归实现<br>相比DFS较快，空间换时间<br>适合广度大的图</p><p>DFS优缺点：<br>无论是系统栈还是用户栈保存的节点数都只是树的深度，所以空间耗用小<br>有递归和非递归实现<br>由于有大量栈操作（特别是递归实现时候的系统调用），执行速度较BFS慢<br>适合深度大的图</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>只要把节点放入队列立即标记其为访问，不要在出列的时候才标记。否则同一个节点会入列多次。<br>比如下图, 入列顺序为1,2,4,3,3。3入列了两次。<br><img src="/images/bfs.png" alt=""></li><li>q.isEmpty() &amp;&amp; !q2.isEmpty()</li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * graph: 邻接表</span></span><br><span class="line"><span class="comment"> * visited: 记录已访问节点，避免重复访问</span></span><br><span class="line"><span class="comment"> * start: BFS的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(HashMap&lt;Integer, LinkedList&lt;Integer&gt;&gt; graph, HashSet&lt;Integer&gt; visited, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">Queue&lt;Integer&gt; q=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">q.offer(start);</span><br><span class="line">visited.add(start);</span><br><span class="line"><span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line"><span class="keyword">int</span> node = q.poll();</span><br><span class="line">LinkedList&lt;Integer&gt; children = graph.get(node);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> child : children)&#123;</span><br><span class="line"><span class="keyword">if</span> (!visited.contains(child))&#123;</span><br><span class="line">q.offer(child);</span><br><span class="line">visited.add(child);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="错误算法："><a href="#错误算法：" class="headerlink" title="错误算法："></a><strong>错误算法：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(HashMap&lt;Integer, LinkedList&lt;Integer&gt;&gt; graph, HashSet&lt;Integer&gt; visited, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">Queue&lt;Integer&gt; q=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">q.offer(start);</span><br><span class="line"><span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line"><span class="keyword">int</span> node = q.poll();</span><br><span class="line">visited.add(node);</span><br><span class="line">LinkedList&lt;Integer&gt; children = graph.get(node);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> child : children)&#123;</span><br><span class="line"><span class="keyword">if</span> (!visited.contains(child))</span><br><span class="line">q.offer(child);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="按层次遍历："><a href="#按层次遍历：" class="headerlink" title="按层次遍历："></a><strong>按层次遍历：</strong></h3><p>第一思路是用两个队列来实现：用第一个队列存储该层的节点，第二个队列存储第一个队列中节点的儿子节点，<br>也就是下一次的节点。此思路比较容易实现。</p><h3 id="Java代码：-1"><a href="#Java代码：-1" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 假设不循环</span></span><br><span class="line"><span class="comment"> * graph: 邻接表</span></span><br><span class="line"><span class="comment"> * start: BFS的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfsByLayer</span><span class="params">(HashMap&lt;Integer, LinkedList&lt;Integer&gt;&gt; graph, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">Queue&lt;Integer&gt; q=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">Queue&lt;Integer&gt; q2=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span> layer = <span class="number">1</span>;</span><br><span class="line">q.offer(start);</span><br><span class="line"><span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line"><span class="keyword">int</span> node = q.poll();</span><br><span class="line">System.out.println(<span class="string">"node:"</span>+node+<span class="string">" in layer "</span>+ layer);</span><br><span class="line">LinkedList&lt;Integer&gt; children = graph.get(node);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> child : children)&#123;</span><br><span class="line">q2.offer(child);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(q.isEmpty() &amp;&amp; !q2.isEmpty())&#123;</span><br><span class="line">q = q2;</span><br><span class="line">q2 = <span class="keyword">new</span> LinkedList&lt;&gt;(); </span><br><span class="line">layer++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二思路是只用一个队列来实现：层与层之间用结束符间隔，每遇到结束符，表示该层访问结束，下一层的节点也准备好<br>（不会再有新的节点加入到这一层），此时再往队列加入新的结束符。此思路对数据有一定限制，实现起来注意事项较多。</p><h3 id="Java代码：-2"><a href="#Java代码：-2" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfsByLayer2</span><span class="params">(HashMap&lt;Integer, LinkedList&lt;Integer&gt;&gt; graph, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">Queue&lt;Integer&gt; q=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span> layer = <span class="number">1</span>;</span><br><span class="line">q.offer(start);</span><br><span class="line">q.offer(-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line"><span class="keyword">int</span> node = q.poll();</span><br><span class="line"><span class="keyword">if</span>(node == -<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//确保有非结束符节点</span></span><br><span class="line"><span class="keyword">if</span>(q.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">q.offer(-<span class="number">1</span>);</span><br><span class="line">layer++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"node:"</span>+node+<span class="string">" in layer "</span>+ layer);</span><br><span class="line">LinkedList&lt;Integer&gt; children = graph.get(node);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> child : children)&#123;</span><br><span class="line">q.offer(child);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，w为树的所有层里面的最大长度，空间复杂度<code>O(w)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法思路：&quot;&gt;&lt;a href=&quot;#算法思路：&quot; class=&quot;headerlink&quot; title=&quot;算法思路：&quot;&gt;&lt;/a&gt;&lt;strong&gt;算法思路：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;图用邻接表为输入，思路用Queue实现, 还要一个机制记录节点访问过没有，可以用H
      
    
    </summary>
    
    
      <category term="Knowledge Base" scheme="https://shineboy2013.github.com/tags/Knowledge-Base/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 122 Best Time to Buy and Sell Stock II</title>
    <link href="https://shineboy2013.github.com/2017/11/28/lee-122/"/>
    <id>https://shineboy2013.github.com/2017/11/28/lee-122/</id>
    <published>2017-11-28T09:39:08.641Z</published>
    <updated>2017-12-31T06:27:27.294Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">LeetCode 122 Best Time to Buy and Sell Stock II</a></strong></p><p>Say you have an array for which the <em>i</em><sup>th</sup> element is the price of a given stock on day <em>i</em>.</p><p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>设计一个算法寻找最大收益。你可以随便完成多少次交易（比如，多次买入卖出）。然而你不能一次进行多次交易。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>仍然是求最大利润，可以交易多次，但要先卖再买。容易想到是求所有上升坡的的总和。更简单而言，若将每一个上升坡，分成一小段(每天的交易)，求这些小段的和即可。<br>如：[6, 1, 2, 3, 4]中的1, 2, 3, 4序列来说，对于两种操作方案：<br>1 在1买入，4卖出<br>2 在1买入，2卖出同时买入，3卖出同时买入，4卖出<br>这两种操作下，收益是一样的。这种方法，避免检测下坡以及计算每段的和。</p><p><img src="/images/L122.png" alt=""></p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>数组为空</li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(prices.length==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(prices[i-<span class="number">1</span>]&lt;prices[i])</span><br><span class="line">profit += prices[i] - prices[i-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，n为字符串长度，空间复杂度<code>O(1)</code>。</p><h3 id="相关题目："><a href="#相关题目：" class="headerlink" title="相关题目："></a><strong>相关题目：</strong></h3><p><a href="https://shineboy2013.github.io/2017/11/27/lee-121/" target="_blank" rel="noopener">LeetCode 121 Best Time to Buy and Sell Stock</a><br><a href="https://shineboy2013.github.io/2017/11/28/lee-122/" target="_blank" rel="noopener">LeetCode 122 Best Time to Buy and Sell Stock II</a><br><a href="https://shineboy2013.github.io/2017/12/11/lee-309/" target="_blank" rel="noopener">LeetCode 309 Best Time to Buy and Sell Stock with Cooldown</a><br><a href="https://shineboy2013.github.io/2017/12/24/lee-123/" target="_blank" rel="noopener">LeetCode 123 Best Time to Buy and Sell Stock III</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 122 Best Time
      
    
    </summary>
    
    
      <category term="Classic" scheme="https://shineboy2013.github.com/tags/Classic/"/>
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Greedy" scheme="https://shineboy2013.github.com/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 121 Best Time to Buy and Sell Stock</title>
    <link href="https://shineboy2013.github.com/2017/11/27/lee-121/"/>
    <id>https://shineboy2013.github.com/2017/11/27/lee-121/</id>
    <published>2017-11-27T08:05:59.671Z</published>
    <updated>2017-12-25T03:02:14.757Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">LeetCode 121 Best Time to Buy and Sell Stock</a></strong></p><p>Say you have an array for which the <em>i</em><sup>th</sup> element is the price of a given stock on day <em>i</em>.</p><p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p><p><strong>Example 1:</strong>  </p><pre>Input: [7, 1, 5, 3, 6, 4]Output: 5max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)</pre><p><strong>Example 2:</strong>  </p><pre>Input: [7, 6, 4, 3, 1]Output: 0In this case, no transaction is done, i.e. max profit = 0.</pre><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>如果你只能进行一次交易（比如购买或者销售一个股票），设计一个算法来获取最大利润。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>利润=当前价格-买入价，利润作为第一个变量求其最大值。由于买入价越低，利润可能会越大，所以第二个变量就要不断更新买入价（最小值）。<br>本题核心思路就是维护两个变量：最低价，利润。为什么不用最高价而选择利润呢？因为最低价和最高价没有顺序，最高价必须在最低价后面，<br>这样的利润才可实现，但如果是最低价和利润，就能确保这个顺序了，因为利润一定是在最低价后，否则这个利润为负，不能为最大值。</p><p><img src="/images/L121.png" alt=""></p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>数组为空</li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(prices.length==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> curProfit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> todayProfit = prices[i]-min;</span><br><span class="line"><span class="keyword">if</span>(todayProfit&gt;curProfit)</span><br><span class="line">curProfit = todayProfit;</span><br><span class="line"><span class="keyword">if</span>(min&gt;prices[i])</span><br><span class="line">min = prices[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> curProfit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>时间复杂度为<code>O(n)</code>，n为字符串长度，空间复杂度<code>O(1)</code>。</p><h3 id="相关题目："><a href="#相关题目：" class="headerlink" title="相关题目："></a><strong>相关题目：</strong></h3><p><a href="https://shineboy2013.github.io/2017/11/27/lee-121/" target="_blank" rel="noopener">LeetCode 121 Best Time to Buy and Sell Stock</a><br><a href="https://shineboy2013.github.io/2017/11/28/lee-122/" target="_blank" rel="noopener">LeetCode 122 Best Time to Buy and Sell Stock II</a><br><a href="https://shineboy2013.github.io/2017/12/11/lee-309/" target="_blank" rel="noopener">LeetCode 309 Best Time to Buy and Sell Stock with Cooldown</a><br><a href="https://shineboy2013.github.io/2017/12/24/lee-123/" target="_blank" rel="noopener">LeetCode 123 Best Time to Buy and Sell Stock III</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/best-time-to-buy-and-sell-stock/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 121 Best Time to
      
    
    </summary>
    
    
      <category term="Array" scheme="https://shineboy2013.github.com/tags/Array/"/>
    
      <category term="Dynamic Programming" scheme="https://shineboy2013.github.com/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Index Page</title>
    <link href="https://shineboy2013.github.com/2017/11/02/lee/"/>
    <id>https://shineboy2013.github.com/2017/11/02/lee/</id>
    <published>2017-11-02T11:43:32.924Z</published>
    <updated>2017-12-31T20:02:39.090Z</updated>
    
    <content type="html"><![CDATA[<p><strong>LeetCode 目录</strong></p><table><thead><tr><th>#</th><th style="text-align:left">Title</th><th style="text-align:left">Difficulty</th></tr></thead><tbody><tr><td>1</td><td style="text-align:left">Two Sum</td><td style="text-align:left">Easy</td></tr><tr><td>2</td><td style="text-align:left">Add Two Numbers</td><td style="text-align:left">Medium</td></tr><tr><td>3</td><td style="text-align:left">Longest Substring Without Repeating Characters</td><td style="text-align:left">Medium</td></tr><tr><td>4</td><td style="text-align:left">Median of Two Sorted Arrays</td><td style="text-align:left">Hard</td></tr><tr><td>5</td><td style="text-align:left">Longest Palindromic Substring</td><td style="text-align:left">Medium</td></tr><tr><td>6</td><td style="text-align:left">ZigZag Conversion</td><td style="text-align:left">Medium</td></tr><tr><td>7</td><td style="text-align:left">Reverse Integer</td><td style="text-align:left">Easy</td></tr><tr><td>8</td><td style="text-align:left">String to Integer (atoi)</td><td style="text-align:left">Medium</td></tr><tr><td>9</td><td style="text-align:left">Palindrome Number</td><td style="text-align:left">Easy</td></tr><tr><td>10</td><td style="text-align:left">Regular Expression Matching</td><td style="text-align:left">Hard</td></tr><tr><td>11</td><td style="text-align:left">Container With Most Water</td><td style="text-align:left">Medium</td></tr><tr><td>12</td><td style="text-align:left">Integer to Roman</td><td style="text-align:left">Medium</td></tr><tr><td>13</td><td style="text-align:left">Roman to Integer</td><td style="text-align:left">Easy</td></tr><tr><td>14</td><td style="text-align:left">Longest Common Prefix</td><td style="text-align:left">Easy</td></tr><tr><td>15</td><td style="text-align:left">3Sum</td><td style="text-align:left">Medium</td></tr><tr><td>16</td><td style="text-align:left">3Sum Closest</td><td style="text-align:left">Medium</td></tr><tr><td>17</td><td style="text-align:left">Letter Combinations of a Phone Number</td><td style="text-align:left">Medium</td></tr><tr><td>18</td><td style="text-align:left">4Sum</td><td style="text-align:left">Medium</td></tr><tr><td>19</td><td style="text-align:left">Remove Nth Node From End of List</td><td style="text-align:left">Medium</td></tr><tr><td>20</td><td style="text-align:left">Valid Parentheses</td><td style="text-align:left">Easy</td></tr><tr><td>21</td><td style="text-align:left">Merge Two Sorted Lists</td><td style="text-align:left">Easy</td></tr><tr><td>22</td><td style="text-align:left">Generate Parentheses</td><td style="text-align:left">Medium</td></tr><tr><td>23</td><td style="text-align:left">Merge k Sorted Lists</td><td style="text-align:left">Hard</td></tr><tr><td>24</td><td style="text-align:left">Swap Nodes in Pairs</td><td style="text-align:left">Medium</td></tr><tr><td>25</td><td style="text-align:left">Reverse Nodes in k-Group</td><td style="text-align:left">Hard</td></tr><tr><td>26</td><td style="text-align:left">Remove Duplicates from Sorted Array</td><td style="text-align:left">Easy</td></tr><tr><td>27</td><td style="text-align:left">Remove Element</td><td style="text-align:left">Easy</td></tr><tr><td>28</td><td style="text-align:left">Implement strStr()</td><td style="text-align:left">Easy</td></tr><tr><td>29</td><td style="text-align:left">Divide Two Integers</td><td style="text-align:left">Medium</td></tr><tr><td>30</td><td style="text-align:left">Substring with Concatenation of All Words</td><td style="text-align:left">Hard</td></tr><tr><td>31</td><td style="text-align:left">Next Permutation</td><td style="text-align:left">Medium</td></tr><tr><td>32</td><td style="text-align:left">Longest Valid Parentheses</td><td style="text-align:left">Hard</td></tr><tr><td>33</td><td style="text-align:left">Search in Rotated Sorted Array</td><td style="text-align:left">Medium</td></tr><tr><td>34</td><td style="text-align:left">Search for a Range</td><td style="text-align:left">Medium</td></tr><tr><td>35</td><td style="text-align:left">Search Insert Position</td><td style="text-align:left">Easy</td></tr><tr><td>36</td><td style="text-align:left">Valid Sudoku</td><td style="text-align:left">Medium</td></tr><tr><td>37</td><td style="text-align:left">Sudoku Solver</td><td style="text-align:left">Hard</td></tr><tr><td>38</td><td style="text-align:left">Count and Say</td><td style="text-align:left">Easy</td></tr><tr><td>39</td><td style="text-align:left">Combination Sum</td><td style="text-align:left">Medium</td></tr><tr><td>40</td><td style="text-align:left">Combination Sum II</td><td style="text-align:left">Medium</td></tr><tr><td>41</td><td style="text-align:left">First Missing Positive</td><td style="text-align:left">Hard</td></tr><tr><td>42</td><td style="text-align:left">Trapping Rain Water</td><td style="text-align:left">Hard</td></tr><tr><td>43</td><td style="text-align:left">Multiply Strings</td><td style="text-align:left">Medium</td></tr><tr><td>44</td><td style="text-align:left">Wildcard Matching</td><td style="text-align:left">Hard</td></tr><tr><td>45</td><td style="text-align:left">Jump Game II</td><td style="text-align:left">Hard</td></tr><tr><td>46</td><td style="text-align:left">Permutations</td><td style="text-align:left">Medium</td></tr><tr><td>47</td><td style="text-align:left">Permutations II</td><td style="text-align:left">Medium</td></tr><tr><td>48</td><td style="text-align:left">Rotate Image</td><td style="text-align:left">Medium</td></tr><tr><td>49</td><td style="text-align:left">Group Anagrams</td><td style="text-align:left">Medium</td></tr><tr><td>50</td><td style="text-align:left">Pow(x, n)</td><td style="text-align:left">Medium</td></tr><tr><td>51</td><td style="text-align:left">N-Queens</td><td style="text-align:left">Hard</td></tr><tr><td>52</td><td style="text-align:left">N-Queens II</td><td style="text-align:left">Hard</td></tr><tr><td>53</td><td style="text-align:left">Maximum Subarray</td><td style="text-align:left">Easy</td></tr><tr><td>54</td><td style="text-align:left">Spiral Matrix</td><td style="text-align:left">Medium</td></tr><tr><td>55</td><td style="text-align:left">Jump Game</td><td style="text-align:left">Medium</td></tr><tr><td>56</td><td style="text-align:left">Merge Intervals</td><td style="text-align:left">Medium</td></tr><tr><td>57</td><td style="text-align:left">Insert Interval</td><td style="text-align:left">Hard</td></tr><tr><td>58</td><td style="text-align:left">Length of Last Word</td><td style="text-align:left">Easy</td></tr><tr><td>59</td><td style="text-align:left">Spiral Matrix II</td><td style="text-align:left">Medium</td></tr><tr><td>60</td><td style="text-align:left">Permutation Sequence</td><td style="text-align:left">Medium</td></tr><tr><td>61</td><td style="text-align:left">Rotate List</td><td style="text-align:left">Medium</td></tr><tr><td>62</td><td style="text-align:left">Unique Paths</td><td style="text-align:left">Medium</td></tr><tr><td>63</td><td style="text-align:left">Unique Paths II</td><td style="text-align:left">Medium</td></tr><tr><td>64</td><td style="text-align:left">Minimum Path Sum</td><td style="text-align:left">Medium</td></tr><tr><td>65</td><td style="text-align:left">Valid Number</td><td style="text-align:left">Hard</td></tr><tr><td>66</td><td style="text-align:left">Plus One</td><td style="text-align:left">Easy</td></tr><tr><td>67</td><td style="text-align:left">Add Binary</td><td style="text-align:left">Easy</td></tr><tr><td>68</td><td style="text-align:left">Text Justification</td><td style="text-align:left">Hard</td></tr><tr><td>69</td><td style="text-align:left">Sqrt(x)</td><td style="text-align:left">Easy</td></tr><tr><td>70</td><td style="text-align:left">Climbing Stairs</td><td style="text-align:left">Easy</td></tr><tr><td>71</td><td style="text-align:left">Simplify Path</td><td style="text-align:left">Medium</td></tr><tr><td>72</td><td style="text-align:left">Edit Distance</td><td style="text-align:left">Hard</td></tr><tr><td>73</td><td style="text-align:left">Set Matrix Zeroes</td><td style="text-align:left">Medium</td></tr><tr><td>74</td><td style="text-align:left">Search a 2D Matrix</td><td style="text-align:left">Medium</td></tr><tr><td>75</td><td style="text-align:left">Sort Colors</td><td style="text-align:left">Medium</td></tr><tr><td>76</td><td style="text-align:left">Minimum Window Substring</td><td style="text-align:left">Hard</td></tr><tr><td>77</td><td style="text-align:left">Combinations</td><td style="text-align:left">Medium</td></tr><tr><td>78</td><td style="text-align:left">Subsets</td><td style="text-align:left">Medium</td></tr><tr><td>79</td><td style="text-align:left">Word Search</td><td style="text-align:left">Medium</td></tr><tr><td>80</td><td style="text-align:left">Remove Duplicates from Sorted Array II</td><td style="text-align:left">Medium</td></tr><tr><td>81</td><td style="text-align:left">Search in Rotated Sorted Array II</td><td style="text-align:left">Medium</td></tr><tr><td>82</td><td style="text-align:left">Remove Duplicates from Sorted List II</td><td style="text-align:left">Medium</td></tr><tr><td>83</td><td style="text-align:left">Remove Duplicates from Sorted List</td><td style="text-align:left">Easy</td></tr><tr><td>84</td><td style="text-align:left">Largest Rectangle in Histogram</td><td style="text-align:left">Hard</td></tr><tr><td>85</td><td style="text-align:left">Maximal Rectangle</td><td style="text-align:left">Hard</td></tr><tr><td>86</td><td style="text-align:left">Partition List</td><td style="text-align:left">Medium</td></tr><tr><td>87</td><td style="text-align:left">Scramble String</td><td style="text-align:left">Hard</td></tr><tr><td>88</td><td style="text-align:left">Merge Sorted Array</td><td style="text-align:left">Easy</td></tr><tr><td>89</td><td style="text-align:left">Gray Code</td><td style="text-align:left">Medium</td></tr><tr><td>90</td><td style="text-align:left">Subsets II</td><td style="text-align:left">Medium</td></tr><tr><td>91</td><td style="text-align:left">Decode Ways</td><td style="text-align:left">Medium</td></tr><tr><td>92</td><td style="text-align:left">Reverse Linked List II</td><td style="text-align:left">Medium</td></tr><tr><td>93</td><td style="text-align:left">Restore IP Addresses</td><td style="text-align:left">Medium</td></tr><tr><td>94</td><td style="text-align:left">Binary Tree Inorder Traversal</td><td style="text-align:left">Medium</td></tr><tr><td>95</td><td style="text-align:left">Unique Binary Search Trees II</td><td style="text-align:left">Medium</td></tr><tr><td>96</td><td style="text-align:left">Unique Binary Search Trees</td><td style="text-align:left">Medium</td></tr><tr><td>97</td><td style="text-align:left">Interleaving String</td><td style="text-align:left">Hard</td></tr><tr><td>98</td><td style="text-align:left">Validate Binary Search Tree</td><td style="text-align:left">Medium</td></tr><tr><td>99</td><td style="text-align:left">Recover Binary Search Tree</td><td style="text-align:left">Hard</td></tr><tr><td>100</td><td style="text-align:left">Same Tree</td><td style="text-align:left">Easy</td></tr><tr><td>101</td><td style="text-align:left">Symmetric Tree</td><td style="text-align:left">Easy</td></tr><tr><td>102</td><td style="text-align:left">Binary Tree Level Order Traversal</td><td style="text-align:left">Medium</td></tr><tr><td>103</td><td style="text-align:left">Binary Tree Zigzag Level Order Traversal</td><td style="text-align:left">Medium</td></tr><tr><td>104</td><td style="text-align:left">Maximum Depth of Binary Tree</td><td style="text-align:left">Easy</td></tr><tr><td>105</td><td style="text-align:left">Construct Binary Tree from Preorder and Inorder Traversal</td><td style="text-align:left">Medium</td></tr><tr><td>106</td><td style="text-align:left">Construct Binary Tree from Inorder and Postorder Traversal</td><td style="text-align:left">Medium</td></tr><tr><td>107</td><td style="text-align:left">Binary Tree Level Order Traversal II</td><td style="text-align:left">Easy</td></tr><tr><td>108</td><td style="text-align:left">Convert Sorted Array to Binary Search Tree</td><td style="text-align:left">Easy</td></tr><tr><td>109</td><td style="text-align:left">Convert Sorted List to Binary Search Tree</td><td style="text-align:left">Medium</td></tr><tr><td>110</td><td style="text-align:left">Balanced Binary Tree</td><td style="text-align:left">Easy</td></tr><tr><td>111</td><td style="text-align:left">Minimum Depth of Binary Tree</td><td style="text-align:left">Easy</td></tr><tr><td>112</td><td style="text-align:left">[Path Sum]</td><td style="text-align:left">Easy</td></tr><tr><td>113</td><td style="text-align:left">Path Sum II</td><td style="text-align:left">Medium</td></tr><tr><td>114</td><td style="text-align:left">Flatten Binary Tree to Linked List</td><td style="text-align:left">Medium</td></tr><tr><td>115</td><td style="text-align:left">Distinct Subsequences</td><td style="text-align:left">Hard</td></tr><tr><td>116</td><td style="text-align:left">Populating Next Right Pointers in Each Node</td><td style="text-align:left">Medium</td></tr><tr><td>117</td><td style="text-align:left">Populating Next Right Pointers in Each Node II</td><td style="text-align:left">Medium</td></tr><tr><td>118</td><td style="text-align:left">Pascal’s Triangle</td><td style="text-align:left">Easy</td></tr><tr><td>119</td><td style="text-align:left">Pascal’s Triangle II</td><td style="text-align:left">Easy</td></tr><tr><td>120</td><td style="text-align:left">Triangle</td><td style="text-align:left">Medium</td></tr><tr><td>121</td><td style="text-align:left"><a href="https://shineboy2013.github.io/2017/11/27/lee-121/" target="_blank" rel="noopener">Best Time to Buy and Sell Stock</a></td><td style="text-align:left">Easy</td></tr><tr><td>122</td><td style="text-align:left"><a href="https://shineboy2013.github.io/2017/11/28/lee-122/" target="_blank" rel="noopener">Best Time to Buy and Sell Stock II</a></td><td style="text-align:left">Easy</td></tr><tr><td>123</td><td style="text-align:left">[Best Time to Buy and Sell Stock III]</td><td style="text-align:left">Hard</td></tr><tr><td>124</td><td style="text-align:left">Binary Tree Maximum Path Sum</td><td style="text-align:left">Hard</td></tr><tr><td>125</td><td style="text-align:left">Valid Palindrome</td><td style="text-align:left">Easy</td></tr><tr><td>126</td><td style="text-align:left">Word Ladder II</td><td style="text-align:left">Hard</td></tr><tr><td>127</td><td style="text-align:left">Word Ladder</td><td style="text-align:left">Medium</td></tr><tr><td>128</td><td style="text-align:left">Longest Consecutive Sequence</td><td style="text-align:left">Hard</td></tr><tr><td>129</td><td style="text-align:left">Sum Root to Leaf Numbers</td><td style="text-align:left">Medium</td></tr><tr><td>130</td><td style="text-align:left">Surrounded Regions</td><td style="text-align:left">Medium</td></tr><tr><td>131</td><td style="text-align:left">Palindrome Partitioning</td><td style="text-align:left">Medium</td></tr><tr><td>132</td><td style="text-align:left">Palindrome Partitioning II</td><td style="text-align:left">Hard</td></tr><tr><td>133</td><td style="text-align:left">Clone Graph</td><td style="text-align:left">Medium</td></tr><tr><td>134</td><td style="text-align:left">Gas Station</td><td style="text-align:left">Medium</td></tr><tr><td>135</td><td style="text-align:left">Candy</td><td style="text-align:left">Hard</td></tr><tr><td>136</td><td style="text-align:left">Single Number</td><td style="text-align:left">Easy</td></tr><tr><td>137</td><td style="text-align:left">Single Number II</td><td style="text-align:left">Medium</td></tr><tr><td>138</td><td style="text-align:left">Copy List with Random Pointer</td><td style="text-align:left">Medium</td></tr><tr><td>139</td><td style="text-align:left">Word Break</td><td style="text-align:left">Medium</td></tr><tr><td>140</td><td style="text-align:left">Word Break II</td><td style="text-align:left">Hard</td></tr><tr><td>141</td><td style="text-align:left">Linked List Cycle</td><td style="text-align:left">Easy</td></tr><tr><td>142</td><td style="text-align:left">Linked List Cycle II</td><td style="text-align:left">Medium</td></tr><tr><td>143</td><td style="text-align:left">Reorder List</td><td style="text-align:left">Medium</td></tr><tr><td>144</td><td style="text-align:left">Binary Tree Preorder Traversal</td><td style="text-align:left">Medium</td></tr><tr><td>145</td><td style="text-align:left">Binary Tree Postorder Traversal</td><td style="text-align:left">Hard</td></tr><tr><td>146</td><td style="text-align:left">LRU Cache</td><td style="text-align:left">Hard</td></tr><tr><td>147</td><td style="text-align:left">Insertion Sort List</td><td style="text-align:left">Medium</td></tr><tr><td>148</td><td style="text-align:left">Sort List</td><td style="text-align:left">Medium</td></tr><tr><td>149</td><td style="text-align:left">Max Points on a Line</td><td style="text-align:left">Hard</td></tr><tr><td>150</td><td style="text-align:left">Evaluate Reverse Polish Notation</td><td style="text-align:left">Medium</td></tr><tr><td>151</td><td style="text-align:left">Reverse Words in a String</td><td style="text-align:left">Medium</td></tr><tr><td>152</td><td style="text-align:left">Maximum Product Subarray</td><td style="text-align:left">Medium</td></tr><tr><td>153</td><td style="text-align:left">Find Minimum in Rotated Sorted Array</td><td style="text-align:left">Medium</td></tr><tr><td>154</td><td style="text-align:left">Find Minimum in Rotated Sorted Array II</td><td style="text-align:left">Hard</td></tr><tr><td>155</td><td style="text-align:left">Min Stack</td><td style="text-align:left">Easy</td></tr><tr><td>156</td><td style="text-align:left">Binary Tree Upside Down</td><td style="text-align:left">Medium</td></tr><tr><td>157</td><td style="text-align:left">Read N Characters Given Read4</td><td style="text-align:left">Easy</td></tr><tr><td>158</td><td style="text-align:left">Read N Characters Given Read4 II - Call multiple times</td><td style="text-align:left">Hard</td></tr><tr><td>159</td><td style="text-align:left">Longest Substring with At Most Two Distinct Characters</td><td style="text-align:left">Hard</td></tr><tr><td>160</td><td style="text-align:left">Intersection of Two Linked Lists</td><td style="text-align:left">Easy</td></tr><tr><td>161</td><td style="text-align:left">One Edit Distance</td><td style="text-align:left">Medium</td></tr><tr><td>162</td><td style="text-align:left">Find Peak Element</td><td style="text-align:left">Medium</td></tr><tr><td>163</td><td style="text-align:left">Missing Ranges</td><td style="text-align:left">Medium</td></tr><tr><td>164</td><td style="text-align:left">Maximum Gap</td><td style="text-align:left">Hard</td></tr><tr><td>165</td><td style="text-align:left">Compare Version Numbers</td><td style="text-align:left">Medium</td></tr><tr><td>166</td><td style="text-align:left">Fraction to Recurring Decimal</td><td style="text-align:left">Medium</td></tr><tr><td>167</td><td style="text-align:left">Two Sum II - Input array is sorted</td><td style="text-align:left">Easy</td></tr><tr><td>168</td><td style="text-align:left">Excel Sheet Column Title</td><td style="text-align:left">Easy</td></tr><tr><td>169</td><td style="text-align:left">Majority Element</td><td style="text-align:left">Easy</td></tr><tr><td>170</td><td style="text-align:left">Two Sum III - Data structure design</td><td style="text-align:left">Easy</td></tr><tr><td>171</td><td style="text-align:left">Excel Sheet Column Number</td><td style="text-align:left">Easy</td></tr><tr><td>172</td><td style="text-align:left">Factorial Trailing Zeroes</td><td style="text-align:left">Easy</td></tr><tr><td>173</td><td style="text-align:left">Binary Search Tree Iterator</td><td style="text-align:left">Medium</td></tr><tr><td>174</td><td style="text-align:left">Dungeon Game</td><td style="text-align:left">Hard</td></tr><tr><td>175</td><td style="text-align:left">Combine Two Tables</td><td style="text-align:left">Easy</td></tr><tr><td>176</td><td style="text-align:left">Second Highest Salary</td><td style="text-align:left">Easy</td></tr><tr><td>177</td><td style="text-align:left">Nth Highest Salary</td><td style="text-align:left">Medium</td></tr><tr><td>178</td><td style="text-align:left">Rank Scores</td><td style="text-align:left">Medium</td></tr><tr><td>179</td><td style="text-align:left">Largest Number</td><td style="text-align:left">Medium</td></tr><tr><td>180</td><td style="text-align:left">Consecutive Numbers</td><td style="text-align:left">Medium</td></tr><tr><td>181</td><td style="text-align:left">Employees Earning More Than Their Managers</td><td style="text-align:left">Easy</td></tr><tr><td>182</td><td style="text-align:left">Duplicate Emails</td><td style="text-align:left">Easy</td></tr><tr><td>183</td><td style="text-align:left">Customers Who Never Order</td><td style="text-align:left">Easy</td></tr><tr><td>184</td><td style="text-align:left">Department Highest Salary</td><td style="text-align:left">Medium</td></tr><tr><td>185</td><td style="text-align:left">Department Top Three Salaries</td><td style="text-align:left">Hard</td></tr><tr><td>186</td><td style="text-align:left">Reverse Words in a String II</td><td style="text-align:left">Medium</td></tr><tr><td>187</td><td style="text-align:left">Repeated DNA Sequences</td><td style="text-align:left">Medium</td></tr><tr><td>188</td><td style="text-align:left">Best Time to Buy and Sell Stock IV</td><td style="text-align:left">Hard</td></tr><tr><td>189</td><td style="text-align:left">Rotate Array</td><td style="text-align:left">Easy</td></tr><tr><td>190</td><td style="text-align:left">Reverse Bits</td><td style="text-align:left">Easy</td></tr><tr><td>191</td><td style="text-align:left">Number of 1 Bits</td><td style="text-align:left">Easy</td></tr><tr><td>192</td><td style="text-align:left">Word Frequency</td><td style="text-align:left">Medium</td></tr><tr><td>193</td><td style="text-align:left">Valid Phone Numbers</td><td style="text-align:left">Easy</td></tr><tr><td>194</td><td style="text-align:left">Transpose File</td><td style="text-align:left">Medium</td></tr><tr><td>195</td><td style="text-align:left">Tenth Line</td><td style="text-align:left">Easy</td></tr><tr><td>196</td><td style="text-align:left">Delete Duplicate Emails</td><td style="text-align:left">Easy</td></tr><tr><td>197</td><td style="text-align:left">Rising Temperature</td><td style="text-align:left">Easy</td></tr><tr><td>198</td><td style="text-align:left">House Robber</td><td style="text-align:left">Easy</td></tr><tr><td>199</td><td style="text-align:left">Binary Tree Right Side View</td><td style="text-align:left">Medium</td></tr><tr><td>200</td><td style="text-align:left">[Number of Islands]</td><td style="text-align:left">Medium</td></tr><tr><td>201</td><td style="text-align:left">Bitwise AND of Numbers Range</td><td style="text-align:left">Medium</td></tr><tr><td>202</td><td style="text-align:left">Happy Number</td><td style="text-align:left">Easy</td></tr><tr><td>203</td><td style="text-align:left">Remove Linked List Elements</td><td style="text-align:left">Easy</td></tr><tr><td>204</td><td style="text-align:left">Count Primes</td><td style="text-align:left">Easy</td></tr><tr><td>205</td><td style="text-align:left">Isomorphic Strings</td><td style="text-align:left">Easy</td></tr><tr><td>206</td><td style="text-align:left">Reverse Linked List</td><td style="text-align:left">Easy</td></tr><tr><td>207</td><td style="text-align:left">Course Schedule</td><td style="text-align:left">Medium</td></tr><tr><td>208</td><td style="text-align:left">Implement Trie (Prefix Tree)</td><td style="text-align:left">Medium</td></tr><tr><td>209</td><td style="text-align:left">Minimum Size Subarray Sum</td><td style="text-align:left">Medium</td></tr><tr><td>210</td><td style="text-align:left">Course Schedule II</td><td style="text-align:left">Medium</td></tr><tr><td>211</td><td style="text-align:left">Add and Search Word - Data structure design</td><td style="text-align:left">Medium</td></tr><tr><td>212</td><td style="text-align:left">Word Search II</td><td style="text-align:left">Hard</td></tr><tr><td>213</td><td style="text-align:left">House Robber II</td><td style="text-align:left">Medium</td></tr><tr><td>214</td><td style="text-align:left">Shortest Palindrome</td><td style="text-align:left">Hard</td></tr><tr><td>215</td><td style="text-align:left">Kth Largest Element in an Array</td><td style="text-align:left">Medium</td></tr><tr><td>216</td><td style="text-align:left">Combination Sum III</td><td style="text-align:left">Medium</td></tr><tr><td>217</td><td style="text-align:left">Contains Duplicate</td><td style="text-align:left">Easy</td></tr><tr><td>218</td><td style="text-align:left">The Skyline Problem</td><td style="text-align:left">Hard</td></tr><tr><td>219</td><td style="text-align:left">Contains Duplicate II</td><td style="text-align:left">Easy</td></tr><tr><td>220</td><td style="text-align:left">Contains Duplicate III</td><td style="text-align:left">Medium</td></tr><tr><td>221</td><td style="text-align:left">Maximal Square</td><td style="text-align:left">Medium</td></tr><tr><td>222</td><td style="text-align:left">Count Complete Tree Nodes</td><td style="text-align:left">Medium</td></tr><tr><td>223</td><td style="text-align:left">Rectangle Area</td><td style="text-align:left">Medium</td></tr><tr><td>224</td><td style="text-align:left">Basic Calculator</td><td style="text-align:left">Hard</td></tr><tr><td>225</td><td style="text-align:left">Implement Stack using Queues</td><td style="text-align:left">Easy</td></tr><tr><td>226</td><td style="text-align:left">Invert Binary Tree</td><td style="text-align:left">Easy</td></tr><tr><td>227</td><td style="text-align:left">Basic Calculator II</td><td style="text-align:left">Medium</td></tr><tr><td>228</td><td style="text-align:left">Summary Ranges</td><td style="text-align:left">Medium</td></tr><tr><td>229</td><td style="text-align:left">Majority Element II</td><td style="text-align:left">Medium</td></tr><tr><td>230</td><td style="text-align:left">Kth Smallest Element in a BST</td><td style="text-align:left">Medium</td></tr><tr><td>231</td><td style="text-align:left">Power of Two</td><td style="text-align:left">Easy</td></tr><tr><td>232</td><td style="text-align:left">Implement Queue using Stacks</td><td style="text-align:left">Easy</td></tr><tr><td>233</td><td style="text-align:left">Number of Digit One</td><td style="text-align:left">Hard</td></tr><tr><td>234</td><td style="text-align:left">Palindrome Linked List</td><td style="text-align:left">Easy</td></tr><tr><td>235</td><td style="text-align:left">Lowest Common Ancestor of a Binary Search Tree</td><td style="text-align:left">Easy</td></tr><tr><td>236</td><td style="text-align:left">Lowest Common Ancestor of a Binary Tree</td><td style="text-align:left">Medium</td></tr><tr><td>237</td><td style="text-align:left">Delete Node in a Linked List</td><td style="text-align:left">Easy</td></tr><tr><td>238</td><td style="text-align:left">Product of Array Except Self</td><td style="text-align:left">Medium</td></tr><tr><td>239</td><td style="text-align:left">Sliding Window Maximum</td><td style="text-align:left">Hard</td></tr><tr><td>240</td><td style="text-align:left">Search a 2D Matrix II</td><td style="text-align:left">Medium</td></tr><tr><td>241</td><td style="text-align:left">Different Ways to Add Parentheses</td><td style="text-align:left">Medium</td></tr><tr><td>242</td><td style="text-align:left">Valid Anagram</td><td style="text-align:left">Easy</td></tr><tr><td>243</td><td style="text-align:left">Shortest Word Distance</td><td style="text-align:left">Easy</td></tr><tr><td>244</td><td style="text-align:left">Shortest Word Distance II</td><td style="text-align:left">Medium</td></tr><tr><td>245</td><td style="text-align:left">Shortest Word Distance III</td><td style="text-align:left">Medium</td></tr><tr><td>246</td><td style="text-align:left">Strobogrammatic Number</td><td style="text-align:left">Easy</td></tr><tr><td>247</td><td style="text-align:left">Strobogrammatic Number II</td><td style="text-align:left">Medium</td></tr><tr><td>248</td><td style="text-align:left">Strobogrammatic Number III</td><td style="text-align:left">Hard</td></tr><tr><td>249</td><td style="text-align:left">Group Shifted Strings</td><td style="text-align:left">Medium</td></tr><tr><td>250</td><td style="text-align:left">Count Univalue Subtrees</td><td style="text-align:left">Medium</td></tr><tr><td>251</td><td style="text-align:left">Flatten 2D Vector</td><td style="text-align:left">Medium</td></tr><tr><td>252</td><td style="text-align:left">Meeting Rooms</td><td style="text-align:left">Easy</td></tr><tr><td>253</td><td style="text-align:left">Meeting Rooms II</td><td style="text-align:left">Medium</td></tr><tr><td>254</td><td style="text-align:left">Factor Combinations</td><td style="text-align:left">Medium</td></tr><tr><td>255</td><td style="text-align:left">Verify Preorder Sequence in Binary Search Tree</td><td style="text-align:left">Medium</td></tr><tr><td>256</td><td style="text-align:left">Paint House</td><td style="text-align:left">Easy</td></tr><tr><td>257</td><td style="text-align:left">Binary Tree Paths</td><td style="text-align:left">Easy</td></tr><tr><td>258</td><td style="text-align:left">Add Digits</td><td style="text-align:left">Easy</td></tr><tr><td>259</td><td style="text-align:left">3Sum Smaller</td><td style="text-align:left">Medium</td></tr><tr><td>260</td><td style="text-align:left">Single Number III</td><td style="text-align:left">Medium</td></tr><tr><td>261</td><td style="text-align:left">Graph Valid Tree</td><td style="text-align:left">Medium</td></tr><tr><td>262</td><td style="text-align:left">Trips and Users</td><td style="text-align:left">Hard</td></tr><tr><td>263</td><td style="text-align:left">Ugly Number</td><td style="text-align:left">Easy</td></tr><tr><td>264</td><td style="text-align:left">Ugly Number II</td><td style="text-align:left">Medium</td></tr><tr><td>265</td><td style="text-align:left">Paint House II</td><td style="text-align:left">Hard</td></tr><tr><td>266</td><td style="text-align:left">Palindrome Permutation</td><td style="text-align:left">Easy</td></tr><tr><td>267</td><td style="text-align:left">Palindrome Permutation II</td><td style="text-align:left">Medium</td></tr><tr><td>268</td><td style="text-align:left">Missing Number</td><td style="text-align:left">Easy</td></tr><tr><td>269</td><td style="text-align:left">Alien Dictionary</td><td style="text-align:left">Hard</td></tr><tr><td>270</td><td style="text-align:left">Closest Binary Search Tree Value</td><td style="text-align:left">Easy</td></tr><tr><td>271</td><td style="text-align:left">Encode and Decode Strings</td><td style="text-align:left">Medium</td></tr><tr><td>272</td><td style="text-align:left">Closest Binary Search Tree Value II</td><td style="text-align:left">Hard</td></tr><tr><td>273</td><td style="text-align:left">Integer to English Words</td><td style="text-align:left">Hard</td></tr><tr><td>274</td><td style="text-align:left">H-Index</td><td style="text-align:left">Medium</td></tr><tr><td>275</td><td style="text-align:left">H-Index II</td><td style="text-align:left">Medium</td></tr><tr><td>276</td><td style="text-align:left">Paint Fence</td><td style="text-align:left">Easy</td></tr><tr><td>277</td><td style="text-align:left">Find the Celebrity</td><td style="text-align:left">Medium</td></tr><tr><td>278</td><td style="text-align:left">First Bad Version</td><td style="text-align:left">Easy</td></tr><tr><td>279</td><td style="text-align:left">Perfect Squares</td><td style="text-align:left">Medium</td></tr><tr><td>280</td><td style="text-align:left">Wiggle Sort</td><td style="text-align:left">Medium</td></tr><tr><td>281</td><td style="text-align:left">Zigzag Iterator</td><td style="text-align:left">Medium</td></tr><tr><td>282</td><td style="text-align:left">Expression Add Operators</td><td style="text-align:left">Hard</td></tr><tr><td>283</td><td style="text-align:left">Move Zeroes</td><td style="text-align:left">Easy</td></tr><tr><td>284</td><td style="text-align:left">Peeking Iterator</td><td style="text-align:left">Medium</td></tr><tr><td>285</td><td style="text-align:left">Inorder Successor in BST</td><td style="text-align:left">Medium</td></tr><tr><td>286</td><td style="text-align:left">Walls and Gates</td><td style="text-align:left">Medium</td></tr><tr><td>287</td><td style="text-align:left">Find the Duplicate Number</td><td style="text-align:left">Medium</td></tr><tr><td>288</td><td style="text-align:left">Unique Word Abbreviation</td><td style="text-align:left">Medium</td></tr><tr><td>289</td><td style="text-align:left">Game of Life</td><td style="text-align:left">Medium</td></tr><tr><td>290</td><td style="text-align:left">Word Pattern</td><td style="text-align:left">Easy</td></tr><tr><td>291</td><td style="text-align:left">Word Pattern II</td><td style="text-align:left">Hard</td></tr><tr><td>292</td><td style="text-align:left">Nim Game</td><td style="text-align:left">Easy</td></tr><tr><td>293</td><td style="text-align:left">Flip Game</td><td style="text-align:left">Easy</td></tr><tr><td>294</td><td style="text-align:left">Flip Game II</td><td style="text-align:left">Medium</td></tr><tr><td>295</td><td style="text-align:left">Find Median from Data Stream</td><td style="text-align:left">Hard</td></tr><tr><td>296</td><td style="text-align:left">Best Meeting Point</td><td style="text-align:left">Hard</td></tr><tr><td>297</td><td style="text-align:left">Serialize and Deserialize Binary Tree</td><td style="text-align:left">Hard</td></tr><tr><td>298</td><td style="text-align:left">Binary Tree Longest Consecutive Sequence</td><td style="text-align:left">Medium</td></tr><tr><td>299</td><td style="text-align:left">Bulls and Cows</td><td style="text-align:left">Medium</td></tr><tr><td>300</td><td style="text-align:left">Longest Increasing Subsequence</td><td style="text-align:left">Medium</td></tr><tr><td>301</td><td style="text-align:left">Remove Invalid Parentheses</td><td style="text-align:left">Hard</td></tr><tr><td>302</td><td style="text-align:left">Smallest Rectangle Enclosing Black Pixels</td><td style="text-align:left">Hard</td></tr><tr><td>303</td><td style="text-align:left">Range Sum Query - Immutable</td><td style="text-align:left">Easy</td></tr><tr><td>304</td><td style="text-align:left">Range Sum Query 2D - Immutable</td><td style="text-align:left">Medium</td></tr><tr><td>305</td><td style="text-align:left">Number of Islands II</td><td style="text-align:left">Hard</td></tr><tr><td>306</td><td style="text-align:left">Additive Number</td><td style="text-align:left">Medium</td></tr><tr><td>307</td><td style="text-align:left">Range Sum Query - Mutable</td><td style="text-align:left">Medium</td></tr><tr><td>308</td><td style="text-align:left">Range Sum Query 2D - Mutable</td><td style="text-align:left">Hard</td></tr><tr><td>309</td><td style="text-align:left">[Best Time to Buy and Sell Stock with Cooldown]</td><td style="text-align:left">Medium</td></tr><tr><td>310</td><td style="text-align:left">[Minimum Height Trees]</td><td style="text-align:left">Medium</td></tr><tr><td>311</td><td style="text-align:left">Sparse Matrix Multiplication</td><td style="text-align:left">Medium</td></tr><tr><td>312</td><td style="text-align:left">[Burst Balloons]</td><td style="text-align:left">Hard</td></tr><tr><td>313</td><td style="text-align:left">Super Ugly Number</td><td style="text-align:left">Medium</td></tr><tr><td>314</td><td style="text-align:left">Binary Tree Vertical Order Traversal</td><td style="text-align:left">Medium</td></tr><tr><td>315</td><td style="text-align:left">Count of Smaller Numbers After Self</td><td style="text-align:left">Hard</td></tr><tr><td>316</td><td style="text-align:left">[Remove Duplicate Letters]</td><td style="text-align:left">Hard</td></tr><tr><td>317</td><td style="text-align:left">Shortest Distance from All Buildings</td><td style="text-align:left">Hard</td></tr><tr><td>318</td><td style="text-align:left">Maximum Product of Word Lengths</td><td style="text-align:left">Medium</td></tr><tr><td>319</td><td style="text-align:left">Bulb Switcher</td><td style="text-align:left">Medium</td></tr><tr><td>320</td><td style="text-align:left">Generalized Abbreviation</td><td style="text-align:left">Medium</td></tr><tr><td>321</td><td style="text-align:left">Create Maximum Number</td><td style="text-align:left">Hard</td></tr><tr><td>322</td><td style="text-align:left">Coin Change</td><td style="text-align:left">Medium</td></tr><tr><td>323</td><td style="text-align:left">Number of Connected Components in an Undirected Graph</td><td style="text-align:left">Medium</td></tr><tr><td>324</td><td style="text-align:left">Wiggle Sort II</td><td style="text-align:left">Medium</td></tr><tr><td>325</td><td style="text-align:left">Maximum Size Subarray Sum Equals k</td><td style="text-align:left">Medium</td></tr><tr><td>326</td><td style="text-align:left">Power of Three</td><td style="text-align:left">Easy</td></tr><tr><td>327</td><td style="text-align:left">Count of Range Sum</td><td style="text-align:left">Hard</td></tr><tr><td>328</td><td style="text-align:left">Odd Even Linked List</td><td style="text-align:left">Medium</td></tr><tr><td>329</td><td style="text-align:left">Longest Increasing Path in a Matrix</td><td style="text-align:left">Hard</td></tr><tr><td>330</td><td style="text-align:left">Patching Array</td><td style="text-align:left">Hard</td></tr><tr><td>331</td><td style="text-align:left">Verify Preorder Serialization of a Binary Tree</td><td style="text-align:left">Medium</td></tr><tr><td>332</td><td style="text-align:left">Reconstruct Itinerary</td><td style="text-align:left">Medium</td></tr><tr><td>333</td><td style="text-align:left">Largest BST Subtree</td><td style="text-align:left">Medium</td></tr><tr><td>334</td><td style="text-align:left">Increasing Triplet Subsequence</td><td style="text-align:left">Medium</td></tr><tr><td>335</td><td style="text-align:left">Self Crossing</td><td style="text-align:left">Hard</td></tr><tr><td>336</td><td style="text-align:left">Palindrome Pairs</td><td style="text-align:left">Hard</td></tr><tr><td>337</td><td style="text-align:left">House Robber III</td><td style="text-align:left">Medium</td></tr><tr><td>338</td><td style="text-align:left">Counting Bits</td><td style="text-align:left">Medium</td></tr><tr><td>339</td><td style="text-align:left">Nested List Weight Sum</td><td style="text-align:left">Easy</td></tr><tr><td>340</td><td style="text-align:left">Longest Substring with At Most K Distinct Characters</td><td style="text-align:left">Hard</td></tr><tr><td>341</td><td style="text-align:left">Flatten Nested List Iterator</td><td style="text-align:left">Medium</td></tr><tr><td>342</td><td style="text-align:left">Power of Four</td><td style="text-align:left">Easy</td></tr><tr><td>343</td><td style="text-align:left">Integer Break</td><td style="text-align:left">Medium</td></tr><tr><td>344</td><td style="text-align:left">Reverse String</td><td style="text-align:left">Easy</td></tr><tr><td>345</td><td style="text-align:left">Reverse Vowels of a String</td><td style="text-align:left">Easy</td></tr><tr><td>346</td><td style="text-align:left">Moving Average from Data Stream</td><td style="text-align:left">Easy</td></tr><tr><td>347</td><td style="text-align:left">Top K Frequent Elements</td><td style="text-align:left">Medium</td></tr><tr><td>348</td><td style="text-align:left">Design Tic-Tac-Toe</td><td style="text-align:left">Medium</td></tr><tr><td>349</td><td style="text-align:left">Intersection of Two Arrays</td><td style="text-align:left">Easy</td></tr><tr><td>350</td><td style="text-align:left">Intersection of Two Arrays II</td><td style="text-align:left">Easy</td></tr><tr><td>351</td><td style="text-align:left">Android Unlock Patterns</td><td style="text-align:left">Medium</td></tr><tr><td>352</td><td style="text-align:left">Data Stream as Disjoint Intervals</td><td style="text-align:left">Hard</td></tr><tr><td>353</td><td style="text-align:left">Design Snake Game</td><td style="text-align:left">Medium</td></tr><tr><td>354</td><td style="text-align:left">Russian Doll Envelopes</td><td style="text-align:left">Hard</td></tr><tr><td>355</td><td style="text-align:left">Design Twitter</td><td style="text-align:left">Medium</td></tr><tr><td>356</td><td style="text-align:left">Line Reflection</td><td style="text-align:left">Medium</td></tr><tr><td>357</td><td style="text-align:left">Count Numbers with Unique Digits</td><td style="text-align:left">Medium</td></tr><tr><td>358</td><td style="text-align:left">Rearrange String k Distance Apart</td><td style="text-align:left">Hard</td></tr><tr><td>359</td><td style="text-align:left">Logger Rate Limiter</td><td style="text-align:left">Easy</td></tr><tr><td>360</td><td style="text-align:left">Sort Transformed Array</td><td style="text-align:left">Medium</td></tr><tr><td>361</td><td style="text-align:left">Bomb Enemy</td><td style="text-align:left">Medium</td></tr><tr><td>362</td><td style="text-align:left">Design Hit Counter</td><td style="text-align:left">Medium</td></tr><tr><td>363</td><td style="text-align:left">Max Sum of Rectangle No Larger Than K</td><td style="text-align:left">Hard</td></tr><tr><td>364</td><td style="text-align:left">Nested List Weight Sum II</td><td style="text-align:left">Medium</td></tr><tr><td>365</td><td style="text-align:left">Water and Jug Problem</td><td style="text-align:left">Medium</td></tr><tr><td>366</td><td style="text-align:left">Find Leaves of Binary Tree</td><td style="text-align:left">Medium</td></tr><tr><td>367</td><td style="text-align:left">Valid Perfect Square</td><td style="text-align:left">Easy</td></tr><tr><td>368</td><td style="text-align:left">Largest Divisible Subset</td><td style="text-align:left">Medium</td></tr><tr><td>369</td><td style="text-align:left">Plus One Linked List</td><td style="text-align:left">Medium</td></tr><tr><td>370</td><td style="text-align:left">Range Addition</td><td style="text-align:left">Medium</td></tr><tr><td>371</td><td style="text-align:left">Sum of Two Integers</td><td style="text-align:left">Easy</td></tr><tr><td>372</td><td style="text-align:left">Super Pow</td><td style="text-align:left">Medium</td></tr><tr><td>373</td><td style="text-align:left">Find K Pairs with Smallest Sums</td><td style="text-align:left">Medium</td></tr><tr><td>374</td><td style="text-align:left">Guess Number Higher or Lower</td><td style="text-align:left">Easy</td></tr><tr><td>375</td><td style="text-align:left">Guess Number Higher or Lower II</td><td style="text-align:left">Medium</td></tr><tr><td>376</td><td style="text-align:left">Wiggle Subsequence</td><td style="text-align:left">Medium</td></tr><tr><td>377</td><td style="text-align:left">Combination Sum IV</td><td style="text-align:left">Medium</td></tr><tr><td>378</td><td style="text-align:left">Kth Smallest Element in a Sorted Matrix</td><td style="text-align:left">Medium</td></tr><tr><td>379</td><td style="text-align:left">Design Phone Directory</td><td style="text-align:left">Medium</td></tr><tr><td>380</td><td style="text-align:left">Insert Delete GetRandom O(1)</td><td style="text-align:left">Medium</td></tr><tr><td>381</td><td style="text-align:left">Insert Delete GetRandom O(1) - Duplicates allowed</td><td style="text-align:left">Hard</td></tr><tr><td>382</td><td style="text-align:left">Linked List Random Node</td><td style="text-align:left">Medium</td></tr><tr><td>383</td><td style="text-align:left">Ransom Note</td><td style="text-align:left">Easy</td></tr><tr><td>384</td><td style="text-align:left">Shuffle an Array</td><td style="text-align:left">Medium</td></tr><tr><td>385</td><td style="text-align:left">Mini Parser</td><td style="text-align:left">Medium</td></tr><tr><td>386</td><td style="text-align:left">Lexicographical Numbers</td><td style="text-align:left">Medium</td></tr><tr><td>387</td><td style="text-align:left">First Unique Character in a String</td><td style="text-align:left">Easy</td></tr><tr><td>388</td><td style="text-align:left">Longest Absolute File Path</td><td style="text-align:left">Medium</td></tr><tr><td>389</td><td style="text-align:left">Find the Difference</td><td style="text-align:left">Easy</td></tr><tr><td>390</td><td style="text-align:left">Elimination Game</td><td style="text-align:left">Medium</td></tr><tr><td>391</td><td style="text-align:left">Perfect Rectangle</td><td style="text-align:left">Hard</td></tr><tr><td>392</td><td style="text-align:left">Is Subsequence</td><td style="text-align:left">Medium</td></tr><tr><td>393</td><td style="text-align:left">UTF-8 Validation</td><td style="text-align:left">Medium</td></tr><tr><td>394</td><td style="text-align:left">Decode String</td><td style="text-align:left">Medium</td></tr><tr><td>395</td><td style="text-align:left">Longest Substring with At Least K Repeating Characters</td><td style="text-align:left">Medium</td></tr><tr><td>396</td><td style="text-align:left">Rotate Function</td><td style="text-align:left">Medium</td></tr><tr><td>397</td><td style="text-align:left">Integer Replacement</td><td style="text-align:left">Medium</td></tr><tr><td>398</td><td style="text-align:left">Random Pick Index</td><td style="text-align:left">Medium</td></tr><tr><td>399</td><td style="text-align:left">Evaluate Division</td><td style="text-align:left">Medium</td></tr><tr><td>400</td><td style="text-align:left">Nth Digit</td><td style="text-align:left">Easy</td></tr><tr><td>401</td><td style="text-align:left">Binary Watch</td><td style="text-align:left">Easy</td></tr><tr><td>402</td><td style="text-align:left">Remove K Digits</td><td style="text-align:left">Medium</td></tr><tr><td>403</td><td style="text-align:left">Frog Jump</td><td style="text-align:left">Hard</td></tr><tr><td>404</td><td style="text-align:left">Sum of Left Leaves</td><td style="text-align:left">Easy</td></tr><tr><td>405</td><td style="text-align:left">Convert a Number to Hexadecimal</td><td style="text-align:left">Easy</td></tr><tr><td>406</td><td style="text-align:left">Queue Reconstruction by Height</td><td style="text-align:left">Medium</td></tr><tr><td>407</td><td style="text-align:left">Trapping Rain Water II</td><td style="text-align:left">Hard</td></tr><tr><td>408</td><td style="text-align:left">Valid Word Abbreviation</td><td style="text-align:left">Easy</td></tr><tr><td>409</td><td style="text-align:left">Longest Palindrome</td><td style="text-align:left">Easy</td></tr><tr><td>410</td><td style="text-align:left">Split Array Largest Sum</td><td style="text-align:left">Hard</td></tr><tr><td>411</td><td style="text-align:left">Minimum Unique Word Abbreviation</td><td style="text-align:left">Hard</td></tr><tr><td>412</td><td style="text-align:left">Fizz Buzz</td><td style="text-align:left">Easy</td></tr><tr><td>413</td><td style="text-align:left">Arithmetic Slices</td><td style="text-align:left">Medium</td></tr><tr><td>414</td><td style="text-align:left">Third Maximum Number</td><td style="text-align:left">Easy</td></tr><tr><td>415</td><td style="text-align:left"><a href="https://shineboy2013.github.io/2017/11/02/lee-415/" target="_blank" rel="noopener">Add Strings</a></td><td style="text-align:left">Easy</td></tr><tr><td>416</td><td style="text-align:left">Partition Equal Subset Sum</td><td style="text-align:left">Medium</td></tr><tr><td>417</td><td style="text-align:left">Pacific Atlantic Water Flow</td><td style="text-align:left">Medium</td></tr><tr><td>418</td><td style="text-align:left">Sentence Screen Fitting</td><td style="text-align:left">Medium</td></tr><tr><td>419</td><td style="text-align:left">Battleships in a Board</td><td style="text-align:left">Medium</td></tr><tr><td>420</td><td style="text-align:left">Strong Password Checker</td><td style="text-align:left">Hard</td></tr><tr><td>421</td><td style="text-align:left">Maximum XOR of Two Numbers in an Array</td><td style="text-align:left">Medium</td></tr><tr><td>422</td><td style="text-align:left">Valid Word Square</td><td style="text-align:left">Easy</td></tr><tr><td>423</td><td style="text-align:left">Reconstruct Original Digits from English</td><td style="text-align:left">Medium</td></tr><tr><td>424</td><td style="text-align:left">Longest Repeating Character Replacement</td><td style="text-align:left">Medium</td></tr><tr><td>425</td><td style="text-align:left">Word Squares</td><td style="text-align:left">Hard</td></tr><tr><td>432</td><td style="text-align:left">All O`one Data Structure</td><td style="text-align:left">Hard</td></tr><tr><td>433</td><td style="text-align:left">Minimum Genetic Mutation</td><td style="text-align:left">Medium</td></tr><tr><td>434</td><td style="text-align:left">Number of Segments in a String</td><td style="text-align:left">Easy</td></tr><tr><td>435</td><td style="text-align:left">Non-overlapping Intervals</td><td style="text-align:left">Medium</td></tr><tr><td>436</td><td style="text-align:left">Find Right Interval</td><td style="text-align:left">Medium</td></tr><tr><td>437</td><td style="text-align:left">Path Sum III</td><td style="text-align:left">Easy</td></tr><tr><td>438</td><td style="text-align:left">Find All Anagrams in a String</td><td style="text-align:left">Easy</td></tr><tr><td>439</td><td style="text-align:left">Ternary Expression Parser</td><td style="text-align:left">Medium</td></tr><tr><td>440</td><td style="text-align:left">K-th Smallest in Lexicographical Order</td><td style="text-align:left">Hard</td></tr><tr><td>441</td><td style="text-align:left">Arranging Coins</td><td style="text-align:left">Easy</td></tr><tr><td>442</td><td style="text-align:left">Find All Duplicates in an Array</td><td style="text-align:left">Medium</td></tr><tr><td>443</td><td style="text-align:left">String Compression</td><td style="text-align:left">Easy</td></tr><tr><td>444</td><td style="text-align:left">Sequence Reconstruction</td><td style="text-align:left">Medium</td></tr><tr><td>445</td><td style="text-align:left">Add Two Numbers II</td><td style="text-align:left">Medium</td></tr><tr><td>446</td><td style="text-align:left">Arithmetic Slices II - Subsequence</td><td style="text-align:left">Hard</td></tr><tr><td>447</td><td style="text-align:left">Number of Boomerangs</td><td style="text-align:left">Easy</td></tr><tr><td>448</td><td style="text-align:left">Find All Numbers Disappeared in an Array</td><td style="text-align:left">Easy</td></tr><tr><td>449</td><td style="text-align:left">Serialize and Deserialize BST</td><td style="text-align:left">Medium</td></tr><tr><td>450</td><td style="text-align:left">Delete Node in a BST</td><td style="text-align:left">Medium</td></tr><tr><td>451</td><td style="text-align:left">Sort Characters By Frequency</td><td style="text-align:left">Medium</td></tr><tr><td>452</td><td style="text-align:left">Minimum Number of Arrows to Burst Balloons</td><td style="text-align:left">Medium</td></tr><tr><td>453</td><td style="text-align:left">Minimum Moves to Equal Array Elements</td><td style="text-align:left">Easy</td></tr><tr><td>454</td><td style="text-align:left">4Sum II</td><td style="text-align:left">Medium</td></tr><tr><td>455</td><td style="text-align:left">Assign Cookies</td><td style="text-align:left">Easy</td></tr><tr><td>456</td><td style="text-align:left">132 Pattern</td><td style="text-align:left">Medium</td></tr><tr><td>457</td><td style="text-align:left">Circular Array Loop</td><td style="text-align:left">Medium</td></tr><tr><td>458</td><td style="text-align:left">Poor Pigs</td><td style="text-align:left">Easy</td></tr><tr><td>459</td><td style="text-align:left">Repeated Substring Pattern</td><td style="text-align:left">Easy</td></tr><tr><td>460</td><td style="text-align:left">LFU Cache</td><td style="text-align:left">Hard</td></tr><tr><td>461</td><td style="text-align:left">Hamming Distance</td><td style="text-align:left">Easy</td></tr><tr><td>462</td><td style="text-align:left">Minimum Moves to Equal Array Elements II</td><td style="text-align:left">Medium</td></tr><tr><td>463</td><td style="text-align:left">Island Perimeter</td><td style="text-align:left">Easy</td></tr><tr><td>464</td><td style="text-align:left">Can I Win</td><td style="text-align:left">Medium</td></tr><tr><td>465</td><td style="text-align:left">Optimal Account Balancing</td><td style="text-align:left">Hard</td></tr><tr><td>466</td><td style="text-align:left">Count The Repetitions</td><td style="text-align:left">Hard</td></tr><tr><td>467</td><td style="text-align:left">Unique Substrings in Wraparound String</td><td style="text-align:left">Medium</td></tr><tr><td>468</td><td style="text-align:left">Validate IP Address</td><td style="text-align:left">Medium</td></tr><tr><td>469</td><td style="text-align:left">Convex Polygon</td><td style="text-align:left">Medium</td></tr><tr><td>471</td><td style="text-align:left">Encode String with Shortest Length</td><td style="text-align:left">Hard</td></tr><tr><td>472</td><td style="text-align:left">Concatenated Words</td><td style="text-align:left">Hard</td></tr><tr><td>473</td><td style="text-align:left">Matchsticks to Square</td><td style="text-align:left">Medium</td></tr><tr><td>474</td><td style="text-align:left">Ones and Zeroes</td><td style="text-align:left">Medium</td></tr><tr><td>475</td><td style="text-align:left">Heaters</td><td style="text-align:left">Easy</td></tr><tr><td>476</td><td style="text-align:left">Number Complement</td><td style="text-align:left">Easy</td></tr><tr><td>477</td><td style="text-align:left">Total Hamming Distance</td><td style="text-align:left">Medium</td></tr><tr><td>479</td><td style="text-align:left">Largest Palindrome Product</td><td style="text-align:left">Easy</td></tr><tr><td>480</td><td style="text-align:left">Sliding Window Median</td><td style="text-align:left">Hard</td></tr><tr><td>481</td><td style="text-align:left">Magical String</td><td style="text-align:left">Medium</td></tr><tr><td>482</td><td style="text-align:left">License Key Formatting</td><td style="text-align:left">Easy</td></tr><tr><td>483</td><td style="text-align:left">Smallest Good Base</td><td style="text-align:left">Hard</td></tr><tr><td>484</td><td style="text-align:left">Find Permutation</td><td style="text-align:left">Medium</td></tr><tr><td>485</td><td style="text-align:left">Max Consecutive Ones</td><td style="text-align:left">Easy</td></tr><tr><td>486</td><td style="text-align:left">Predict the Winner</td><td style="text-align:left">Medium</td></tr><tr><td>487</td><td style="text-align:left">Max Consecutive Ones II</td><td style="text-align:left">Medium</td></tr><tr><td>488</td><td style="text-align:left">Zuma Game</td><td style="text-align:left">Hard</td></tr><tr><td>490</td><td style="text-align:left">The Maze</td><td style="text-align:left">Medium</td></tr><tr><td>491</td><td style="text-align:left">Increasing Subsequences</td><td style="text-align:left">Medium</td></tr><tr><td>492</td><td style="text-align:left">Construct the Rectangle</td><td style="text-align:left">Easy</td></tr><tr><td>493</td><td style="text-align:left">Reverse Pairs</td><td style="text-align:left">Hard</td></tr><tr><td>494</td><td style="text-align:left">Target Sum</td><td style="text-align:left">Medium</td></tr><tr><td>495</td><td style="text-align:left">Teemo Attacking</td><td style="text-align:left">Medium</td></tr><tr><td>496</td><td style="text-align:left">Next Greater Element I</td><td style="text-align:left">Easy</td></tr><tr><td>498</td><td style="text-align:left">Diagonal Traverse</td><td style="text-align:left">Medium</td></tr><tr><td>499</td><td style="text-align:left">The Maze III</td><td style="text-align:left">Hard</td></tr><tr><td>500</td><td style="text-align:left">Keyboard Row</td><td style="text-align:left">Easy</td></tr><tr><td>501</td><td style="text-align:left">Find Mode in Binary Search Tree</td><td style="text-align:left">Easy</td></tr><tr><td>502</td><td style="text-align:left">IPO</td><td style="text-align:left">Hard</td></tr><tr><td>503</td><td style="text-align:left">Next Greater Element II</td><td style="text-align:left">Medium</td></tr><tr><td>504</td><td style="text-align:left">Base 7</td><td style="text-align:left">Easy</td></tr><tr><td>505</td><td style="text-align:left">The Maze II</td><td style="text-align:left">Medium</td></tr><tr><td>506</td><td style="text-align:left">Relative Ranks</td><td style="text-align:left">Easy</td></tr><tr><td>507</td><td style="text-align:left">Perfect Number</td><td style="text-align:left">Easy</td></tr><tr><td>508</td><td style="text-align:left">Most Frequent Subtree Sum</td><td style="text-align:left">Medium</td></tr><tr><td>513</td><td style="text-align:left">Find Bottom Left Tree Value</td><td style="text-align:left">Medium</td></tr><tr><td>514</td><td style="text-align:left">Freedom Trail</td><td style="text-align:left">Hard</td></tr><tr><td>515</td><td style="text-align:left">Find Largest Value in Each Tree Row</td><td style="text-align:left">Medium</td></tr><tr><td>516</td><td style="text-align:left">Longest Palindromic Subsequence</td><td style="text-align:left">Medium</td></tr><tr><td>517</td><td style="text-align:left">Super Washing Machines</td><td style="text-align:left">Hard</td></tr><tr><td>518</td><td style="text-align:left">Coin Change 2</td><td style="text-align:left">Medium</td></tr><tr><td>520</td><td style="text-align:left">Detect Capital</td><td style="text-align:left">Easy</td></tr><tr><td>521</td><td style="text-align:left">Longest Uncommon Subsequence IÊ</td><td style="text-align:left">Easy</td></tr><tr><td>522</td><td style="text-align:left">Longest Uncommon Subsequence II</td><td style="text-align:left">Medium</td></tr><tr><td>523</td><td style="text-align:left">Continuous Subarray Sum</td><td style="text-align:left">Medium</td></tr><tr><td>524</td><td style="text-align:left">Longest Word in Dictionary through Deleting</td><td style="text-align:left">Medium</td></tr><tr><td>525</td><td style="text-align:left">Contiguous Array</td><td style="text-align:left">Medium</td></tr><tr><td>526</td><td style="text-align:left">Beautiful Arrangement</td><td style="text-align:left">Medium</td></tr><tr><td>527</td><td style="text-align:left">Word Abbreviation</td><td style="text-align:left">Hard</td></tr><tr><td>529</td><td style="text-align:left">Minesweeper</td><td style="text-align:left">Medium</td></tr><tr><td>530</td><td style="text-align:left">Minimum Absolute Difference in BST</td><td style="text-align:left">Easy</td></tr><tr><td>531</td><td style="text-align:left">Lonely Pixel I</td><td style="text-align:left">Medium</td></tr><tr><td>532</td><td style="text-align:left">K-diff Pairs in an Array</td><td style="text-align:left">Easy</td></tr><tr><td>533</td><td style="text-align:left">Lonely Pixel II</td><td style="text-align:left">Medium</td></tr><tr><td>534</td><td style="text-align:left">Design TinyURL</td><td style="text-align:left">Medium</td></tr><tr><td>535</td><td style="text-align:left">Encode and Decode TinyURL</td><td style="text-align:left">Medium</td></tr><tr><td>536</td><td style="text-align:left">Construct Binary Tree from String</td><td style="text-align:left">Medium</td></tr><tr><td>537</td><td style="text-align:left">Complex Number Multiplication</td><td style="text-align:left">Medium</td></tr><tr><td>538</td><td style="text-align:left">Convert BST to Greater Tree</td><td style="text-align:left">Easy</td></tr><tr><td>539</td><td style="text-align:left">Minimum Time Difference</td><td style="text-align:left">Medium</td></tr><tr><td>540</td><td style="text-align:left">Single Element in a Sorted Array</td><td style="text-align:left">Medium</td></tr><tr><td>541</td><td style="text-align:left">Reverse String II</td><td style="text-align:left">Easy</td></tr><tr><td>542</td><td style="text-align:left">01 Matrix</td><td style="text-align:left">Medium</td></tr><tr><td>543</td><td style="text-align:left">Diameter of Binary Tree</td><td style="text-align:left">Easy</td></tr><tr><td>544</td><td style="text-align:left">Output Contest Matches</td><td style="text-align:left">Medium</td></tr><tr><td>545</td><td style="text-align:left">Boundary of Binary Tree</td><td style="text-align:left">Medium</td></tr><tr><td>546</td><td style="text-align:left">Remove Boxes</td><td style="text-align:left">Hard</td></tr><tr><td>547</td><td style="text-align:left">Friend Circles</td><td style="text-align:left">Medium</td></tr><tr><td>548</td><td style="text-align:left">Split Array with Equal Sum</td><td style="text-align:left">Medium</td></tr><tr><td>549</td><td style="text-align:left">Binary Tree Longest Consecutive Sequence II</td><td style="text-align:left">Medium</td></tr><tr><td>551</td><td style="text-align:left">Student Attendance Record I</td><td style="text-align:left">Easy</td></tr><tr><td>552</td><td style="text-align:left">Student Attendance Record II</td><td style="text-align:left">Hard</td></tr><tr><td>553</td><td style="text-align:left">Optimal Division</td><td style="text-align:left">Medium</td></tr><tr><td>554</td><td style="text-align:left">Brick Wall</td><td style="text-align:left">Medium</td></tr><tr><td>555</td><td style="text-align:left">Split Concatenated Strings</td><td style="text-align:left">Medium</td></tr><tr><td>556</td><td style="text-align:left">Next Greater Element III</td><td style="text-align:left">Medium</td></tr><tr><td>557</td><td style="text-align:left"><a href="https://shineboy2013.github.io/2017/11/02/lee-557/" target="_blank" rel="noopener">Reverse Words in a String III</a></td><td style="text-align:left">Easy</td></tr><tr><td>560</td><td style="text-align:left">Subarray Sum Equals K</td><td style="text-align:left">Medium</td></tr><tr><td>561</td><td style="text-align:left">Array Partition I</td><td style="text-align:left">Easy</td></tr><tr><td>562</td><td style="text-align:left">Longest Line of Consecutive One in Matrix</td><td style="text-align:left">Medium</td></tr><tr><td>563</td><td style="text-align:left">Binary Tree Tilt</td><td style="text-align:left">Easy</td></tr><tr><td>564</td><td style="text-align:left">Find the Closest Palindrome</td><td style="text-align:left">Hard</td></tr><tr><td>565</td><td style="text-align:left">Array Nesting</td><td style="text-align:left">Medium</td></tr><tr><td>566</td><td style="text-align:left">Reshape the Matrix</td><td style="text-align:left">Easy</td></tr><tr><td>567</td><td style="text-align:left">Permutation in String</td><td style="text-align:left">Medium</td></tr><tr><td>568</td><td style="text-align:left">Maximum Vacation Days</td><td style="text-align:left">Hard</td></tr><tr><td>569</td><td style="text-align:left">Median Employee Salary</td><td style="text-align:left">Hard</td></tr><tr><td>570</td><td style="text-align:left">Managers with at Least 5 Direct Reports</td><td style="text-align:left">Medium</td></tr><tr><td>571</td><td style="text-align:left">Find Median Given Frequency of Numbers</td><td style="text-align:left">Hard</td></tr><tr><td>572</td><td style="text-align:left">Subtree of Another Tree</td><td style="text-align:left">Easy</td></tr><tr><td>573</td><td style="text-align:left">Squirrel Simulation</td><td style="text-align:left">Medium</td></tr><tr><td>574</td><td style="text-align:left">Winning Candidate</td><td style="text-align:left">Medium</td></tr><tr><td>575</td><td style="text-align:left">Distribute Candies</td><td style="text-align:left">Easy</td></tr><tr><td>576</td><td style="text-align:left">Out of Boundary Paths</td><td style="text-align:left">Medium</td></tr><tr><td>577</td><td style="text-align:left">Employee Bonus</td><td style="text-align:left">Easy</td></tr><tr><td>578</td><td style="text-align:left">Get Highest Answer Rate Question</td><td style="text-align:left">Medium</td></tr><tr><td>579</td><td style="text-align:left">Find Cumulative Salary of an Employee</td><td style="text-align:left">Hard</td></tr><tr><td>580</td><td style="text-align:left">Count Student Number in Departments</td><td style="text-align:left">Medium</td></tr><tr><td>581</td><td style="text-align:left">Shortest Unsorted Continuous Subarray</td><td style="text-align:left">Easy</td></tr><tr><td>582</td><td style="text-align:left">Kill Process</td><td style="text-align:left">Medium</td></tr><tr><td>583</td><td style="text-align:left">Delete Operation for Two Strings</td><td style="text-align:left">Medium</td></tr><tr><td>584</td><td style="text-align:left">Find Customer Referee</td><td style="text-align:left">Easy</td></tr><tr><td>585</td><td style="text-align:left">Investments in 2016</td><td style="text-align:left">Medium</td></tr><tr><td>586</td><td style="text-align:left">Customer Placing the Largest Number of Orders</td><td style="text-align:left">Easy</td></tr><tr><td>587</td><td style="text-align:left">Erect the Fence</td><td style="text-align:left">Hard</td></tr><tr><td>588</td><td style="text-align:left">Design In-Memory File System</td><td style="text-align:left">Hard</td></tr><tr><td>591</td><td style="text-align:left">Tag Validator</td><td style="text-align:left">Hard</td></tr><tr><td>592</td><td style="text-align:left">Fraction Addition and Subtraction</td><td style="text-align:left">Medium</td></tr><tr><td>593</td><td style="text-align:left">Valid Square</td><td style="text-align:left">Medium</td></tr><tr><td>594</td><td style="text-align:left">Longest Harmonious Subsequence</td><td style="text-align:left">Easy</td></tr><tr><td>595</td><td style="text-align:left">Big Countries</td><td style="text-align:left">Easy</td></tr><tr><td>596</td><td style="text-align:left">Classes More Than 5 Students</td><td style="text-align:left">Easy</td></tr><tr><td>597</td><td style="text-align:left">Friend Requests I: Overall Acceptance Rate</td><td style="text-align:left">Easy</td></tr><tr><td>598</td><td style="text-align:left">Range Addition II</td><td style="text-align:left">Easy</td></tr><tr><td>599</td><td style="text-align:left">Minimum Index Sum of Two Lists</td><td style="text-align:left">Easy</td></tr><tr><td>600</td><td style="text-align:left">Non-negative Integers without Consecutive Ones</td><td style="text-align:left">Hard</td></tr><tr><td>601</td><td style="text-align:left">Human Traffic of Stadium</td><td style="text-align:left">Hard</td></tr><tr><td>602</td><td style="text-align:left">Friend Requests II: Who Has the Most Friends</td><td style="text-align:left">Medium</td></tr><tr><td>603</td><td style="text-align:left">Consecutive Available Seats</td><td style="text-align:left">Easy</td></tr><tr><td>604</td><td style="text-align:left">Design Compressed String Iterator</td><td style="text-align:left">Easy</td></tr><tr><td>605</td><td style="text-align:left">Can Place Flowers</td><td style="text-align:left">Easy</td></tr><tr><td>606</td><td style="text-align:left">Construct String from Binary Tree</td><td style="text-align:left">Easy</td></tr><tr><td>607</td><td style="text-align:left">Sales Person</td><td style="text-align:left">Easy</td></tr><tr><td>608</td><td style="text-align:left">Tree Node</td><td style="text-align:left">Medium</td></tr><tr><td>609</td><td style="text-align:left">Find Duplicate File in System</td><td style="text-align:left">Medium</td></tr><tr><td>610</td><td style="text-align:left">Triangle Judgement</td><td style="text-align:left">Easy</td></tr><tr><td>611</td><td style="text-align:left">Valid Triangle Number</td><td style="text-align:left">Medium</td></tr><tr><td>612</td><td style="text-align:left">Shortest Distance in a Plane</td><td style="text-align:left">Medium</td></tr><tr><td>613</td><td style="text-align:left">Shortest Distance in a Line</td><td style="text-align:left">Easy</td></tr><tr><td>614</td><td style="text-align:left">Second Degree Follower</td><td style="text-align:left">Medium</td></tr><tr><td>615</td><td style="text-align:left">Average Salary: Departments VS Company</td><td style="text-align:left">Hard</td></tr><tr><td>616</td><td style="text-align:left">Add Bold Tag in String</td><td style="text-align:left">Medium</td></tr><tr><td>617</td><td style="text-align:left">Merge Two Binary Trees</td><td style="text-align:left">Easy</td></tr><tr><td>618</td><td style="text-align:left">Students Report By Geography</td><td style="text-align:left">Hard</td></tr><tr><td>619</td><td style="text-align:left">Biggest Single Number</td><td style="text-align:left">Easy</td></tr><tr><td>620</td><td style="text-align:left">Not Boring Movies</td><td style="text-align:left">Easy</td></tr><tr><td>621</td><td style="text-align:left">Task Scheduler</td><td style="text-align:left">Medium</td></tr><tr><td>623</td><td style="text-align:left">Add One Row to Tree</td><td style="text-align:left">Medium</td></tr><tr><td>624</td><td style="text-align:left">Maximum Distance in Arrays</td><td style="text-align:left">Easy</td></tr><tr><td>625</td><td style="text-align:left">Minimum Factorization</td><td style="text-align:left">Medium</td></tr><tr><td>626</td><td style="text-align:left">Exchange Seats</td><td style="text-align:left">Medium</td></tr><tr><td>627</td><td style="text-align:left">Swap Salary</td><td style="text-align:left">Easy</td></tr><tr><td>628</td><td style="text-align:left">Maximum Product of Three Numbers</td><td style="text-align:left">Easy</td></tr><tr><td>629</td><td style="text-align:left">K Inverse Pairs Array</td><td style="text-align:left">Hard</td></tr><tr><td>630</td><td style="text-align:left">Course Schedule III</td><td style="text-align:left">Hard</td></tr><tr><td>631</td><td style="text-align:left">Design Excel Sum Formula</td><td style="text-align:left">Hard</td></tr><tr><td>632</td><td style="text-align:left">Smallest Range</td><td style="text-align:left">Hard</td></tr><tr><td>633</td><td style="text-align:left">Sum of Square Numbers</td><td style="text-align:left">Easy</td></tr><tr><td>634</td><td style="text-align:left">Find the Derangement of An Array</td><td style="text-align:left">Medium</td></tr><tr><td>635</td><td style="text-align:left">Design Log Storage System</td><td style="text-align:left">Medium</td></tr><tr><td>636</td><td style="text-align:left">Exclusive Time of Functions</td><td style="text-align:left">Medium</td></tr><tr><td>637</td><td style="text-align:left">Average of Levels in Binary Tree</td><td style="text-align:left">Easy</td></tr><tr><td>638</td><td style="text-align:left">Shopping Offers</td><td style="text-align:left">Medium</td></tr><tr><td>639</td><td style="text-align:left">Decode Ways II</td><td style="text-align:left">Hard</td></tr><tr><td>640</td><td style="text-align:left">Solve the Equation</td><td style="text-align:left">Medium</td></tr><tr><td>642</td><td style="text-align:left">Design Search Autocomplete System</td><td style="text-align:left">Hard</td></tr><tr><td>643</td><td style="text-align:left">Maximum Average Subarray I</td><td style="text-align:left">Easy</td></tr><tr><td>644</td><td style="text-align:left">Maximum Average Subarray II</td><td style="text-align:left">Hard</td></tr><tr><td>645</td><td style="text-align:left">Set Mismatch</td><td style="text-align:left">Easy</td></tr><tr><td>646</td><td style="text-align:left">Maximum Length of Pair Chain</td><td style="text-align:left">Medium</td></tr><tr><td>647</td><td style="text-align:left">Palindromic Substrings</td><td style="text-align:left">Medium</td></tr><tr><td>648</td><td style="text-align:left">Replace Words</td><td style="text-align:left">Medium</td></tr><tr><td>649</td><td style="text-align:left">Dota2 Senate</td><td style="text-align:left">Medium</td></tr><tr><td>650</td><td style="text-align:left">2 Keys Keyboard</td><td style="text-align:left">Medium</td></tr><tr><td>651</td><td style="text-align:left">4 Keys Keyboard</td><td style="text-align:left">Medium</td></tr><tr><td>652</td><td style="text-align:left">Find Duplicate Subtrees</td><td style="text-align:left">Medium</td></tr><tr><td>653</td><td style="text-align:left">Two Sum IV - Input is a BST</td><td style="text-align:left">Easy</td></tr><tr><td>654</td><td style="text-align:left">Maximum Binary Tree</td><td style="text-align:left">Medium</td></tr><tr><td>655</td><td style="text-align:left">Print Binary Tree</td><td style="text-align:left">Medium</td></tr><tr><td>656</td><td style="text-align:left">Coin Path</td><td style="text-align:left">Hard</td></tr><tr><td>657</td><td style="text-align:left">Judge Route Circle</td><td style="text-align:left">Easy</td></tr><tr><td>658</td><td style="text-align:left">Find K Closest Elements</td><td style="text-align:left">Medium</td></tr><tr><td>659</td><td style="text-align:left">Split Array into Consecutive Subsequences</td><td style="text-align:left">Medium</td></tr><tr><td>660</td><td style="text-align:left">Remove 9</td><td style="text-align:left">Hard</td></tr><tr><td>661</td><td style="text-align:left">Image Smoother</td><td style="text-align:left">Easy</td></tr><tr><td>662</td><td style="text-align:left">Maximum Width of Binary Tree</td><td style="text-align:left">Medium</td></tr><tr><td>663</td><td style="text-align:left">Equal Tree Partition</td><td style="text-align:left">Medium</td></tr><tr><td>664</td><td style="text-align:left">Strange Printer</td><td style="text-align:left">Hard</td></tr><tr><td>665</td><td style="text-align:left">Non-decreasing Array</td><td style="text-align:left">Easy</td></tr><tr><td>666</td><td style="text-align:left">Path Sum IV</td><td style="text-align:left">Medium</td></tr><tr><td>667</td><td style="text-align:left">Beautiful Arrangement II</td><td style="text-align:left">Medium</td></tr><tr><td>668</td><td style="text-align:left">Kth Smallest Number in Multiplication Table</td><td style="text-align:left">Hard</td></tr><tr><td>669</td><td style="text-align:left">Trim a Binary Search Tree</td><td style="text-align:left">Easy</td></tr><tr><td>670</td><td style="text-align:left">Maximum Swap</td><td style="text-align:left">Medium</td></tr><tr><td>671</td><td style="text-align:left">Second Minimum Node In a Binary Tree</td><td style="text-align:left">Easy</td></tr><tr><td>672</td><td style="text-align:left">Bulb Switcher II</td><td style="text-align:left">Medium</td></tr><tr><td>673</td><td style="text-align:left">Number of Longest Increasing Subsequence</td><td style="text-align:left">Medium</td></tr><tr><td>674</td><td style="text-align:left">Longest Continuous Increasing Subsequence</td><td style="text-align:left">Easy</td></tr><tr><td>675</td><td style="text-align:left">Cut Off Trees for Golf Event</td><td style="text-align:left">Hard</td></tr><tr><td>676</td><td style="text-align:left">Implement Magic Dictionary</td><td style="text-align:left">Medium</td></tr><tr><td>677</td><td style="text-align:left">Map Sum Pairs</td><td style="text-align:left">Medium</td></tr><tr><td>678</td><td style="text-align:left">Valid Parenthesis String</td><td style="text-align:left">Medium</td></tr><tr><td>679</td><td style="text-align:left">24 Game</td><td style="text-align:left">Hard</td></tr><tr><td>680</td><td style="text-align:left">Valid Palindrome II</td><td style="text-align:left">Easy</td></tr><tr><td>681</td><td style="text-align:left">Next Closest Time</td><td style="text-align:left">Medium</td></tr><tr><td>682</td><td style="text-align:left">Baseball Game</td><td style="text-align:left">Easy</td></tr><tr><td>683</td><td style="text-align:left">K Empty Slots</td><td style="text-align:left">Hard</td></tr><tr><td>684</td><td style="text-align:left">Redundant Connection</td><td style="text-align:left">Medium</td></tr><tr><td>685</td><td style="text-align:left">Redundant Connection II</td><td style="text-align:left">Hard</td></tr><tr><td>686</td><td style="text-align:left">Repeated String Match</td><td style="text-align:left">Easy</td></tr><tr><td>687</td><td style="text-align:left">Longest Univalue Path</td><td style="text-align:left">Easy</td></tr><tr><td>688</td><td style="text-align:left">Knight Probability in Chessboard</td><td style="text-align:left">Medium</td></tr><tr><td>689</td><td style="text-align:left">Maximum Sum of 3 Non-Overlapping Subarrays</td><td style="text-align:left">Hard</td></tr><tr><td>690</td><td style="text-align:left">Employee Importance</td><td style="text-align:left">Easy</td></tr><tr><td>691</td><td style="text-align:left">Stickers to Spell Word</td><td style="text-align:left">Hard</td></tr><tr><td>692</td><td style="text-align:left">Top K Frequent Words</td><td style="text-align:left">Medium</td></tr><tr><td>693</td><td style="text-align:left">Binary Number with Alternating Bits</td><td style="text-align:left">Easy</td></tr><tr><td>694</td><td style="text-align:left">Number of Distinct Islands</td><td style="text-align:left">Medium</td></tr><tr><td>695</td><td style="text-align:left">Max Area of Island</td><td style="text-align:left">Easy</td></tr><tr><td>696</td><td style="text-align:left">Count Binary Substrings</td><td style="text-align:left">Easy</td></tr><tr><td>697</td><td style="text-align:left">Degree of an Array</td><td style="text-align:left">Easy</td></tr><tr><td>698</td><td style="text-align:left">Partition to K Equal Sum Subsets</td><td style="text-align:left">Medium</td></tr><tr><td>699</td><td style="text-align:left">Falling Squares</td><td style="text-align:left">Hard</td></tr><tr><td>711</td><td style="text-align:left">Number of Distinct Islands II</td><td style="text-align:left">Hard</td></tr><tr><td>712</td><td style="text-align:left">Minimum ASCII Delete Sum for Two Strings</td><td style="text-align:left">Medium</td></tr><tr><td>713</td><td style="text-align:left">Subarray Product Less Than K</td><td style="text-align:left">Medium</td></tr><tr><td>714</td><td style="text-align:left">Best Time to Buy and Sell Stock with Transaction Fee</td><td style="text-align:left">Medium</td></tr><tr><td>715</td><td style="text-align:left">Range Module</td><td style="text-align:left">Hard</td></tr><tr><td>716</td><td style="text-align:left">Max Stack</td><td style="text-align:left">Hard</td></tr><tr><td>717</td><td style="text-align:left">1-bit and 2-bit Characters</td><td style="text-align:left">Easy</td></tr><tr><td>718</td><td style="text-align:left">Maximum Length of Repeated Subarray</td><td style="text-align:left">Medium</td></tr><tr><td>719</td><td style="text-align:left">Find K-th Smallest Pair Distance</td><td style="text-align:left">Hard</td></tr><tr><td>720</td><td style="text-align:left">Longest Word in Dictionary</td><td style="text-align:left">Easy</td></tr><tr><td>721</td><td style="text-align:left">Accounts Merge</td><td style="text-align:left">Medium</td></tr><tr><td>722</td><td style="text-align:left">Remove Comments</td><td style="text-align:left">Medium</td></tr><tr><td>723</td><td style="text-align:left">Candy Crush</td><td style="text-align:left">Medium</td></tr><tr><td>724</td><td style="text-align:left">Find Pivot Index</td><td style="text-align:left">Easy</td></tr><tr><td>725</td><td style="text-align:left">Split Linked List in Parts</td><td style="text-align:left">Medium</td></tr><tr><td>726</td><td style="text-align:left">Number of Atoms</td><td style="text-align:left">Hard</td></tr><tr><td>727</td><td style="text-align:left">Minimum Window Subsequence</td><td style="text-align:left">Hard</td></tr><tr><td>728</td><td style="text-align:left">Self Dividing Numbers</td><td style="text-align:left">Easy</td></tr><tr><td>729</td><td style="text-align:left">My Calendar I</td><td style="text-align:left">Medium</td></tr><tr><td>730</td><td style="text-align:left">Count Different Palindromic Subsequences</td><td style="text-align:left">Hard</td></tr><tr><td>731</td><td style="text-align:left">My Calendar II</td><td style="text-align:left">Medium</td></tr><tr><td>732</td><td style="text-align:left">My Calendar III</td><td style="text-align:left">Hard</td></tr><tr><td>733</td><td style="text-align:left">Flood Fill</td><td style="text-align:left">Easy</td></tr><tr><td>734</td><td style="text-align:left">Sentence Similarity</td><td style="text-align:left">Easy</td></tr><tr><td>735</td><td style="text-align:left">Asteroid Collision</td><td style="text-align:left">Medium</td></tr><tr><td>736</td><td style="text-align:left">Parse Lisp Expression</td><td style="text-align:left">Hard</td></tr><tr><td>737</td><td style="text-align:left">Sentence Similarity II</td><td style="text-align:left">Medium</td></tr><tr><td>738</td><td style="text-align:left">Monotone Increasing Digits</td><td style="text-align:left">Medium</td></tr><tr><td>739</td><td style="text-align:left">Daily Temperatures</td><td style="text-align:left">Medium</td></tr><tr><td>740</td><td style="text-align:left">Delete and Earn</td><td style="text-align:left">Medium</td></tr><tr><td>741</td><td style="text-align:left">Cherry Pickup</td><td style="text-align:left">Hard</td></tr><tr><td>742</td><td style="text-align:left">Closest Leaf in a Binary TreeNew</td><td style="text-align:left">Medium</td></tr><tr><td>743</td><td style="text-align:left">Network Delay TimeNew</td><td style="text-align:left">Medium</td></tr><tr><td>744</td><td style="text-align:left">Find Smallest Letter Greater Than TargetNew</td><td style="text-align:left">Easy</td></tr><tr><td>745</td><td style="text-align:left">Prefix and Suffix SearchNew</td><td style="text-align:left">Hard</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;LeetCode 目录&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;#&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;Title&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;Diffi
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 557 Reverse Words in a String III</title>
    <link href="https://shineboy2013.github.com/2017/11/02/lee-557/"/>
    <id>https://shineboy2013.github.com/2017/11/02/lee-557/</id>
    <published>2017-11-02T11:43:32.737Z</published>
    <updated>2017-12-05T04:44:50.862Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/reverse-words-in-a-string-iii/" target="_blank" rel="noopener">LeetCode 557 Reverse Words in a String III</a></strong></p><p>Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.</p><p><strong>Example 1:</strong></p><pre>Input: "Let's take LeetCode contest"Output: "s'teL ekat edoCteeL tsetnoc"</pre><p><strong>Note:</strong>In the string, each word is separated by single space and there will not be any extra space in the string.</p><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a><strong>题目大意：</strong></h3><p>给定字符串，将每个单词逐字符逆置，返回新字符串。注意：字符串中单词之间有且只有1个空格分开。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a><strong>解题思路：</strong></h3><p>这里考到StringBuilder，对于字符串连接效率高。还有一个小技巧，就是往输入参数附加一个空格，这样for循环结束后不用特别处理边界情况。<br>第一种方法是以单词为扫描单位，把字符串分成单词字符串数组，然后把每个单词反转及一个空格加入到结果sb中。<br>第二种方法是以字符为扫描单位，遇到空格是，就把之前存入的word放入sb中，再进行下一轮word扫描。</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ol><li>用StringBuilder</li><li>末尾加入空格</li></ol><h3 id="Java代码："><a href="#Java代码：" class="headerlink" title="Java代码："></a><strong>Java代码：</strong></h3><p>第一种方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">String[] tokens = s.split(<span class="string">" "</span>);</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span>(String token : tokens)</span><br><span class="line">sb.append(<span class="keyword">new</span> StringBuilder(token).reverse().toString()+<span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sb.toString().trim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二种方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">s = s+<span class="string">" "</span>;</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">StringBuilder word = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray())&#123;</span><br><span class="line"><span class="keyword">if</span>(c!=<span class="string">' '</span>)</span><br><span class="line">word.append(c);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">sb.append(word.reverse().toString()+<span class="string">" "</span>);</span><br><span class="line">word = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sb.toString().trim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a><strong>算法分析：</strong></h3><p>两种方法时间复杂度为<code>O(n)</code>，n为字符串长度。第一种方法空间复杂度为<code>O(n)</code>，而第二种方法为<code>O(1)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/reverse-words-in-a-string-iii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 557 Reverse Words 
      
    
    </summary>
    
    
      <category term="String" scheme="https://shineboy2013.github.com/tags/String/"/>
    
  </entry>
  
</feed>
